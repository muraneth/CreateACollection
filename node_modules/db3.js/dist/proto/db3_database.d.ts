import { MessageType } from "@protobuf-ts/runtime";
/**
 *
 * the definition of database
 *
 *
 * @generated from protobuf message db3_database_proto.Database
 */
export interface Database {
    /**
     * @generated from protobuf field: bytes address = 1;
     */
    address: Uint8Array;
    /**
     * the owner of the Database
     *
     * @generated from protobuf field: bytes sender = 2;
     */
    sender: Uint8Array;
    /**
     * the history of database modification
     *
     * @generated from protobuf field: repeated bytes tx = 3;
     */
    tx: Uint8Array[];
    /**
     * @generated from protobuf field: map<string, db3_database_proto.Collection> collections = 4;
     */
    collections: {
        [key: string]: Collection;
    };
}
/**
 * @generated from protobuf message db3_database_proto.Collection
 */
export interface Collection {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated db3_database_proto.Index index_list = 3;
     */
    indexList: Index[];
}
/**
 * @generated from protobuf message db3_database_proto.Document
 */
export interface Document {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: bytes doc = 2;
     */
    doc: Uint8Array;
    /**
     * @generated from protobuf field: bytes owner = 3;
     */
    owner: Uint8Array;
    /**
     * @generated from protobuf field: bytes tx_id = 4;
     */
    txId: Uint8Array;
}
/**
 * @generated from protobuf message db3_database_proto.Index
 */
export interface Index {
    /**
     * Output only. A server defined name for this index.
     * The form of this name for composite indexes will be:
     * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{composite_index_id}`
     * For single field indexes, this field will be empty.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Id of the index filed in the collection
     *
     * @generated from protobuf field: uint32 id = 2;
     */
    id: number;
    /**
     * The fields supported by this index.
     *
     * For composite indexes, this is always 2 or more fields.
     * The last field entry is always for the field path `__name__`. If, on
     * creation, `__name__` was not specified as the last field, it will be added
     * automatically with the same direction as that of the last field defined. If
     * the final field in a composite index is not directional, the `__name__`
     * will be ordered ASCENDING (unless explicitly specified).
     *
     * For single field indexes, this will always be exactly one entry with a
     * field path equal to the field path of the associated field.
     *
     * @generated from protobuf field: repeated db3_database_proto.Index.IndexField fields = 3;
     */
    fields: Index_IndexField[];
}
/**
 * A field in an index.
 * The field_path describes which field is indexed, the value_mode describes
 * how the field value is indexed.
 *
 * @generated from protobuf message db3_database_proto.Index.IndexField
 */
export interface Index_IndexField {
    /**
     * Can be __name__.
     * For single field indexes, this must match the name of the field or may
     * be omitted.
     *
     * @generated from protobuf field: string field_path = 1;
     */
    fieldPath: string;
    /**
     * @generated from protobuf oneof: value_mode
     */
    valueMode: {
        oneofKind: "order";
        /**
         * Indicates that this field supports ordering by the specified order or
         * comparing using =, !=, <, <=, >, >=.
         *
         * @generated from protobuf field: db3_database_proto.Index.IndexField.Order order = 2;
         */
        order: Index_IndexField_Order;
    } | {
        oneofKind: "arrayConfig";
        /**
         * Indicates that this field supports operations on `array_value`s.
         *
         * @generated from protobuf field: db3_database_proto.Index.IndexField.ArrayConfig array_config = 3;
         */
        arrayConfig: Index_IndexField_ArrayConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The supported orderings.
 *
 * @generated from protobuf enum db3_database_proto.Index.IndexField.Order
 */
export declare enum Index_IndexField_Order {
    /**
     * The ordering is unspecified. Not a valid option.
     *
     * @generated from protobuf enum value: ORDER_UNSPECIFIED = 0;
     */
    ORDER_UNSPECIFIED = 0,
    /**
     * The field is ordered by ascending field value.
     *
     * @generated from protobuf enum value: ASCENDING = 1;
     */
    ASCENDING = 1,
    /**
     * The field is ordered by descending field value.
     *
     * @generated from protobuf enum value: DESCENDING = 2;
     */
    DESCENDING = 2
}
/**
 * The supported array value configurations.
 *
 * @generated from protobuf enum db3_database_proto.Index.IndexField.ArrayConfig
 */
export declare enum Index_IndexField_ArrayConfig {
    /**
     * The index does not support additional array queries.
     *
     * @generated from protobuf enum value: ARRAY_CONFIG_UNSPECIFIED = 0;
     */
    ARRAY_CONFIG_UNSPECIFIED = 0,
    /**
     * The index supports array containment queries.
     *
     * @generated from protobuf enum value: CONTAINS = 1;
     */
    CONTAINS = 1
}
/**
 * The state of an index. During index creation, an index will be in the
 * `CREATING` state. If the index is created successfully, it will transition
 * to the `READY` state. If the index creation encounters a problem, the index
 * will transition to the `NEEDS_REPAIR` state.
 *
 * @generated from protobuf enum db3_database_proto.Index.State
 */
export declare enum Index_State {
    /**
     * The state is unspecified.
     *
     * @generated from protobuf enum value: STATE_UNSPECIFIED = 0;
     */
    STATE_UNSPECIFIED = 0,
    /**
     * The index is being created.
     * There is an active long-running operation for the index.
     * The index is updated when writing a document.
     * Some index data may exist.
     *
     * @generated from protobuf enum value: CREATING = 1;
     */
    CREATING = 1,
    /**
     * The index is ready to be used.
     * The index is updated when writing a document.
     * The index is fully populated from all stored documents it applies to.
     *
     * @generated from protobuf enum value: READY = 2;
     */
    READY = 2,
    /**
     * The index was being created, but something went wrong.
     * There is no active long-running operation for the index,
     * and the most recently finished long-running operation failed.
     * The index is not updated when writing a document.
     * Some index data may exist.
     * Use the google.longrunning.Operations API to determine why the operation
     * that last attempted to create this index failed, then re-create the
     * index.
     *
     * @generated from protobuf enum value: NEEDS_REPAIR = 3;
     */
    NEEDS_REPAIR = 3
}
/**
 * A Firestore query.
 *
 * @generated from protobuf message db3_database_proto.StructuredQuery
 */
export interface StructuredQuery {
    /**
     * The projection to return.
     *
     * @generated from protobuf field: db3_database_proto.StructuredQuery.Projection select = 1;
     */
    select?: StructuredQuery_Projection;
    /**
     * The collections to query.
     * TODO: Will support repeated collection in the future
     *
     * @generated from protobuf field: string collection_name = 2;
     */
    collectionName: string;
    /**
     * The filter to apply.
     *
     * @generated from protobuf field: db3_database_proto.StructuredQuery.Filter where = 3;
     */
    where?: StructuredQuery_Filter;
    /**
     * The maximum number of results to return.
     *
     * Applies after all other constraints.
     *
     * Requires:
     *
     * * The value must be greater than or equal to zero if specified.
     *
     * @generated from protobuf field: db3_database_proto.StructuredQuery.Limit limit = 5;
     */
    limit?: StructuredQuery_Limit;
}
/**
 * A filter.
 *
 * @generated from protobuf message db3_database_proto.StructuredQuery.Filter
 */
export interface StructuredQuery_Filter {
    /**
     * @generated from protobuf oneof: filter_type
     */
    filterType: {
        oneofKind: "fieldFilter";
        /**
         * A filter on a document field.
         *
         * @generated from protobuf field: db3_database_proto.StructuredQuery.FieldFilter field_filter = 1;
         */
        fieldFilter: StructuredQuery_FieldFilter;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A message that can hold any of the supported value types.
 *
 * @generated from protobuf message db3_database_proto.StructuredQuery.Value
 */
export interface StructuredQuery_Value {
    /**
     * @generated from protobuf oneof: value_type
     */
    valueType: {
        oneofKind: "booleanValue";
        /**
         * A boolean value.
         *
         * @generated from protobuf field: bool boolean_value = 1;
         */
        booleanValue: boolean;
    } | {
        oneofKind: "integerValue";
        /**
         * An integer value.
         *
         * @generated from protobuf field: int64 integer_value = 2;
         */
        integerValue: string;
    } | {
        oneofKind: "doubleValue";
        /**
         * A double value.
         *
         * @generated from protobuf field: double double_value = 3;
         */
        doubleValue: number;
    } | {
        oneofKind: "stringValue";
        /**
         * A string value.
         *
         * The string, represented as UTF-8, must not exceed 1 MiB - 89 bytes.
         * Only the first 1,500 bytes of the UTF-8 representation are considered by
         * queries.
         *
         * @generated from protobuf field: string string_value = 17;
         */
        stringValue: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A filter on a specific field.
 *
 * @generated from protobuf message db3_database_proto.StructuredQuery.FieldFilter
 */
export interface StructuredQuery_FieldFilter {
    /**
     * The field to filter by.
     *
     * @generated from protobuf field: string field = 1;
     */
    field: string;
    /**
     * The operator to filter by.
     *
     * @generated from protobuf field: db3_database_proto.StructuredQuery.FieldFilter.Operator op = 2;
     */
    op: StructuredQuery_FieldFilter_Operator;
    /**
     * The bytes of Bson value to compare to.
     *
     * @generated from protobuf field: db3_database_proto.StructuredQuery.Value value = 3;
     */
    value?: StructuredQuery_Value;
}
/**
 * A field filter operator.
 *
 * @generated from protobuf enum db3_database_proto.StructuredQuery.FieldFilter.Operator
 */
export declare enum StructuredQuery_FieldFilter_Operator {
    /**
     * Unspecified. This value must not be used.
     *
     * @generated from protobuf enum value: OPERATOR_UNSPECIFIED = 0;
     */
    OPERATOR_UNSPECIFIED = 0,
    /**
     * The given `field` is less than the given `value`.
     *
     * Requires:
     *
     * * That `field` come first in `order_by`.
     *
     * @generated from protobuf enum value: LESS_THAN = 1;
     */
    LESS_THAN = 1,
    /**
     * The given `field` is less than or equal to the given `value`.
     *
     * Requires:
     *
     * * That `field` come first in `order_by`.
     *
     * @generated from protobuf enum value: LESS_THAN_OR_EQUAL = 2;
     */
    LESS_THAN_OR_EQUAL = 2,
    /**
     * The given `field` is greater than the given `value`.
     *
     * Requires:
     *
     * * That `field` come first in `order_by`.
     *
     * @generated from protobuf enum value: GREATER_THAN = 3;
     */
    GREATER_THAN = 3,
    /**
     * The given `field` is greater than or equal to the given `value`.
     *
     * Requires:
     *
     * * That `field` come first in `order_by`.
     *
     * @generated from protobuf enum value: GREATER_THAN_OR_EQUAL = 4;
     */
    GREATER_THAN_OR_EQUAL = 4,
    /**
     * The given `field` is equal to the given `value`.
     *
     * @generated from protobuf enum value: EQUAL = 5;
     */
    EQUAL = 5,
    /**
     * The given `field` is not equal to the given `value`.
     *
     * Requires:
     *
     * * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
     * * That `field` comes first in the `order_by`.
     *
     * @generated from protobuf enum value: NOT_EQUAL = 6;
     */
    NOT_EQUAL = 6,
    /**
     * The given `field` is an array that contains the given `value`.
     *
     * @generated from protobuf enum value: ARRAY_CONTAINS = 7;
     */
    ARRAY_CONTAINS = 7
}
/**
 * The projection of document's fields to return.
 *
 * @generated from protobuf message db3_database_proto.StructuredQuery.Projection
 */
export interface StructuredQuery_Projection {
    /**
     * The fields to return.
     *
     * If empty, all fields are returned.
     *
     * @generated from protobuf field: repeated string fields = 1;
     */
    fields: string[];
}
/**
 * @generated from protobuf message db3_database_proto.StructuredQuery.Limit
 */
export interface StructuredQuery_Limit {
    /**
     * @generated from protobuf field: int32 limit = 1;
     */
    limit: number;
}
declare class Database$Type extends MessageType<Database> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.Database
 */
export declare const Database: Database$Type;
declare class Collection$Type extends MessageType<Collection> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.Collection
 */
export declare const Collection: Collection$Type;
declare class Document$Type extends MessageType<Document> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.Document
 */
export declare const Document: Document$Type;
declare class Index$Type extends MessageType<Index> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.Index
 */
export declare const Index: Index$Type;
declare class Index_IndexField$Type extends MessageType<Index_IndexField> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.Index.IndexField
 */
export declare const Index_IndexField: Index_IndexField$Type;
declare class StructuredQuery$Type extends MessageType<StructuredQuery> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.StructuredQuery
 */
export declare const StructuredQuery: StructuredQuery$Type;
declare class StructuredQuery_Filter$Type extends MessageType<StructuredQuery_Filter> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.StructuredQuery.Filter
 */
export declare const StructuredQuery_Filter: StructuredQuery_Filter$Type;
declare class StructuredQuery_Value$Type extends MessageType<StructuredQuery_Value> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.StructuredQuery.Value
 */
export declare const StructuredQuery_Value: StructuredQuery_Value$Type;
declare class StructuredQuery_FieldFilter$Type extends MessageType<StructuredQuery_FieldFilter> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.StructuredQuery.FieldFilter
 */
export declare const StructuredQuery_FieldFilter: StructuredQuery_FieldFilter$Type;
declare class StructuredQuery_Projection$Type extends MessageType<StructuredQuery_Projection> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.StructuredQuery.Projection
 */
export declare const StructuredQuery_Projection: StructuredQuery_Projection$Type;
declare class StructuredQuery_Limit$Type extends MessageType<StructuredQuery_Limit> {
    constructor();
}
/**
 * @generated MessageType for protobuf message db3_database_proto.StructuredQuery.Limit
 */
export declare const StructuredQuery_Limit: StructuredQuery_Limit$Type;
export {};
