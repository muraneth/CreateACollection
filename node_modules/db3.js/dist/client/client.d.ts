import { StorageProvider } from '../provider/storage_provider';
import { Wallet } from '../wallet/wallet';
import { Database, Index, StructuredQuery } from '../proto/db3_database';
import { QuerySessionInfo } from '../proto/db3_session';
import { BSON } from 'bson';
export interface DocumentData {
    [field: string]: any;
}
export interface DocumentEntry<T> {
    id: string;
    owner: string;
    tx: string;
    doc: T;
}
export declare class DB3Client {
    readonly provider: StorageProvider;
    querySessionInfo: QuerySessionInfo | undefined;
    sessionToken: string | undefined;
    wallet: Wallet;
    /**
     * new a db3 client with db3 node url and wallet
     *
     */
    constructor(url: string, wallet: Wallet);
    /**
     * create a database and return the address of it
     *
     */
    createDatabase(): Promise<[string, string]>;
    /**
     * get a database information
     *
     */
    getDatabase(addr: string): Promise<Database | undefined>;
    listCollection(databaseAddress: string): Promise<{
        [key: string]: import("../proto/db3_database").Collection;
    } | undefined>;
    /**
     * create a collection
     *
     */
    createCollection(databaseAddress: string, name: string, index: Index[]): Promise<string>;
    getState(): Promise<import("../proto/db3_node").NetworkStatus>;
    getAccount(address: string): Promise<import("../proto/db3_node").GetAccountResponse>;
    /**
     * create a document
     *
     */
    createDocument(databaseAddress: string, collectionName: string, document: DocumentData): Promise<string>;
    getDocument(id: string): Promise<{
        id: string;
        doc: BSON.Document;
        owner: string;
        tx: string;
    }>;
    runQuery<T>(dbAddress: string, query: StructuredQuery): Promise<DocumentEntry<T>[]>;
    deleteDocument(databaseAddress: string, collectionName: string, ids: string[]): Promise<import("../crypto/id").TxId>;
    updateDocument(databaseAddress: string, collectionName: string, document: Record<string, any>, id: string, masks: string[]): Promise<import("../crypto/id").TxId>;
    keepSessionAlive(): Promise<string>;
}
