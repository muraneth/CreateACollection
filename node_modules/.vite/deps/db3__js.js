import "./chunk-TWLJ45QX.js";

// node_modules/db3.js/dist/index.modern.js
function e(e2) {
  let t2 = typeof e2;
  if ("object" == t2) {
    if (Array.isArray(e2))
      return "array";
    if (null === e2)
      return "null";
  }
  return t2;
}
var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var r = [];
for (let e2 = 0; e2 < t.length; e2++)
  r[t[e2].charCodeAt(0)] = e2;
function n(e2) {
  let t2 = 3 * e2.length / 4;
  "=" == e2[e2.length - 2] ? t2 -= 2 : "=" == e2[e2.length - 1] && (t2 -= 1);
  let n2, i2 = new Uint8Array(t2), o2 = 0, s2 = 0, a2 = 0;
  for (let t3 = 0; t3 < e2.length; t3++) {
    if (n2 = r[e2.charCodeAt(t3)], void 0 === n2)
      switch (e2[t3]) {
        case "=":
          s2 = 0;
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        default:
          throw Error("invalid base64 string.");
      }
    switch (s2) {
      case 0:
        a2 = n2, s2 = 1;
        break;
      case 1:
        i2[o2++] = a2 << 2 | (48 & n2) >> 4, a2 = n2, s2 = 2;
        break;
      case 2:
        i2[o2++] = (15 & a2) << 4 | (60 & n2) >> 2, a2 = n2, s2 = 3;
        break;
      case 3:
        i2[o2++] = (3 & a2) << 6 | n2, s2 = 0;
    }
  }
  if (1 == s2)
    throw Error("invalid base64 string.");
  return i2.subarray(0, o2);
}
function i(e2) {
  let r2, n2 = "", i2 = 0, o2 = 0;
  for (let s2 = 0; s2 < e2.length; s2++)
    switch (r2 = e2[s2], i2) {
      case 0:
        n2 += t[r2 >> 2], o2 = (3 & r2) << 4, i2 = 1;
        break;
      case 1:
        n2 += t[o2 | r2 >> 4], o2 = (15 & r2) << 2, i2 = 2;
        break;
      case 2:
        n2 += t[o2 | r2 >> 6], n2 += t[63 & r2], i2 = 0;
    }
  return i2 && (n2 += t[o2], n2 += "=", 1 == i2 && (n2 += "=")), n2;
}
var o;
var s;
function a() {
  let e2 = 0, t2 = 0;
  for (let r3 = 0; r3 < 28; r3 += 7) {
    let n2 = this.buf[this.pos++];
    if (e2 |= (127 & n2) << r3, 0 == (128 & n2))
      return this.assertBounds(), [e2, t2];
  }
  let r2 = this.buf[this.pos++];
  if (e2 |= (15 & r2) << 28, t2 = (112 & r2) >> 4, 0 == (128 & r2))
    return this.assertBounds(), [e2, t2];
  for (let r3 = 3; r3 <= 31; r3 += 7) {
    let n2 = this.buf[this.pos++];
    if (t2 |= (127 & n2) << r3, 0 == (128 & n2))
      return this.assertBounds(), [e2, t2];
  }
  throw new Error("invalid varint");
}
function u(e2, t2, r2) {
  for (let n3 = 0; n3 < 28; n3 += 7) {
    const i3 = e2 >>> n3, o2 = !(i3 >>> 7 == 0 && 0 == t2);
    if (r2.push(255 & (o2 ? 128 | i3 : i3)), !o2)
      return;
  }
  const n2 = e2 >>> 28 & 15 | (7 & t2) << 4, i2 = !(t2 >> 3 == 0);
  if (r2.push(255 & (i2 ? 128 | n2 : n2)), i2) {
    for (let e3 = 3; e3 < 31; e3 += 7) {
      const n3 = t2 >>> e3, i3 = !(n3 >>> 7 == 0);
      if (r2.push(255 & (i3 ? 128 | n3 : n3)), !i3)
        return;
    }
    r2.push(t2 >>> 31 & 1);
  }
}
r["-".charCodeAt(0)] = t.indexOf("+"), r["_".charCodeAt(0)] = t.indexOf("/"), function(e2) {
  e2.symbol = Symbol.for("protobuf-ts/unknown"), e2.onRead = (r2, n2, i2, o2, s2) => {
    (t2(n2) ? n2[e2.symbol] : n2[e2.symbol] = []).push({ no: i2, wireType: o2, data: s2 });
  }, e2.onWrite = (t3, r2, n2) => {
    for (let { no: t4, wireType: i2, data: o2 } of e2.list(r2))
      n2.tag(t4, i2).raw(o2);
  }, e2.list = (r2, n2) => {
    if (t2(r2)) {
      let t3 = r2[e2.symbol];
      return n2 ? t3.filter((e3) => e3.no == n2) : t3;
    }
    return [];
  }, e2.last = (t3, r2) => e2.list(t3, r2).slice(-1)[0];
  const t2 = (t3) => t3 && Array.isArray(t3[e2.symbol]);
}(o || (o = {})), function(e2) {
  e2[e2.Varint = 0] = "Varint", e2[e2.Bit64 = 1] = "Bit64", e2[e2.LengthDelimited = 2] = "LengthDelimited", e2[e2.StartGroup = 3] = "StartGroup", e2[e2.EndGroup = 4] = "EndGroup", e2[e2.Bit32 = 5] = "Bit32";
}(s || (s = {}));
var h = 4294967296;
function f(e2) {
  let t2 = "-" == e2[0];
  t2 && (e2 = e2.slice(1));
  const r2 = 1e6;
  let n2 = 0, i2 = 0;
  function o2(t3, o3) {
    const s2 = Number(e2.slice(t3, o3));
    i2 *= r2, n2 = n2 * r2 + s2, n2 >= h && (i2 += n2 / h | 0, n2 %= h);
  }
  return o2(-24, -18), o2(-18, -12), o2(-12, -6), o2(-6), [t2, n2, i2];
}
function c(e2, t2) {
  if (t2 <= 2097151)
    return "" + (h * t2 + (e2 >>> 0));
  let r2 = (e2 >>> 24 | t2 << 8) >>> 0 & 16777215, n2 = t2 >> 16 & 65535, i2 = (16777215 & e2) + 6777216 * r2 + 6710656 * n2, o2 = r2 + 8147497 * n2, s2 = 2 * n2, a2 = 1e7;
  function u2(e3, t3) {
    let r3 = e3 ? String(e3) : "";
    return t3 ? "0000000".slice(r3.length) + r3 : r3;
  }
  return i2 >= a2 && (o2 += Math.floor(i2 / a2), i2 %= a2), o2 >= a2 && (s2 += Math.floor(o2 / a2), o2 %= a2), u2(s2, 0) + u2(o2, s2) + u2(i2, 1);
}
function l(e2, t2) {
  if (e2 >= 0) {
    for (; e2 > 127; )
      t2.push(127 & e2 | 128), e2 >>>= 7;
    t2.push(e2);
  } else {
    for (let r2 = 0; r2 < 9; r2++)
      t2.push(127 & e2 | 128), e2 >>= 7;
    t2.push(1);
  }
}
function d() {
  let e2 = this.buf[this.pos++], t2 = 127 & e2;
  if (0 == (128 & e2))
    return this.assertBounds(), t2;
  if (e2 = this.buf[this.pos++], t2 |= (127 & e2) << 7, 0 == (128 & e2))
    return this.assertBounds(), t2;
  if (e2 = this.buf[this.pos++], t2 |= (127 & e2) << 14, 0 == (128 & e2))
    return this.assertBounds(), t2;
  if (e2 = this.buf[this.pos++], t2 |= (127 & e2) << 21, 0 == (128 & e2))
    return this.assertBounds(), t2;
  e2 = this.buf[this.pos++], t2 |= (15 & e2) << 28;
  for (let t3 = 5; 0 != (128 & e2) && t3 < 10; t3++)
    e2 = this.buf[this.pos++];
  if (0 != (128 & e2))
    throw new Error("invalid varint");
  return this.assertBounds(), t2 >>> 0;
}
var p = function() {
  const e2 = new DataView(new ArrayBuffer(8));
  return void 0 !== globalThis.BigInt && "function" == typeof e2.getBigInt64 && "function" == typeof e2.getBigUint64 && "function" == typeof e2.setBigInt64 && "function" == typeof e2.setBigUint64 ? { MIN: BigInt("-9223372036854775808"), MAX: BigInt("9223372036854775807"), UMIN: BigInt("0"), UMAX: BigInt("18446744073709551615"), C: BigInt, V: e2 } : void 0;
}();
function y(e2) {
  if (!e2)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var g = /^-?[0-9]+$/;
var m = 4294967296;
var w = class {
  constructor(e2, t2) {
    this.lo = 0 | e2, this.hi = 0 | t2;
  }
  isZero() {
    return 0 == this.lo && 0 == this.hi;
  }
  toNumber() {
    let e2 = this.hi * m + (this.lo >>> 0);
    if (!Number.isSafeInteger(e2))
      throw new Error("cannot convert to safe number");
    return e2;
  }
};
var b = class extends w {
  static from(e2) {
    if (p)
      switch (typeof e2) {
        case "string":
          if ("0" == e2)
            return this.ZERO;
          if ("" == e2)
            throw new Error("string is no integer");
          e2 = p.C(e2);
        case "number":
          if (0 === e2)
            return this.ZERO;
          e2 = p.C(e2);
        case "bigint":
          if (!e2)
            return this.ZERO;
          if (e2 < p.UMIN)
            throw new Error("signed value for ulong");
          if (e2 > p.UMAX)
            throw new Error("ulong too large");
          return p.V.setBigUint64(0, e2, true), new b(p.V.getInt32(0, true), p.V.getInt32(4, true));
      }
    else
      switch (typeof e2) {
        case "string":
          if ("0" == e2)
            return this.ZERO;
          if (e2 = e2.trim(), !g.test(e2))
            throw new Error("string is no integer");
          let [t2, r2, n2] = f(e2);
          if (t2)
            throw new Error("signed value");
          return new b(r2, n2);
        case "number":
          if (0 == e2)
            return this.ZERO;
          if (!Number.isSafeInteger(e2))
            throw new Error("number is no integer");
          if (e2 < 0)
            throw new Error("signed value for ulong");
          return new b(e2, e2 / m);
      }
    throw new Error("unknown value " + typeof e2);
  }
  toString() {
    return p ? this.toBigInt().toString() : c(this.lo, this.hi);
  }
  toBigInt() {
    return y(p), p.V.setInt32(0, this.lo, true), p.V.setInt32(4, this.hi, true), p.V.getBigUint64(0, true);
  }
};
b.ZERO = new b(0, 0);
var v = class extends w {
  static from(e2) {
    if (p)
      switch (typeof e2) {
        case "string":
          if ("0" == e2)
            return this.ZERO;
          if ("" == e2)
            throw new Error("string is no integer");
          e2 = p.C(e2);
        case "number":
          if (0 === e2)
            return this.ZERO;
          e2 = p.C(e2);
        case "bigint":
          if (!e2)
            return this.ZERO;
          if (e2 < p.MIN)
            throw new Error("ulong too small");
          if (e2 > p.MAX)
            throw new Error("ulong too large");
          return p.V.setBigInt64(0, e2, true), new v(p.V.getInt32(0, true), p.V.getInt32(4, true));
      }
    else
      switch (typeof e2) {
        case "string":
          if ("0" == e2)
            return this.ZERO;
          if (e2 = e2.trim(), !g.test(e2))
            throw new Error("string is no integer");
          let [t2, r2, n2] = f(e2), i2 = new v(r2, n2);
          return t2 ? i2.negate() : i2;
        case "number":
          if (0 == e2)
            return this.ZERO;
          if (!Number.isSafeInteger(e2))
            throw new Error("number is no integer");
          return e2 > 0 ? new v(e2, e2 / m) : new v(-e2, -e2 / m).negate();
      }
    throw new Error("unknown value " + typeof e2);
  }
  isNegative() {
    return 0 != (2147483648 & this.hi);
  }
  negate() {
    let e2 = ~this.hi, t2 = this.lo;
    return t2 ? t2 = 1 + ~t2 : e2 += 1, new v(t2, e2);
  }
  toString() {
    if (p)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let e2 = this.negate();
      return "-" + c(e2.lo, e2.hi);
    }
    return c(this.lo, this.hi);
  }
  toBigInt() {
    return y(p), p.V.setInt32(0, this.lo, true), p.V.setInt32(4, this.hi, true), p.V.getBigInt64(0, true);
  }
};
v.ZERO = new v(0, 0);
var E = { readUnknownField: true, readerFactory: (e2) => new x(e2) };
var x = class {
  constructor(e2, t2) {
    this.varint64 = a, this.uint32 = d, this.buf = e2, this.len = e2.length, this.pos = 0, this.view = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), this.textDecoder = null != t2 ? t2 : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
  }
  tag() {
    let e2 = this.uint32(), t2 = e2 >>> 3, r2 = 7 & e2;
    if (t2 <= 0 || r2 < 0 || r2 > 5)
      throw new Error("illegal tag: field no " + t2 + " wire type " + r2);
    return [t2, r2];
  }
  skip(e2) {
    let t2 = this.pos;
    switch (e2) {
      case s.Varint:
        for (; 128 & this.buf[this.pos++]; )
          ;
        break;
      case s.Bit64:
        this.pos += 4;
      case s.Bit32:
        this.pos += 4;
        break;
      case s.LengthDelimited:
        let t3 = this.uint32();
        this.pos += t3;
        break;
      case s.StartGroup:
        let r2;
        for (; (r2 = this.tag()[1]) !== s.EndGroup; )
          this.skip(r2);
        break;
      default:
        throw new Error("cant skip wire type " + e2);
    }
    return this.assertBounds(), this.buf.subarray(t2, this.pos);
  }
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  int32() {
    return 0 | this.uint32();
  }
  sint32() {
    let e2 = this.uint32();
    return e2 >>> 1 ^ -(1 & e2);
  }
  int64() {
    return new v(...this.varint64());
  }
  uint64() {
    return new b(...this.varint64());
  }
  sint64() {
    let [e2, t2] = this.varint64(), r2 = -(1 & e2);
    return e2 = (e2 >>> 1 | (1 & t2) << 31) ^ r2, t2 = t2 >>> 1 ^ r2, new v(e2, t2);
  }
  bool() {
    let [e2, t2] = this.varint64();
    return 0 !== e2 || 0 !== t2;
  }
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  fixed64() {
    return new b(this.sfixed32(), this.sfixed32());
  }
  sfixed64() {
    return new v(this.sfixed32(), this.sfixed32());
  }
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  bytes() {
    let e2 = this.uint32(), t2 = this.pos;
    return this.pos += e2, this.assertBounds(), this.buf.subarray(t2, t2 + e2);
  }
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};
function B(e2, t2) {
  if (!e2)
    throw new Error(t2);
}
function A(e2) {
  if ("number" != typeof e2)
    throw new Error("invalid int 32: " + typeof e2);
  if (!Number.isInteger(e2) || e2 > 2147483647 || e2 < -2147483648)
    throw new Error("invalid int 32: " + e2);
}
function _(e2) {
  if ("number" != typeof e2)
    throw new Error("invalid uint 32: " + typeof e2);
  if (!Number.isInteger(e2) || e2 > 4294967295 || e2 < 0)
    throw new Error("invalid uint 32: " + e2);
}
function T(e2) {
  if ("number" != typeof e2)
    throw new Error("invalid float 32: " + typeof e2);
  if (Number.isFinite(e2) && (e2 > 34028234663852886e22 || e2 < -34028234663852886e22))
    throw new Error("invalid float 32: " + e2);
}
var S = { writeUnknownFields: true, writerFactory: () => new N() };
var N = class {
  constructor(e2) {
    this.stack = [], this.textEncoder = null != e2 ? e2 : new TextEncoder(), this.chunks = [], this.buf = [];
  }
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let e2 = 0;
    for (let t3 = 0; t3 < this.chunks.length; t3++)
      e2 += this.chunks[t3].length;
    let t2 = new Uint8Array(e2), r2 = 0;
    for (let e3 = 0; e3 < this.chunks.length; e3++)
      t2.set(this.chunks[e3], r2), r2 += this.chunks[e3].length;
    return this.chunks = [], t2;
  }
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  join() {
    let e2 = this.finish(), t2 = this.stack.pop();
    if (!t2)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = t2.chunks, this.buf = t2.buf, this.uint32(e2.byteLength), this.raw(e2);
  }
  tag(e2, t2) {
    return this.uint32((e2 << 3 | t2) >>> 0);
  }
  raw(e2) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(e2), this;
  }
  uint32(e2) {
    for (_(e2); e2 > 127; )
      this.buf.push(127 & e2 | 128), e2 >>>= 7;
    return this.buf.push(e2), this;
  }
  int32(e2) {
    return A(e2), l(e2, this.buf), this;
  }
  bool(e2) {
    return this.buf.push(e2 ? 1 : 0), this;
  }
  bytes(e2) {
    return this.uint32(e2.byteLength), this.raw(e2);
  }
  string(e2) {
    let t2 = this.textEncoder.encode(e2);
    return this.uint32(t2.byteLength), this.raw(t2);
  }
  float(e2) {
    T(e2);
    let t2 = new Uint8Array(4);
    return new DataView(t2.buffer).setFloat32(0, e2, true), this.raw(t2);
  }
  double(e2) {
    let t2 = new Uint8Array(8);
    return new DataView(t2.buffer).setFloat64(0, e2, true), this.raw(t2);
  }
  fixed32(e2) {
    _(e2);
    let t2 = new Uint8Array(4);
    return new DataView(t2.buffer).setUint32(0, e2, true), this.raw(t2);
  }
  sfixed32(e2) {
    A(e2);
    let t2 = new Uint8Array(4);
    return new DataView(t2.buffer).setInt32(0, e2, true), this.raw(t2);
  }
  sint32(e2) {
    return A(e2), l(e2 = (e2 << 1 ^ e2 >> 31) >>> 0, this.buf), this;
  }
  sfixed64(e2) {
    let t2 = new Uint8Array(8), r2 = new DataView(t2.buffer), n2 = v.from(e2);
    return r2.setInt32(0, n2.lo, true), r2.setInt32(4, n2.hi, true), this.raw(t2);
  }
  fixed64(e2) {
    let t2 = new Uint8Array(8), r2 = new DataView(t2.buffer), n2 = b.from(e2);
    return r2.setInt32(0, n2.lo, true), r2.setInt32(4, n2.hi, true), this.raw(t2);
  }
  int64(e2) {
    let t2 = v.from(e2);
    return u(t2.lo, t2.hi, this.buf), this;
  }
  sint64(e2) {
    let t2 = v.from(e2), r2 = t2.hi >> 31;
    return u(t2.lo << 1 ^ r2, (t2.hi << 1 | t2.lo >>> 31) ^ r2, this.buf), this;
  }
  uint64(e2) {
    let t2 = b.from(e2);
    return u(t2.lo, t2.hi, this.buf), this;
  }
};
var I = { emitDefaultValues: false, enumAsInteger: false, useProtoFieldName: false, prettySpaces: 0 };
var O = { ignoreUnknownFields: false };
function U(e2, t2) {
  var r2, n2;
  let i2 = Object.assign(Object.assign({}, e2), t2);
  return i2.typeRegistry = [...null !== (r2 = null == e2 ? void 0 : e2.typeRegistry) && void 0 !== r2 ? r2 : [], ...null !== (n2 = null == t2 ? void 0 : t2.typeRegistry) && void 0 !== n2 ? n2 : []], i2;
}
var L = Symbol.for("protobuf-ts/message-type");
function k(e2) {
  let t2 = false;
  const r2 = [];
  for (let n2 = 0; n2 < e2.length; n2++) {
    let i2 = e2.charAt(n2);
    "_" == i2 ? t2 = true : /\d/.test(i2) ? (r2.push(i2), t2 = true) : t2 ? (r2.push(i2.toUpperCase()), t2 = false) : r2.push(0 == n2 ? i2.toLowerCase() : i2);
  }
  return r2.join("");
}
var M;
var C;
var P;
function R(e2) {
  var t2, r2, n2, i2;
  return e2.localName = null !== (t2 = e2.localName) && void 0 !== t2 ? t2 : k(e2.name), e2.jsonName = null !== (r2 = e2.jsonName) && void 0 !== r2 ? r2 : k(e2.name), e2.repeat = null !== (n2 = e2.repeat) && void 0 !== n2 ? n2 : P.NO, e2.opt = null !== (i2 = e2.opt) && void 0 !== i2 ? i2 : !e2.repeat && !e2.oneof && "message" == e2.kind, e2;
}
function D(e2) {
  if ("object" != typeof e2 || null === e2 || !e2.hasOwnProperty("oneofKind"))
    return false;
  switch (typeof e2.oneofKind) {
    case "string":
      return void 0 !== e2[e2.oneofKind] && 2 == Object.keys(e2).length;
    case "undefined":
      return 1 == Object.keys(e2).length;
    default:
      return false;
  }
}
!function(e2) {
  e2[e2.DOUBLE = 1] = "DOUBLE", e2[e2.FLOAT = 2] = "FLOAT", e2[e2.INT64 = 3] = "INT64", e2[e2.UINT64 = 4] = "UINT64", e2[e2.INT32 = 5] = "INT32", e2[e2.FIXED64 = 6] = "FIXED64", e2[e2.FIXED32 = 7] = "FIXED32", e2[e2.BOOL = 8] = "BOOL", e2[e2.STRING = 9] = "STRING", e2[e2.BYTES = 12] = "BYTES", e2[e2.UINT32 = 13] = "UINT32", e2[e2.SFIXED32 = 15] = "SFIXED32", e2[e2.SFIXED64 = 16] = "SFIXED64", e2[e2.SINT32 = 17] = "SINT32", e2[e2.SINT64 = 18] = "SINT64";
}(M || (M = {})), function(e2) {
  e2[e2.BIGINT = 0] = "BIGINT", e2[e2.STRING = 1] = "STRING", e2[e2.NUMBER = 2] = "NUMBER";
}(C || (C = {})), function(e2) {
  e2[e2.NO = 0] = "NO", e2[e2.PACKED = 1] = "PACKED", e2[e2.UNPACKED = 2] = "UNPACKED";
}(P || (P = {}));
var z = class {
  constructor(e2) {
    var t2;
    this.fields = null !== (t2 = e2.fields) && void 0 !== t2 ? t2 : [];
  }
  prepare() {
    if (this.data)
      return;
    const e2 = [], t2 = [], r2 = [];
    for (let n2 of this.fields)
      if (n2.oneof)
        r2.includes(n2.oneof) || (r2.push(n2.oneof), e2.push(n2.oneof), t2.push(n2.oneof));
      else
        switch (t2.push(n2.localName), n2.kind) {
          case "scalar":
          case "enum":
            n2.opt && !n2.repeat || e2.push(n2.localName);
            break;
          case "message":
            n2.repeat && e2.push(n2.localName);
            break;
          case "map":
            e2.push(n2.localName);
        }
    this.data = { req: e2, known: t2, oneofs: Object.values(r2) };
  }
  is(e2, t2, r2 = false) {
    if (t2 < 0)
      return true;
    if (null == e2 || "object" != typeof e2)
      return false;
    this.prepare();
    let n2 = Object.keys(e2), i2 = this.data;
    if (n2.length < i2.req.length || i2.req.some((e3) => !n2.includes(e3)))
      return false;
    if (!r2 && n2.some((e3) => !i2.known.includes(e3)))
      return false;
    if (t2 < 1)
      return true;
    for (const n3 of i2.oneofs) {
      const i3 = e2[n3];
      if (!D(i3))
        return false;
      if (void 0 === i3.oneofKind)
        continue;
      const o2 = this.fields.find((e3) => e3.localName === i3.oneofKind);
      if (!o2)
        return false;
      if (!this.field(i3[i3.oneofKind], o2, r2, t2))
        return false;
    }
    for (const n3 of this.fields)
      if (void 0 === n3.oneof && !this.field(e2[n3.localName], n3, r2, t2))
        return false;
    return true;
  }
  field(e2, t2, r2, n2) {
    let i2 = t2.repeat;
    switch (t2.kind) {
      case "scalar":
        return void 0 === e2 ? t2.opt : i2 ? this.scalars(e2, t2.T, n2, t2.L) : this.scalar(e2, t2.T, t2.L);
      case "enum":
        return void 0 === e2 ? t2.opt : i2 ? this.scalars(e2, M.INT32, n2) : this.scalar(e2, M.INT32);
      case "message":
        return void 0 === e2 || (i2 ? this.messages(e2, t2.T(), r2, n2) : this.message(e2, t2.T(), r2, n2));
      case "map":
        if ("object" != typeof e2 || null === e2)
          return false;
        if (n2 < 2)
          return true;
        if (!this.mapKeys(e2, t2.K, n2))
          return false;
        switch (t2.V.kind) {
          case "scalar":
            return this.scalars(Object.values(e2), t2.V.T, n2, t2.V.L);
          case "enum":
            return this.scalars(Object.values(e2), M.INT32, n2);
          case "message":
            return this.messages(Object.values(e2), t2.V.T(), r2, n2);
        }
    }
    return true;
  }
  message(e2, t2, r2, n2) {
    return r2 ? t2.isAssignable(e2, n2) : t2.is(e2, n2);
  }
  messages(e2, t2, r2, n2) {
    if (!Array.isArray(e2))
      return false;
    if (n2 < 2)
      return true;
    if (r2) {
      for (let r3 = 0; r3 < e2.length && r3 < n2; r3++)
        if (!t2.isAssignable(e2[r3], n2 - 1))
          return false;
    } else
      for (let r3 = 0; r3 < e2.length && r3 < n2; r3++)
        if (!t2.is(e2[r3], n2 - 1))
          return false;
    return true;
  }
  scalar(e2, t2, r2) {
    let n2 = typeof e2;
    switch (t2) {
      case M.UINT64:
      case M.FIXED64:
      case M.INT64:
      case M.SFIXED64:
      case M.SINT64:
        switch (r2) {
          case C.BIGINT:
            return "bigint" == n2;
          case C.NUMBER:
            return "number" == n2 && !isNaN(e2);
          default:
            return "string" == n2;
        }
      case M.BOOL:
        return "boolean" == n2;
      case M.STRING:
        return "string" == n2;
      case M.BYTES:
        return e2 instanceof Uint8Array;
      case M.DOUBLE:
      case M.FLOAT:
        return "number" == n2 && !isNaN(e2);
      default:
        return "number" == n2 && Number.isInteger(e2);
    }
  }
  scalars(e2, t2, r2, n2) {
    if (!Array.isArray(e2))
      return false;
    if (r2 < 2)
      return true;
    if (Array.isArray(e2)) {
      for (let i2 = 0; i2 < e2.length && i2 < r2; i2++)
        if (!this.scalar(e2[i2], t2, n2))
          return false;
    }
    return true;
  }
  mapKeys(e2, t2, r2) {
    let n2 = Object.keys(e2);
    switch (t2) {
      case M.INT32:
      case M.FIXED32:
      case M.SFIXED32:
      case M.SINT32:
      case M.UINT32:
        return this.scalars(n2.slice(0, r2).map((e3) => parseInt(e3)), t2, r2);
      case M.BOOL:
        return this.scalars(n2.slice(0, r2).map((e3) => "true" == e3 || "false" != e3 && e3), t2, r2);
      default:
        return this.scalars(n2, t2, r2, C.STRING);
    }
  }
};
function $(e2, t2) {
  switch (t2) {
    case C.BIGINT:
      return e2.toBigInt();
    case C.NUMBER:
      return e2.toNumber();
    default:
      return e2.toString();
  }
}
var V = class {
  constructor(e2) {
    this.info = e2;
  }
  prepare() {
    var e2;
    if (void 0 === this.fMap) {
      this.fMap = {};
      const t2 = null !== (e2 = this.info.fields) && void 0 !== e2 ? e2 : [];
      for (const e3 of t2)
        this.fMap[e3.name] = e3, this.fMap[e3.jsonName] = e3, this.fMap[e3.localName] = e3;
    }
  }
  assert(t2, r2, n2) {
    if (!t2) {
      let t3 = e(n2);
      throw "number" != t3 && "boolean" != t3 || (t3 = n2.toString()), new Error(`Cannot parse JSON ${t3} for ${this.info.typeName}#${r2}`);
    }
  }
  read(e2, t2, r2) {
    this.prepare();
    const n2 = [];
    for (const [o2, s2] of Object.entries(e2)) {
      const e3 = this.fMap[o2];
      if (!e3) {
        if (!r2.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${o2}`);
        continue;
      }
      const a2 = e3.localName;
      let u2;
      if (e3.oneof) {
        if (n2.includes(e3.oneof))
          throw new Error(`Multiple members of the oneof group "${e3.oneof}" of ${this.info.typeName} are present in JSON.`);
        n2.push(e3.oneof), u2 = t2[e3.oneof] = { oneofKind: a2 };
      } else
        u2 = t2;
      if ("map" == e3.kind) {
        if (null === s2)
          continue;
        this.assert(null !== (i2 = s2) && "object" == typeof i2 && !Array.isArray(i2), e3.name, s2);
        const t3 = u2[a2];
        for (const [n3, i3] of Object.entries(s2)) {
          let o3;
          switch (this.assert(null !== i3, e3.name + " map value", null), e3.V.kind) {
            case "message":
              o3 = e3.V.T().internalJsonRead(i3, r2);
              break;
            case "enum":
              if (o3 = this.enum(e3.V.T(), i3, e3.name, r2.ignoreUnknownFields), false === o3)
                continue;
              break;
            case "scalar":
              o3 = this.scalar(i3, e3.V.T, e3.V.L, e3.name);
          }
          this.assert(void 0 !== o3, e3.name + " map value", i3);
          let s3 = n3;
          e3.K == M.BOOL && (s3 = "true" == s3 || "false" != s3 && s3), s3 = this.scalar(s3, e3.K, C.STRING, e3.name).toString(), t3[s3] = o3;
        }
      } else if (e3.repeat) {
        if (null === s2)
          continue;
        this.assert(Array.isArray(s2), e3.name, s2);
        const t3 = u2[a2];
        for (const n3 of s2) {
          let i3;
          switch (this.assert(null !== n3, e3.name, null), e3.kind) {
            case "message":
              i3 = e3.T().internalJsonRead(n3, r2);
              break;
            case "enum":
              if (i3 = this.enum(e3.T(), n3, e3.name, r2.ignoreUnknownFields), false === i3)
                continue;
              break;
            case "scalar":
              i3 = this.scalar(n3, e3.T, e3.L, e3.name);
          }
          this.assert(void 0 !== i3, e3.name, s2), t3.push(i3);
        }
      } else
        switch (e3.kind) {
          case "message":
            if (null === s2 && "google.protobuf.Value" != e3.T().typeName) {
              this.assert(void 0 === e3.oneof, e3.name + " (oneof member)", null);
              continue;
            }
            u2[a2] = e3.T().internalJsonRead(s2, r2, u2[a2]);
            break;
          case "enum":
            let t3 = this.enum(e3.T(), s2, e3.name, r2.ignoreUnknownFields);
            if (false === t3)
              continue;
            u2[a2] = t3;
            break;
          case "scalar":
            u2[a2] = this.scalar(s2, e3.T, e3.L, e3.name);
        }
    }
    var i2;
  }
  enum(e2, t2, r2, n2) {
    if ("google.protobuf.NullValue" == e2[0] && B(null === t2, `Unable to parse field ${this.info.typeName}#${r2}, enum ${e2[0]} only accepts null.`), null === t2)
      return 0;
    switch (typeof t2) {
      case "number":
        return B(Number.isInteger(t2), `Unable to parse field ${this.info.typeName}#${r2}, enum can only be integral number, got ${t2}.`), t2;
      case "string":
        let i2 = t2;
        e2[2] && t2.substring(0, e2[2].length) === e2[2] && (i2 = t2.substring(e2[2].length));
        let o2 = e2[1][i2];
        return (void 0 !== o2 || !n2) && (B("number" == typeof o2, `Unable to parse field ${this.info.typeName}#${r2}, enum ${e2[0]} has no value for "${t2}".`), o2);
    }
    B(false, `Unable to parse field ${this.info.typeName}#${r2}, cannot parse enum value from ${typeof t2}".`);
  }
  scalar(e2, t2, r2, i2) {
    let o2;
    try {
      switch (t2) {
        case M.DOUBLE:
        case M.FLOAT:
          if (null === e2)
            return 0;
          if ("NaN" === e2)
            return Number.NaN;
          if ("Infinity" === e2)
            return Number.POSITIVE_INFINITY;
          if ("-Infinity" === e2)
            return Number.NEGATIVE_INFINITY;
          if ("" === e2) {
            o2 = "empty string";
            break;
          }
          if ("string" == typeof e2 && e2.trim().length !== e2.length) {
            o2 = "extra whitespace";
            break;
          }
          if ("string" != typeof e2 && "number" != typeof e2)
            break;
          let i3 = Number(e2);
          if (Number.isNaN(i3)) {
            o2 = "not a number";
            break;
          }
          if (!Number.isFinite(i3)) {
            o2 = "too large or small";
            break;
          }
          return t2 == M.FLOAT && T(i3), i3;
        case M.INT32:
        case M.FIXED32:
        case M.SFIXED32:
        case M.SINT32:
        case M.UINT32:
          if (null === e2)
            return 0;
          let s2;
          if ("number" == typeof e2 ? s2 = e2 : "" === e2 ? o2 = "empty string" : "string" == typeof e2 && (e2.trim().length !== e2.length ? o2 = "extra whitespace" : s2 = Number(e2)), void 0 === s2)
            break;
          return t2 == M.UINT32 ? _(s2) : A(s2), s2;
        case M.INT64:
        case M.SFIXED64:
        case M.SINT64:
          if (null === e2)
            return $(v.ZERO, r2);
          if ("number" != typeof e2 && "string" != typeof e2)
            break;
          return $(v.from(e2), r2);
        case M.FIXED64:
        case M.UINT64:
          if (null === e2)
            return $(b.ZERO, r2);
          if ("number" != typeof e2 && "string" != typeof e2)
            break;
          return $(b.from(e2), r2);
        case M.BOOL:
          if (null === e2)
            return false;
          if ("boolean" != typeof e2)
            break;
          return e2;
        case M.STRING:
          if (null === e2)
            return "";
          if ("string" != typeof e2) {
            o2 = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(e2);
          } catch (o3) {
            o3 = "invalid UTF8";
            break;
          }
          return e2;
        case M.BYTES:
          if (null === e2 || "" === e2)
            return new Uint8Array(0);
          if ("string" != typeof e2)
            break;
          return n(e2);
      }
    } catch (e3) {
      o2 = e3.message;
    }
    this.assert(false, i2 + (o2 ? " - " + o2 : ""), e2);
  }
};
var j = class {
  constructor(e2) {
    var t2;
    this.fields = null !== (t2 = e2.fields) && void 0 !== t2 ? t2 : [];
  }
  write(e2, t2) {
    const r2 = {}, n2 = e2;
    for (const e3 of this.fields) {
      if (!e3.oneof) {
        let i3 = this.field(e3, n2[e3.localName], t2);
        void 0 !== i3 && (r2[t2.useProtoFieldName ? e3.name : e3.jsonName] = i3);
        continue;
      }
      const i2 = n2[e3.oneof];
      if (i2.oneofKind !== e3.localName)
        continue;
      const o2 = "scalar" == e3.kind || "enum" == e3.kind ? Object.assign(Object.assign({}, t2), { emitDefaultValues: true }) : t2;
      let s2 = this.field(e3, i2[e3.localName], o2);
      B(void 0 !== s2), r2[t2.useProtoFieldName ? e3.name : e3.jsonName] = s2;
    }
    return r2;
  }
  field(e2, t2, r2) {
    let n2;
    if ("map" == e2.kind) {
      B("object" == typeof t2 && null !== t2);
      const i2 = {};
      switch (e2.V.kind) {
        case "scalar":
          for (const [r3, n4] of Object.entries(t2)) {
            const t3 = this.scalar(e2.V.T, n4, e2.name, false, true);
            B(void 0 !== t3), i2[r3.toString()] = t3;
          }
          break;
        case "message":
          const n3 = e2.V.T();
          for (const [o3, s2] of Object.entries(t2)) {
            const t3 = this.message(n3, s2, e2.name, r2);
            B(void 0 !== t3), i2[o3.toString()] = t3;
          }
          break;
        case "enum":
          const o2 = e2.V.T();
          for (const [n4, s2] of Object.entries(t2)) {
            B(void 0 === s2 || "number" == typeof s2);
            const t3 = this.enum(o2, s2, e2.name, false, true, r2.enumAsInteger);
            B(void 0 !== t3), i2[n4.toString()] = t3;
          }
      }
      (r2.emitDefaultValues || Object.keys(i2).length > 0) && (n2 = i2);
    } else if (e2.repeat) {
      B(Array.isArray(t2));
      const i2 = [];
      switch (e2.kind) {
        case "scalar":
          for (let r3 = 0; r3 < t2.length; r3++) {
            const n4 = this.scalar(e2.T, t2[r3], e2.name, e2.opt, true);
            B(void 0 !== n4), i2.push(n4);
          }
          break;
        case "enum":
          const n3 = e2.T();
          for (let o3 = 0; o3 < t2.length; o3++) {
            B(void 0 === t2[o3] || "number" == typeof t2[o3]);
            const s2 = this.enum(n3, t2[o3], e2.name, e2.opt, true, r2.enumAsInteger);
            B(void 0 !== s2), i2.push(s2);
          }
          break;
        case "message":
          const o2 = e2.T();
          for (let n4 = 0; n4 < t2.length; n4++) {
            const s2 = this.message(o2, t2[n4], e2.name, r2);
            B(void 0 !== s2), i2.push(s2);
          }
      }
      (r2.emitDefaultValues || i2.length > 0 || r2.emitDefaultValues) && (n2 = i2);
    } else
      switch (e2.kind) {
        case "scalar":
          n2 = this.scalar(e2.T, t2, e2.name, e2.opt, r2.emitDefaultValues);
          break;
        case "enum":
          n2 = this.enum(e2.T(), t2, e2.name, e2.opt, r2.emitDefaultValues, r2.enumAsInteger);
          break;
        case "message":
          n2 = this.message(e2.T(), t2, e2.name, r2);
      }
    return n2;
  }
  enum(e2, t2, r2, n2, i2, o2) {
    if ("google.protobuf.NullValue" == e2[0])
      return null;
    if (void 0 !== t2) {
      if (0 !== t2 || i2 || n2)
        return B("number" == typeof t2), B(Number.isInteger(t2)), o2 || !e2[1].hasOwnProperty(t2) ? t2 : e2[2] ? e2[2] + e2[1][t2] : e2[1][t2];
    } else
      B(n2);
  }
  message(e2, t2, r2, n2) {
    return void 0 === t2 ? n2.emitDefaultValues ? null : void 0 : e2.internalJsonWrite(t2, n2);
  }
  scalar(e2, t2, r2, n2, o2) {
    if (void 0 === t2)
      return void B(n2);
    const s2 = o2 || n2;
    switch (e2) {
      case M.INT32:
      case M.SFIXED32:
      case M.SINT32:
        return 0 === t2 ? s2 ? 0 : void 0 : (A(t2), t2);
      case M.FIXED32:
      case M.UINT32:
        return 0 === t2 ? s2 ? 0 : void 0 : (_(t2), t2);
      case M.FLOAT:
        T(t2);
      case M.DOUBLE:
        return 0 === t2 ? s2 ? 0 : void 0 : (B("number" == typeof t2), Number.isNaN(t2) ? "NaN" : t2 === Number.POSITIVE_INFINITY ? "Infinity" : t2 === Number.NEGATIVE_INFINITY ? "-Infinity" : t2);
      case M.STRING:
        return "" === t2 ? s2 ? "" : void 0 : (B("string" == typeof t2), t2);
      case M.BOOL:
        return false === t2 ? !s2 && void 0 : (B("boolean" == typeof t2), t2);
      case M.UINT64:
      case M.FIXED64:
        B("number" == typeof t2 || "string" == typeof t2 || "bigint" == typeof t2);
        let e3 = b.from(t2);
        if (e3.isZero() && !s2)
          return;
        return e3.toString();
      case M.INT64:
      case M.SFIXED64:
      case M.SINT64:
        B("number" == typeof t2 || "string" == typeof t2 || "bigint" == typeof t2);
        let r3 = v.from(t2);
        if (r3.isZero() && !s2)
          return;
        return r3.toString();
      case M.BYTES:
        return B(t2 instanceof Uint8Array), t2.byteLength ? i(t2) : s2 ? "" : void 0;
    }
  }
};
function F(e2, t2 = C.STRING) {
  switch (e2) {
    case M.BOOL:
      return false;
    case M.UINT64:
    case M.FIXED64:
      return $(b.ZERO, t2);
    case M.INT64:
    case M.SFIXED64:
    case M.SINT64:
      return $(v.ZERO, t2);
    case M.DOUBLE:
    case M.FLOAT:
      return 0;
    case M.BYTES:
      return new Uint8Array(0);
    case M.STRING:
      return "";
    default:
      return 0;
  }
}
var H = class {
  constructor(e2) {
    this.info = e2;
  }
  prepare() {
    var e2;
    if (!this.fieldNoToField) {
      const t2 = null !== (e2 = this.info.fields) && void 0 !== e2 ? e2 : [];
      this.fieldNoToField = new Map(t2.map((e3) => [e3.no, e3]));
    }
  }
  read(e2, t2, r2, n2) {
    this.prepare();
    const i2 = void 0 === n2 ? e2.len : e2.pos + n2;
    for (; e2.pos < i2; ) {
      const [n3, i3] = e2.tag(), a2 = this.fieldNoToField.get(n3);
      if (!a2) {
        let s2 = r2.readUnknownField;
        if ("throw" == s2)
          throw new Error(`Unknown field ${n3} (wire type ${i3}) for ${this.info.typeName}`);
        let a3 = e2.skip(i3);
        false !== s2 && (true === s2 ? o.onRead : s2)(this.info.typeName, t2, n3, i3, a3);
        continue;
      }
      let u2 = t2, h2 = a2.repeat, f2 = a2.localName;
      switch (a2.oneof && (u2 = u2[a2.oneof], u2.oneofKind !== f2 && (u2 = t2[a2.oneof] = { oneofKind: f2 })), a2.kind) {
        case "scalar":
        case "enum":
          let t3 = "enum" == a2.kind ? M.INT32 : a2.T, n4 = "scalar" == a2.kind ? a2.L : void 0;
          if (h2) {
            let r3 = u2[f2];
            if (i3 == s.LengthDelimited && t3 != M.STRING && t3 != M.BYTES) {
              let i4 = e2.uint32() + e2.pos;
              for (; e2.pos < i4; )
                r3.push(this.scalar(e2, t3, n4));
            } else
              r3.push(this.scalar(e2, t3, n4));
          } else
            u2[f2] = this.scalar(e2, t3, n4);
          break;
        case "message":
          if (h2) {
            let t4 = u2[f2], n5 = a2.T().internalBinaryRead(e2, e2.uint32(), r2);
            t4.push(n5);
          } else
            u2[f2] = a2.T().internalBinaryRead(e2, e2.uint32(), r2, u2[f2]);
          break;
        case "map":
          let [o2, c2] = this.mapEntry(a2, e2, r2);
          u2[f2][o2] = c2;
      }
    }
  }
  mapEntry(e2, t2, r2) {
    let n2, i2, o2 = t2.uint32(), s2 = t2.pos + o2;
    for (; t2.pos < s2; ) {
      let [o3, s3] = t2.tag();
      switch (o3) {
        case 1:
          n2 = e2.K == M.BOOL ? t2.bool().toString() : this.scalar(t2, e2.K, C.STRING);
          break;
        case 2:
          switch (e2.V.kind) {
            case "scalar":
              i2 = this.scalar(t2, e2.V.T, e2.V.L);
              break;
            case "enum":
              i2 = t2.int32();
              break;
            case "message":
              i2 = e2.V.T().internalBinaryRead(t2, t2.uint32(), r2);
          }
          break;
        default:
          throw new Error(`Unknown field ${o3} (wire type ${s3}) in map entry for ${this.info.typeName}#${e2.name}`);
      }
    }
    if (void 0 === n2) {
      let t3 = F(e2.K);
      n2 = e2.K == M.BOOL ? t3.toString() : t3;
    }
    if (void 0 === i2)
      switch (e2.V.kind) {
        case "scalar":
          i2 = F(e2.V.T, e2.V.L);
          break;
        case "enum":
          i2 = 0;
          break;
        case "message":
          i2 = e2.V.T().create();
      }
    return [n2, i2];
  }
  scalar(e2, t2, r2) {
    switch (t2) {
      case M.INT32:
        return e2.int32();
      case M.STRING:
        return e2.string();
      case M.BOOL:
        return e2.bool();
      case M.DOUBLE:
        return e2.double();
      case M.FLOAT:
        return e2.float();
      case M.INT64:
        return $(e2.int64(), r2);
      case M.UINT64:
        return $(e2.uint64(), r2);
      case M.FIXED64:
        return $(e2.fixed64(), r2);
      case M.FIXED32:
        return e2.fixed32();
      case M.BYTES:
        return e2.bytes();
      case M.UINT32:
        return e2.uint32();
      case M.SFIXED32:
        return e2.sfixed32();
      case M.SFIXED64:
        return $(e2.sfixed64(), r2);
      case M.SINT32:
        return e2.sint32();
      case M.SINT64:
        return $(e2.sint64(), r2);
    }
  }
};
var K = class {
  constructor(e2) {
    this.info = e2;
  }
  prepare() {
    if (!this.fields) {
      const e2 = this.info.fields ? this.info.fields.concat() : [];
      this.fields = e2.sort((e3, t2) => e3.no - t2.no);
    }
  }
  write(e2, t2, r2) {
    this.prepare();
    for (const n3 of this.fields) {
      let i2, o2, s2 = n3.repeat, a2 = n3.localName;
      if (n3.oneof) {
        const t3 = e2[n3.oneof];
        if (t3.oneofKind !== a2)
          continue;
        i2 = t3[a2], o2 = true;
      } else
        i2 = e2[a2], o2 = false;
      switch (n3.kind) {
        case "scalar":
        case "enum":
          let e3 = "enum" == n3.kind ? M.INT32 : n3.T;
          if (s2)
            if (B(Array.isArray(i2)), s2 == P.PACKED)
              this.packed(t2, e3, n3.no, i2);
            else
              for (const r3 of i2)
                this.scalar(t2, e3, n3.no, r3, true);
          else
            void 0 === i2 ? B(n3.opt) : this.scalar(t2, e3, n3.no, i2, o2 || n3.opt);
          break;
        case "message":
          if (s2) {
            B(Array.isArray(i2));
            for (const e4 of i2)
              this.message(t2, r2, n3.T(), n3.no, e4);
          } else
            this.message(t2, r2, n3.T(), n3.no, i2);
          break;
        case "map":
          B("object" == typeof i2 && null !== i2);
          for (const [e4, o3] of Object.entries(i2))
            this.mapEntry(t2, r2, n3, e4, o3);
      }
    }
    let n2 = r2.writeUnknownFields;
    false !== n2 && (true === n2 ? o.onWrite : n2)(this.info.typeName, e2, t2);
  }
  mapEntry(e2, t2, r2, n2, i2) {
    e2.tag(r2.no, s.LengthDelimited), e2.fork();
    let o2 = n2;
    switch (r2.K) {
      case M.INT32:
      case M.FIXED32:
      case M.UINT32:
      case M.SFIXED32:
      case M.SINT32:
        o2 = Number.parseInt(n2);
        break;
      case M.BOOL:
        B("true" == n2 || "false" == n2), o2 = "true" == n2;
    }
    switch (this.scalar(e2, r2.K, 1, o2, true), r2.V.kind) {
      case "scalar":
        this.scalar(e2, r2.V.T, 2, i2, true);
        break;
      case "enum":
        this.scalar(e2, M.INT32, 2, i2, true);
        break;
      case "message":
        this.message(e2, t2, r2.V.T(), 2, i2);
    }
    e2.join();
  }
  message(e2, t2, r2, n2, i2) {
    void 0 !== i2 && (r2.internalBinaryWrite(i2, e2.tag(n2, s.LengthDelimited).fork(), t2), e2.join());
  }
  scalar(e2, t2, r2, n2, i2) {
    let [o2, s2, a2] = this.scalarInfo(t2, n2);
    a2 && !i2 || (e2.tag(r2, o2), e2[s2](n2));
  }
  packed(e2, t2, r2, n2) {
    if (!n2.length)
      return;
    B(t2 !== M.BYTES && t2 !== M.STRING), e2.tag(r2, s.LengthDelimited), e2.fork();
    let [, i2] = this.scalarInfo(t2);
    for (let t3 = 0; t3 < n2.length; t3++)
      e2[i2](n2[t3]);
    e2.join();
  }
  scalarInfo(e2, t2) {
    let r2, n2 = s.Varint, i2 = void 0 === t2, o2 = 0 === t2;
    switch (e2) {
      case M.INT32:
        r2 = "int32";
        break;
      case M.STRING:
        o2 = i2 || !t2.length, n2 = s.LengthDelimited, r2 = "string";
        break;
      case M.BOOL:
        o2 = false === t2, r2 = "bool";
        break;
      case M.UINT32:
        r2 = "uint32";
        break;
      case M.DOUBLE:
        n2 = s.Bit64, r2 = "double";
        break;
      case M.FLOAT:
        n2 = s.Bit32, r2 = "float";
        break;
      case M.INT64:
        o2 = i2 || v.from(t2).isZero(), r2 = "int64";
        break;
      case M.UINT64:
        o2 = i2 || b.from(t2).isZero(), r2 = "uint64";
        break;
      case M.FIXED64:
        o2 = i2 || b.from(t2).isZero(), n2 = s.Bit64, r2 = "fixed64";
        break;
      case M.BYTES:
        o2 = i2 || !t2.byteLength, n2 = s.LengthDelimited, r2 = "bytes";
        break;
      case M.FIXED32:
        n2 = s.Bit32, r2 = "fixed32";
        break;
      case M.SFIXED32:
        n2 = s.Bit32, r2 = "sfixed32";
        break;
      case M.SFIXED64:
        o2 = i2 || v.from(t2).isZero(), n2 = s.Bit64, r2 = "sfixed64";
        break;
      case M.SINT32:
        r2 = "sint32";
        break;
      case M.SINT64:
        o2 = i2 || v.from(t2).isZero(), r2 = "sint64";
    }
    return [n2, r2, i2 || o2];
  }
};
function G(e2, t2, r2) {
  let n2, i2, o2 = r2;
  for (let r3 of e2.fields) {
    let e3 = r3.localName;
    if (r3.oneof) {
      const s2 = o2[r3.oneof];
      if (null == (null == s2 ? void 0 : s2.oneofKind))
        continue;
      if (n2 = s2[e3], i2 = t2[r3.oneof], i2.oneofKind = s2.oneofKind, null == n2) {
        delete i2[e3];
        continue;
      }
    } else if (n2 = o2[e3], i2 = t2, null == n2)
      continue;
    switch (r3.repeat && (i2[e3].length = n2.length), r3.kind) {
      case "scalar":
      case "enum":
        if (r3.repeat)
          for (let t4 = 0; t4 < n2.length; t4++)
            i2[e3][t4] = n2[t4];
        else
          i2[e3] = n2;
        break;
      case "message":
        let t3 = r3.T();
        if (r3.repeat)
          for (let r4 = 0; r4 < n2.length; r4++)
            i2[e3][r4] = t3.create(n2[r4]);
        else
          void 0 === i2[e3] ? i2[e3] = t3.create(n2) : t3.mergePartial(i2[e3], n2);
        break;
      case "map":
        switch (r3.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(i2[e3], n2);
            break;
          case "message":
            let t4 = r3.V.T();
            for (let r4 of Object.keys(n2))
              i2[e3][r4] = t4.create(n2[r4]);
        }
    }
  }
}
var q = Object.values;
function J(e2, t2, r2) {
  if (t2 === r2)
    return true;
  if (e2 !== M.BYTES)
    return false;
  let n2 = t2, i2 = r2;
  if (n2.length !== i2.length)
    return false;
  for (let e3 = 0; e3 < n2.length; e3++)
    if (n2[e3] != i2[e3])
      return false;
  return true;
}
function W(e2, t2, r2) {
  if (t2.length !== r2.length)
    return false;
  for (let n2 = 0; n2 < t2.length; n2++)
    if (!J(e2, t2[n2], r2[n2]))
      return false;
  return true;
}
function Z(e2, t2, r2) {
  if (t2.length !== r2.length)
    return false;
  for (let n2 = 0; n2 < t2.length; n2++)
    if (!e2.equals(t2[n2], r2[n2]))
      return false;
  return true;
}
var Y = class {
  constructor(e2, t2, r2) {
    this.defaultCheckDepth = 16, this.typeName = e2, this.fields = t2.map(R), this.options = null != r2 ? r2 : {}, this.refTypeCheck = new z(this), this.refJsonReader = new V(this), this.refJsonWriter = new j(this), this.refBinReader = new H(this), this.refBinWriter = new K(this);
  }
  create(e2) {
    let t2 = function(e3) {
      const t3 = {};
      Object.defineProperty(t3, L, { enumerable: false, value: e3 });
      for (let r2 of e3.fields) {
        let e4 = r2.localName;
        if (!r2.opt)
          if (r2.oneof)
            t3[r2.oneof] = { oneofKind: void 0 };
          else if (r2.repeat)
            t3[e4] = [];
          else
            switch (r2.kind) {
              case "scalar":
                t3[e4] = F(r2.T, r2.L);
                break;
              case "enum":
                t3[e4] = 0;
                break;
              case "map":
                t3[e4] = {};
            }
      }
      return t3;
    }(this);
    return void 0 !== e2 && G(this, t2, e2), t2;
  }
  clone(e2) {
    let t2 = this.create();
    return G(this, t2, e2), t2;
  }
  equals(e2, t2) {
    return function(e3, t3, r2) {
      if (t3 === r2)
        return true;
      if (!t3 || !r2)
        return false;
      for (let n2 of e3.fields) {
        let e4 = n2.localName, i2 = n2.oneof ? t3[n2.oneof][e4] : t3[e4], o2 = n2.oneof ? r2[n2.oneof][e4] : r2[e4];
        switch (n2.kind) {
          case "enum":
          case "scalar":
            let e5 = "enum" == n2.kind ? M.INT32 : n2.T;
            if (!(n2.repeat ? W(e5, i2, o2) : J(e5, i2, o2)))
              return false;
            break;
          case "map":
            if (!("message" == n2.V.kind ? Z(n2.V.T(), q(i2), q(o2)) : W("enum" == n2.V.kind ? M.INT32 : n2.V.T, q(i2), q(o2))))
              return false;
            break;
          case "message":
            let t4 = n2.T();
            if (!(n2.repeat ? Z(t4, i2, o2) : t4.equals(i2, o2)))
              return false;
        }
      }
      return true;
    }(this, e2, t2);
  }
  is(e2, t2 = this.defaultCheckDepth) {
    return this.refTypeCheck.is(e2, t2, false);
  }
  isAssignable(e2, t2 = this.defaultCheckDepth) {
    return this.refTypeCheck.is(e2, t2, true);
  }
  mergePartial(e2, t2) {
    G(this, e2, t2);
  }
  fromBinary(e2, t2) {
    let r2 = function(e3) {
      return e3 ? Object.assign(Object.assign({}, E), e3) : E;
    }(t2);
    return this.internalBinaryRead(r2.readerFactory(e2), e2.byteLength, r2);
  }
  fromJson(e2, t2) {
    return this.internalJsonRead(e2, function(e3) {
      return e3 ? Object.assign(Object.assign({}, O), e3) : O;
    }(t2));
  }
  fromJsonString(e2, t2) {
    let r2 = JSON.parse(e2);
    return this.fromJson(r2, t2);
  }
  toJson(e2, t2) {
    return this.internalJsonWrite(e2, function(e3) {
      return e3 ? Object.assign(Object.assign({}, I), e3) : I;
    }(t2));
  }
  toJsonString(e2, t2) {
    var r2;
    let n2 = this.toJson(e2, t2);
    return JSON.stringify(n2, null, null !== (r2 = null == t2 ? void 0 : t2.prettySpaces) && void 0 !== r2 ? r2 : 0);
  }
  toBinary(e2, t2) {
    let r2 = function(e3) {
      return e3 ? Object.assign(Object.assign({}, S), e3) : S;
    }(t2);
    return this.internalBinaryWrite(e2, r2.writerFactory(), r2).finish();
  }
  internalJsonRead(t2, r2, n2) {
    if (null !== t2 && "object" == typeof t2 && !Array.isArray(t2)) {
      let e2 = null != n2 ? n2 : this.create();
      return this.refJsonReader.read(t2, e2, r2), e2;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${e(t2)}.`);
  }
  internalJsonWrite(e2, t2) {
    return this.refJsonWriter.write(e2, t2);
  }
  internalBinaryWrite(e2, t2, r2) {
    return this.refBinWriter.write(e2, t2, r2), t2;
  }
  internalBinaryRead(e2, t2, r2, n2) {
    let i2 = null != n2 ? n2 : this.create();
    return this.refBinReader.read(e2, i2, r2, t2), i2;
  }
};
var X = new class extends Y {
  constructor() {
    super("db3_account_proto.Account", [{ no: 1, name: "bills", kind: "scalar", T: 4 }, { no: 2, name: "credits", kind: "scalar", T: 4 }, { no: 3, name: "total_storage_in_bytes", kind: "scalar", T: 4 }, { no: 4, name: "total_mutation_count", kind: "scalar", T: 4 }, { no: 5, name: "total_session_count", kind: "scalar", T: 4 }, { no: 6, name: "nonce", kind: "scalar", T: 4 }]);
  }
}();
var Q;
var ee;
var te;
var re;
!function(e2) {
  e2[e2.ORDER_UNSPECIFIED = 0] = "ORDER_UNSPECIFIED", e2[e2.ASCENDING = 1] = "ASCENDING", e2[e2.DESCENDING = 2] = "DESCENDING";
}(Q || (Q = {})), function(e2) {
  e2[e2.ARRAY_CONFIG_UNSPECIFIED = 0] = "ARRAY_CONFIG_UNSPECIFIED", e2[e2.CONTAINS = 1] = "CONTAINS";
}(ee || (ee = {})), function(e2) {
  e2[e2.STATE_UNSPECIFIED = 0] = "STATE_UNSPECIFIED", e2[e2.CREATING = 1] = "CREATING", e2[e2.READY = 2] = "READY", e2[e2.NEEDS_REPAIR = 3] = "NEEDS_REPAIR";
}(te || (te = {})), function(e2) {
  e2[e2.OPERATOR_UNSPECIFIED = 0] = "OPERATOR_UNSPECIFIED", e2[e2.LESS_THAN = 1] = "LESS_THAN", e2[e2.LESS_THAN_OR_EQUAL = 2] = "LESS_THAN_OR_EQUAL", e2[e2.GREATER_THAN = 3] = "GREATER_THAN", e2[e2.GREATER_THAN_OR_EQUAL = 4] = "GREATER_THAN_OR_EQUAL", e2[e2.EQUAL = 5] = "EQUAL", e2[e2.NOT_EQUAL = 6] = "NOT_EQUAL", e2[e2.ARRAY_CONTAINS = 7] = "ARRAY_CONTAINS";
}(re || (re = {}));
var ne = new class extends Y {
  constructor() {
    super("db3_database_proto.Database", [{ no: 1, name: "address", kind: "scalar", T: 12 }, { no: 2, name: "sender", kind: "scalar", T: 12 }, { no: 3, name: "tx", kind: "scalar", repeat: 2, T: 12 }, { no: 4, name: "collections", kind: "map", K: 9, V: { kind: "message", T: () => ie } }]);
  }
}();
var ie = new class extends Y {
  constructor() {
    super("db3_database_proto.Collection", [{ no: 1, name: "id", kind: "scalar", T: 12 }, { no: 2, name: "name", kind: "scalar", T: 9 }, { no: 3, name: "index_list", kind: "message", repeat: 1, T: () => se }]);
  }
}();
var oe = new class extends Y {
  constructor() {
    super("db3_database_proto.Document", [{ no: 1, name: "id", kind: "scalar", T: 12 }, { no: 2, name: "doc", kind: "scalar", T: 12 }, { no: 3, name: "owner", kind: "scalar", T: 12 }, { no: 4, name: "tx_id", kind: "scalar", T: 12 }]);
  }
}();
var se = new class extends Y {
  constructor() {
    super("db3_database_proto.Index", [{ no: 1, name: "name", kind: "scalar", T: 9 }, { no: 2, name: "id", kind: "scalar", T: 13 }, { no: 3, name: "fields", kind: "message", repeat: 1, T: () => ae }]);
  }
}();
var ae = new class extends Y {
  constructor() {
    super("db3_database_proto.Index.IndexField", [{ no: 1, name: "field_path", kind: "scalar", T: 9 }, { no: 2, name: "order", kind: "enum", oneof: "valueMode", T: () => ["db3_database_proto.Index.IndexField.Order", Q] }, { no: 3, name: "array_config", kind: "enum", oneof: "valueMode", T: () => ["db3_database_proto.Index.IndexField.ArrayConfig", ee] }]);
  }
}();
var ue = new class extends Y {
  constructor() {
    super("db3_database_proto.StructuredQuery", [{ no: 1, name: "select", kind: "message", T: () => le }, { no: 2, name: "collection_name", kind: "scalar", T: 9 }, { no: 3, name: "where", kind: "message", T: () => he }, { no: 5, name: "limit", kind: "message", T: () => de }]);
  }
}();
var he = new class extends Y {
  constructor() {
    super("db3_database_proto.StructuredQuery.Filter", [{ no: 1, name: "field_filter", kind: "message", oneof: "filterType", T: () => ce }]);
  }
}();
var fe = new class extends Y {
  constructor() {
    super("db3_database_proto.StructuredQuery.Value", [{ no: 1, name: "boolean_value", kind: "scalar", oneof: "valueType", T: 8 }, { no: 2, name: "integer_value", kind: "scalar", oneof: "valueType", T: 3 }, { no: 3, name: "double_value", kind: "scalar", oneof: "valueType", T: 1 }, { no: 17, name: "string_value", kind: "scalar", oneof: "valueType", T: 9 }]);
  }
}();
var ce = new class extends Y {
  constructor() {
    super("db3_database_proto.StructuredQuery.FieldFilter", [{ no: 1, name: "field", kind: "scalar", T: 9 }, { no: 2, name: "op", kind: "enum", T: () => ["db3_database_proto.StructuredQuery.FieldFilter.Operator", re] }, { no: 3, name: "value", kind: "message", T: () => fe }]);
  }
}();
var le = new class extends Y {
  constructor() {
    super("db3_database_proto.StructuredQuery.Projection", [{ no: 1, name: "fields", kind: "scalar", repeat: 2, T: 9 }]);
  }
}();
var de = new class extends Y {
  constructor() {
    super("db3_database_proto.StructuredQuery.Limit", [{ no: 1, name: "limit", kind: "scalar", T: 5 }]);
  }
}();
var pe = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ye(e2) {
  var t2 = { exports: {} };
  return e2(t2, t2.exports), t2.exports;
}
function ge(e2) {
  throw new Error('Could not dynamically require "' + e2 + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
}
var me = { __proto__: null, default: {} };
var we = ye(function(e2) {
  !function(e3) {
    var t2 = function(e4) {
      var t3, r3 = new Float64Array(16);
      if (e4)
        for (t3 = 0; t3 < e4.length; t3++)
          r3[t3] = e4[t3];
      return r3;
    }, r2 = function() {
      throw new Error("no PRNG");
    }, n2 = new Uint8Array(16), i2 = new Uint8Array(32);
    i2[0] = 9;
    var o2 = t2(), s2 = t2([1]), a2 = t2([56129, 1]), u2 = t2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), h2 = t2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), f2 = t2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), c2 = t2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), l2 = t2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function d2(e4, t3, r3, n3) {
      e4[t3] = r3 >> 24 & 255, e4[t3 + 1] = r3 >> 16 & 255, e4[t3 + 2] = r3 >> 8 & 255, e4[t3 + 3] = 255 & r3, e4[t3 + 4] = n3 >> 24 & 255, e4[t3 + 5] = n3 >> 16 & 255, e4[t3 + 6] = n3 >> 8 & 255, e4[t3 + 7] = 255 & n3;
    }
    function p2(e4, t3, r3, n3, i3) {
      var o3, s3 = 0;
      for (o3 = 0; o3 < i3; o3++)
        s3 |= e4[t3 + o3] ^ r3[n3 + o3];
      return (1 & s3 - 1 >>> 8) - 1;
    }
    function y2(e4, t3, r3, n3) {
      return p2(e4, t3, r3, n3, 16);
    }
    function g2(e4, t3, r3, n3) {
      return p2(e4, t3, r3, n3, 32);
    }
    function m2(e4, t3, r3, n3) {
      !function(e5, t4, r4, n4) {
        for (var i3, o3 = 255 & n4[0] | (255 & n4[1]) << 8 | (255 & n4[2]) << 16 | (255 & n4[3]) << 24, s3 = 255 & r4[0] | (255 & r4[1]) << 8 | (255 & r4[2]) << 16 | (255 & r4[3]) << 24, a3 = 255 & r4[4] | (255 & r4[5]) << 8 | (255 & r4[6]) << 16 | (255 & r4[7]) << 24, u3 = 255 & r4[8] | (255 & r4[9]) << 8 | (255 & r4[10]) << 16 | (255 & r4[11]) << 24, h3 = 255 & r4[12] | (255 & r4[13]) << 8 | (255 & r4[14]) << 16 | (255 & r4[15]) << 24, f3 = 255 & n4[4] | (255 & n4[5]) << 8 | (255 & n4[6]) << 16 | (255 & n4[7]) << 24, c3 = 255 & t4[0] | (255 & t4[1]) << 8 | (255 & t4[2]) << 16 | (255 & t4[3]) << 24, l3 = 255 & t4[4] | (255 & t4[5]) << 8 | (255 & t4[6]) << 16 | (255 & t4[7]) << 24, d3 = 255 & t4[8] | (255 & t4[9]) << 8 | (255 & t4[10]) << 16 | (255 & t4[11]) << 24, p3 = 255 & t4[12] | (255 & t4[13]) << 8 | (255 & t4[14]) << 16 | (255 & t4[15]) << 24, y3 = 255 & n4[8] | (255 & n4[9]) << 8 | (255 & n4[10]) << 16 | (255 & n4[11]) << 24, g3 = 255 & r4[16] | (255 & r4[17]) << 8 | (255 & r4[18]) << 16 | (255 & r4[19]) << 24, m3 = 255 & r4[20] | (255 & r4[21]) << 8 | (255 & r4[22]) << 16 | (255 & r4[23]) << 24, w3 = 255 & r4[24] | (255 & r4[25]) << 8 | (255 & r4[26]) << 16 | (255 & r4[27]) << 24, b3 = 255 & r4[28] | (255 & r4[29]) << 8 | (255 & r4[30]) << 16 | (255 & r4[31]) << 24, v3 = 255 & n4[12] | (255 & n4[13]) << 8 | (255 & n4[14]) << 16 | (255 & n4[15]) << 24, E3 = o3, x3 = s3, B3 = a3, A3 = u3, _3 = h3, T3 = f3, S3 = c3, N3 = l3, I3 = d3, O3 = p3, U3 = y3, L3 = g3, k3 = m3, M3 = w3, C3 = b3, P3 = v3, R3 = 0; R3 < 20; R3 += 2)
          E3 ^= (i3 = (k3 ^= (i3 = (I3 ^= (i3 = (_3 ^= (i3 = E3 + k3 | 0) << 7 | i3 >>> 25) + E3 | 0) << 9 | i3 >>> 23) + _3 | 0) << 13 | i3 >>> 19) + I3 | 0) << 18 | i3 >>> 14, T3 ^= (i3 = (x3 ^= (i3 = (M3 ^= (i3 = (O3 ^= (i3 = T3 + x3 | 0) << 7 | i3 >>> 25) + T3 | 0) << 9 | i3 >>> 23) + O3 | 0) << 13 | i3 >>> 19) + M3 | 0) << 18 | i3 >>> 14, U3 ^= (i3 = (S3 ^= (i3 = (B3 ^= (i3 = (C3 ^= (i3 = U3 + S3 | 0) << 7 | i3 >>> 25) + U3 | 0) << 9 | i3 >>> 23) + C3 | 0) << 13 | i3 >>> 19) + B3 | 0) << 18 | i3 >>> 14, P3 ^= (i3 = (L3 ^= (i3 = (N3 ^= (i3 = (A3 ^= (i3 = P3 + L3 | 0) << 7 | i3 >>> 25) + P3 | 0) << 9 | i3 >>> 23) + A3 | 0) << 13 | i3 >>> 19) + N3 | 0) << 18 | i3 >>> 14, E3 ^= (i3 = (A3 ^= (i3 = (B3 ^= (i3 = (x3 ^= (i3 = E3 + A3 | 0) << 7 | i3 >>> 25) + E3 | 0) << 9 | i3 >>> 23) + x3 | 0) << 13 | i3 >>> 19) + B3 | 0) << 18 | i3 >>> 14, T3 ^= (i3 = (_3 ^= (i3 = (N3 ^= (i3 = (S3 ^= (i3 = T3 + _3 | 0) << 7 | i3 >>> 25) + T3 | 0) << 9 | i3 >>> 23) + S3 | 0) << 13 | i3 >>> 19) + N3 | 0) << 18 | i3 >>> 14, U3 ^= (i3 = (O3 ^= (i3 = (I3 ^= (i3 = (L3 ^= (i3 = U3 + O3 | 0) << 7 | i3 >>> 25) + U3 | 0) << 9 | i3 >>> 23) + L3 | 0) << 13 | i3 >>> 19) + I3 | 0) << 18 | i3 >>> 14, P3 ^= (i3 = (C3 ^= (i3 = (M3 ^= (i3 = (k3 ^= (i3 = P3 + C3 | 0) << 7 | i3 >>> 25) + P3 | 0) << 9 | i3 >>> 23) + k3 | 0) << 13 | i3 >>> 19) + M3 | 0) << 18 | i3 >>> 14;
        x3 = x3 + s3 | 0, B3 = B3 + a3 | 0, A3 = A3 + u3 | 0, _3 = _3 + h3 | 0, T3 = T3 + f3 | 0, S3 = S3 + c3 | 0, N3 = N3 + l3 | 0, I3 = I3 + d3 | 0, O3 = O3 + p3 | 0, U3 = U3 + y3 | 0, L3 = L3 + g3 | 0, k3 = k3 + m3 | 0, M3 = M3 + w3 | 0, C3 = C3 + b3 | 0, P3 = P3 + v3 | 0, e5[0] = (E3 = E3 + o3 | 0) >>> 0 & 255, e5[1] = E3 >>> 8 & 255, e5[2] = E3 >>> 16 & 255, e5[3] = E3 >>> 24 & 255, e5[4] = x3 >>> 0 & 255, e5[5] = x3 >>> 8 & 255, e5[6] = x3 >>> 16 & 255, e5[7] = x3 >>> 24 & 255, e5[8] = B3 >>> 0 & 255, e5[9] = B3 >>> 8 & 255, e5[10] = B3 >>> 16 & 255, e5[11] = B3 >>> 24 & 255, e5[12] = A3 >>> 0 & 255, e5[13] = A3 >>> 8 & 255, e5[14] = A3 >>> 16 & 255, e5[15] = A3 >>> 24 & 255, e5[16] = _3 >>> 0 & 255, e5[17] = _3 >>> 8 & 255, e5[18] = _3 >>> 16 & 255, e5[19] = _3 >>> 24 & 255, e5[20] = T3 >>> 0 & 255, e5[21] = T3 >>> 8 & 255, e5[22] = T3 >>> 16 & 255, e5[23] = T3 >>> 24 & 255, e5[24] = S3 >>> 0 & 255, e5[25] = S3 >>> 8 & 255, e5[26] = S3 >>> 16 & 255, e5[27] = S3 >>> 24 & 255, e5[28] = N3 >>> 0 & 255, e5[29] = N3 >>> 8 & 255, e5[30] = N3 >>> 16 & 255, e5[31] = N3 >>> 24 & 255, e5[32] = I3 >>> 0 & 255, e5[33] = I3 >>> 8 & 255, e5[34] = I3 >>> 16 & 255, e5[35] = I3 >>> 24 & 255, e5[36] = O3 >>> 0 & 255, e5[37] = O3 >>> 8 & 255, e5[38] = O3 >>> 16 & 255, e5[39] = O3 >>> 24 & 255, e5[40] = U3 >>> 0 & 255, e5[41] = U3 >>> 8 & 255, e5[42] = U3 >>> 16 & 255, e5[43] = U3 >>> 24 & 255, e5[44] = L3 >>> 0 & 255, e5[45] = L3 >>> 8 & 255, e5[46] = L3 >>> 16 & 255, e5[47] = L3 >>> 24 & 255, e5[48] = k3 >>> 0 & 255, e5[49] = k3 >>> 8 & 255, e5[50] = k3 >>> 16 & 255, e5[51] = k3 >>> 24 & 255, e5[52] = M3 >>> 0 & 255, e5[53] = M3 >>> 8 & 255, e5[54] = M3 >>> 16 & 255, e5[55] = M3 >>> 24 & 255, e5[56] = C3 >>> 0 & 255, e5[57] = C3 >>> 8 & 255, e5[58] = C3 >>> 16 & 255, e5[59] = C3 >>> 24 & 255, e5[60] = P3 >>> 0 & 255, e5[61] = P3 >>> 8 & 255, e5[62] = P3 >>> 16 & 255, e5[63] = P3 >>> 24 & 255;
      }(e4, t3, r3, n3);
    }
    function w2(e4, t3, r3, n3) {
      !function(e5, t4, r4, n4) {
        for (var i3, o3 = 255 & n4[0] | (255 & n4[1]) << 8 | (255 & n4[2]) << 16 | (255 & n4[3]) << 24, s3 = 255 & r4[0] | (255 & r4[1]) << 8 | (255 & r4[2]) << 16 | (255 & r4[3]) << 24, a3 = 255 & r4[4] | (255 & r4[5]) << 8 | (255 & r4[6]) << 16 | (255 & r4[7]) << 24, u3 = 255 & r4[8] | (255 & r4[9]) << 8 | (255 & r4[10]) << 16 | (255 & r4[11]) << 24, h3 = 255 & r4[12] | (255 & r4[13]) << 8 | (255 & r4[14]) << 16 | (255 & r4[15]) << 24, f3 = 255 & n4[4] | (255 & n4[5]) << 8 | (255 & n4[6]) << 16 | (255 & n4[7]) << 24, c3 = 255 & t4[0] | (255 & t4[1]) << 8 | (255 & t4[2]) << 16 | (255 & t4[3]) << 24, l3 = 255 & t4[4] | (255 & t4[5]) << 8 | (255 & t4[6]) << 16 | (255 & t4[7]) << 24, d3 = 255 & t4[8] | (255 & t4[9]) << 8 | (255 & t4[10]) << 16 | (255 & t4[11]) << 24, p3 = 255 & t4[12] | (255 & t4[13]) << 8 | (255 & t4[14]) << 16 | (255 & t4[15]) << 24, y3 = 255 & n4[8] | (255 & n4[9]) << 8 | (255 & n4[10]) << 16 | (255 & n4[11]) << 24, g3 = 255 & r4[16] | (255 & r4[17]) << 8 | (255 & r4[18]) << 16 | (255 & r4[19]) << 24, m3 = 255 & r4[20] | (255 & r4[21]) << 8 | (255 & r4[22]) << 16 | (255 & r4[23]) << 24, w3 = 255 & r4[24] | (255 & r4[25]) << 8 | (255 & r4[26]) << 16 | (255 & r4[27]) << 24, b3 = 255 & r4[28] | (255 & r4[29]) << 8 | (255 & r4[30]) << 16 | (255 & r4[31]) << 24, v3 = 255 & n4[12] | (255 & n4[13]) << 8 | (255 & n4[14]) << 16 | (255 & n4[15]) << 24, E3 = 0; E3 < 20; E3 += 2)
          o3 ^= (i3 = (m3 ^= (i3 = (d3 ^= (i3 = (h3 ^= (i3 = o3 + m3 | 0) << 7 | i3 >>> 25) + o3 | 0) << 9 | i3 >>> 23) + h3 | 0) << 13 | i3 >>> 19) + d3 | 0) << 18 | i3 >>> 14, f3 ^= (i3 = (s3 ^= (i3 = (w3 ^= (i3 = (p3 ^= (i3 = f3 + s3 | 0) << 7 | i3 >>> 25) + f3 | 0) << 9 | i3 >>> 23) + p3 | 0) << 13 | i3 >>> 19) + w3 | 0) << 18 | i3 >>> 14, y3 ^= (i3 = (c3 ^= (i3 = (a3 ^= (i3 = (b3 ^= (i3 = y3 + c3 | 0) << 7 | i3 >>> 25) + y3 | 0) << 9 | i3 >>> 23) + b3 | 0) << 13 | i3 >>> 19) + a3 | 0) << 18 | i3 >>> 14, v3 ^= (i3 = (g3 ^= (i3 = (l3 ^= (i3 = (u3 ^= (i3 = v3 + g3 | 0) << 7 | i3 >>> 25) + v3 | 0) << 9 | i3 >>> 23) + u3 | 0) << 13 | i3 >>> 19) + l3 | 0) << 18 | i3 >>> 14, o3 ^= (i3 = (u3 ^= (i3 = (a3 ^= (i3 = (s3 ^= (i3 = o3 + u3 | 0) << 7 | i3 >>> 25) + o3 | 0) << 9 | i3 >>> 23) + s3 | 0) << 13 | i3 >>> 19) + a3 | 0) << 18 | i3 >>> 14, f3 ^= (i3 = (h3 ^= (i3 = (l3 ^= (i3 = (c3 ^= (i3 = f3 + h3 | 0) << 7 | i3 >>> 25) + f3 | 0) << 9 | i3 >>> 23) + c3 | 0) << 13 | i3 >>> 19) + l3 | 0) << 18 | i3 >>> 14, y3 ^= (i3 = (p3 ^= (i3 = (d3 ^= (i3 = (g3 ^= (i3 = y3 + p3 | 0) << 7 | i3 >>> 25) + y3 | 0) << 9 | i3 >>> 23) + g3 | 0) << 13 | i3 >>> 19) + d3 | 0) << 18 | i3 >>> 14, v3 ^= (i3 = (b3 ^= (i3 = (w3 ^= (i3 = (m3 ^= (i3 = v3 + b3 | 0) << 7 | i3 >>> 25) + v3 | 0) << 9 | i3 >>> 23) + m3 | 0) << 13 | i3 >>> 19) + w3 | 0) << 18 | i3 >>> 14;
        e5[0] = o3 >>> 0 & 255, e5[1] = o3 >>> 8 & 255, e5[2] = o3 >>> 16 & 255, e5[3] = o3 >>> 24 & 255, e5[4] = f3 >>> 0 & 255, e5[5] = f3 >>> 8 & 255, e5[6] = f3 >>> 16 & 255, e5[7] = f3 >>> 24 & 255, e5[8] = y3 >>> 0 & 255, e5[9] = y3 >>> 8 & 255, e5[10] = y3 >>> 16 & 255, e5[11] = y3 >>> 24 & 255, e5[12] = v3 >>> 0 & 255, e5[13] = v3 >>> 8 & 255, e5[14] = v3 >>> 16 & 255, e5[15] = v3 >>> 24 & 255, e5[16] = c3 >>> 0 & 255, e5[17] = c3 >>> 8 & 255, e5[18] = c3 >>> 16 & 255, e5[19] = c3 >>> 24 & 255, e5[20] = l3 >>> 0 & 255, e5[21] = l3 >>> 8 & 255, e5[22] = l3 >>> 16 & 255, e5[23] = l3 >>> 24 & 255, e5[24] = d3 >>> 0 & 255, e5[25] = d3 >>> 8 & 255, e5[26] = d3 >>> 16 & 255, e5[27] = d3 >>> 24 & 255, e5[28] = p3 >>> 0 & 255, e5[29] = p3 >>> 8 & 255, e5[30] = p3 >>> 16 & 255, e5[31] = p3 >>> 24 & 255;
      }(e4, t3, r3, n3);
    }
    var b2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function v2(e4, t3, r3, n3, i3, o3, s3) {
      var a3, u3, h3 = new Uint8Array(16), f3 = new Uint8Array(64);
      for (u3 = 0; u3 < 16; u3++)
        h3[u3] = 0;
      for (u3 = 0; u3 < 8; u3++)
        h3[u3] = o3[u3];
      for (; i3 >= 64; ) {
        for (m2(f3, h3, s3, b2), u3 = 0; u3 < 64; u3++)
          e4[t3 + u3] = r3[n3 + u3] ^ f3[u3];
        for (a3 = 1, u3 = 8; u3 < 16; u3++)
          h3[u3] = 255 & (a3 = a3 + (255 & h3[u3]) | 0), a3 >>>= 8;
        i3 -= 64, t3 += 64, n3 += 64;
      }
      if (i3 > 0)
        for (m2(f3, h3, s3, b2), u3 = 0; u3 < i3; u3++)
          e4[t3 + u3] = r3[n3 + u3] ^ f3[u3];
      return 0;
    }
    function E2(e4, t3, r3, n3, i3) {
      var o3, s3, a3 = new Uint8Array(16), u3 = new Uint8Array(64);
      for (s3 = 0; s3 < 16; s3++)
        a3[s3] = 0;
      for (s3 = 0; s3 < 8; s3++)
        a3[s3] = n3[s3];
      for (; r3 >= 64; ) {
        for (m2(u3, a3, i3, b2), s3 = 0; s3 < 64; s3++)
          e4[t3 + s3] = u3[s3];
        for (o3 = 1, s3 = 8; s3 < 16; s3++)
          a3[s3] = 255 & (o3 = o3 + (255 & a3[s3]) | 0), o3 >>>= 8;
        r3 -= 64, t3 += 64;
      }
      if (r3 > 0)
        for (m2(u3, a3, i3, b2), s3 = 0; s3 < r3; s3++)
          e4[t3 + s3] = u3[s3];
      return 0;
    }
    function x2(e4, t3, r3, n3, i3) {
      var o3 = new Uint8Array(32);
      w2(o3, n3, i3, b2);
      for (var s3 = new Uint8Array(8), a3 = 0; a3 < 8; a3++)
        s3[a3] = n3[a3 + 16];
      return E2(e4, t3, r3, s3, o3);
    }
    function B2(e4, t3, r3, n3, i3, o3, s3) {
      var a3 = new Uint8Array(32);
      w2(a3, o3, s3, b2);
      for (var u3 = new Uint8Array(8), h3 = 0; h3 < 8; h3++)
        u3[h3] = o3[h3 + 16];
      return v2(e4, t3, r3, n3, i3, u3, a3);
    }
    var A2 = function(e4) {
      var t3, r3, n3, i3, o3, s3, a3, u3;
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, this.r[0] = 8191 & (t3 = 255 & e4[0] | (255 & e4[1]) << 8), this.r[1] = 8191 & (t3 >>> 13 | (r3 = 255 & e4[2] | (255 & e4[3]) << 8) << 3), this.r[2] = 7939 & (r3 >>> 10 | (n3 = 255 & e4[4] | (255 & e4[5]) << 8) << 6), this.r[3] = 8191 & (n3 >>> 7 | (i3 = 255 & e4[6] | (255 & e4[7]) << 8) << 9), this.r[4] = 255 & (i3 >>> 4 | (o3 = 255 & e4[8] | (255 & e4[9]) << 8) << 12), this.r[5] = o3 >>> 1 & 8190, this.r[6] = 8191 & (o3 >>> 14 | (s3 = 255 & e4[10] | (255 & e4[11]) << 8) << 2), this.r[7] = 8065 & (s3 >>> 11 | (a3 = 255 & e4[12] | (255 & e4[13]) << 8) << 5), this.r[8] = 8191 & (a3 >>> 8 | (u3 = 255 & e4[14] | (255 & e4[15]) << 8) << 8), this.r[9] = u3 >>> 5 & 127, this.pad[0] = 255 & e4[16] | (255 & e4[17]) << 8, this.pad[1] = 255 & e4[18] | (255 & e4[19]) << 8, this.pad[2] = 255 & e4[20] | (255 & e4[21]) << 8, this.pad[3] = 255 & e4[22] | (255 & e4[23]) << 8, this.pad[4] = 255 & e4[24] | (255 & e4[25]) << 8, this.pad[5] = 255 & e4[26] | (255 & e4[27]) << 8, this.pad[6] = 255 & e4[28] | (255 & e4[29]) << 8, this.pad[7] = 255 & e4[30] | (255 & e4[31]) << 8;
    };
    function _2(e4, t3, r3, n3, i3, o3) {
      var s3 = new A2(o3);
      return s3.update(r3, n3, i3), s3.finish(e4, t3), 0;
    }
    function T2(e4, t3, r3, n3, i3, o3) {
      var s3 = new Uint8Array(16);
      return _2(s3, 0, r3, n3, i3, o3), y2(e4, t3, s3, 0);
    }
    function S2(e4, t3, r3, n3, i3) {
      var o3;
      if (r3 < 32)
        return -1;
      for (B2(e4, 0, t3, 0, r3, n3, i3), _2(e4, 16, e4, 32, r3 - 32, e4), o3 = 0; o3 < 16; o3++)
        e4[o3] = 0;
      return 0;
    }
    function N2(e4, t3, r3, n3, i3) {
      var o3, s3 = new Uint8Array(32);
      if (r3 < 32)
        return -1;
      if (x2(s3, 0, 32, n3, i3), 0 !== T2(t3, 16, t3, 32, r3 - 32, s3))
        return -1;
      for (B2(e4, 0, t3, 0, r3, n3, i3), o3 = 0; o3 < 32; o3++)
        e4[o3] = 0;
      return 0;
    }
    function I2(e4, t3) {
      var r3;
      for (r3 = 0; r3 < 16; r3++)
        e4[r3] = 0 | t3[r3];
    }
    function O2(e4) {
      var t3, r3, n3 = 1;
      for (t3 = 0; t3 < 16; t3++)
        r3 = e4[t3] + n3 + 65535, n3 = Math.floor(r3 / 65536), e4[t3] = r3 - 65536 * n3;
      e4[0] += n3 - 1 + 37 * (n3 - 1);
    }
    function U2(e4, t3, r3) {
      for (var n3, i3 = ~(r3 - 1), o3 = 0; o3 < 16; o3++)
        e4[o3] ^= n3 = i3 & (e4[o3] ^ t3[o3]), t3[o3] ^= n3;
    }
    function L2(e4, r3) {
      var n3, i3, o3, s3 = t2(), a3 = t2();
      for (n3 = 0; n3 < 16; n3++)
        a3[n3] = r3[n3];
      for (O2(a3), O2(a3), O2(a3), i3 = 0; i3 < 2; i3++) {
        for (s3[0] = a3[0] - 65517, n3 = 1; n3 < 15; n3++)
          s3[n3] = a3[n3] - 65535 - (s3[n3 - 1] >> 16 & 1), s3[n3 - 1] &= 65535;
        s3[15] = a3[15] - 32767 - (s3[14] >> 16 & 1), o3 = s3[15] >> 16 & 1, s3[14] &= 65535, U2(a3, s3, 1 - o3);
      }
      for (n3 = 0; n3 < 16; n3++)
        e4[2 * n3] = 255 & a3[n3], e4[2 * n3 + 1] = a3[n3] >> 8;
    }
    function k2(e4, t3) {
      var r3 = new Uint8Array(32), n3 = new Uint8Array(32);
      return L2(r3, e4), L2(n3, t3), g2(r3, 0, n3, 0);
    }
    function M2(e4) {
      var t3 = new Uint8Array(32);
      return L2(t3, e4), 1 & t3[0];
    }
    function C2(e4, t3) {
      var r3;
      for (r3 = 0; r3 < 16; r3++)
        e4[r3] = t3[2 * r3] + (t3[2 * r3 + 1] << 8);
      e4[15] &= 32767;
    }
    function P2(e4, t3, r3) {
      for (var n3 = 0; n3 < 16; n3++)
        e4[n3] = t3[n3] + r3[n3];
    }
    function R2(e4, t3, r3) {
      for (var n3 = 0; n3 < 16; n3++)
        e4[n3] = t3[n3] - r3[n3];
    }
    function D2(e4, t3, r3) {
      var n3, i3, o3 = 0, s3 = 0, a3 = 0, u3 = 0, h3 = 0, f3 = 0, c3 = 0, l3 = 0, d3 = 0, p3 = 0, y3 = 0, g3 = 0, m3 = 0, w3 = 0, b3 = 0, v3 = 0, E3 = 0, x3 = 0, B3 = 0, A3 = 0, _3 = 0, T3 = 0, S3 = 0, N3 = 0, I3 = 0, O3 = 0, U3 = 0, L3 = 0, k3 = 0, M3 = 0, C3 = 0, P3 = r3[0], R3 = r3[1], D3 = r3[2], z3 = r3[3], $3 = r3[4], V3 = r3[5], j3 = r3[6], F3 = r3[7], H3 = r3[8], K3 = r3[9], G3 = r3[10], q3 = r3[11], J3 = r3[12], W3 = r3[13], Z3 = r3[14], Y3 = r3[15];
      o3 += (n3 = t3[0]) * P3, s3 += n3 * R3, a3 += n3 * D3, u3 += n3 * z3, h3 += n3 * $3, f3 += n3 * V3, c3 += n3 * j3, l3 += n3 * F3, d3 += n3 * H3, p3 += n3 * K3, y3 += n3 * G3, g3 += n3 * q3, m3 += n3 * J3, w3 += n3 * W3, b3 += n3 * Z3, v3 += n3 * Y3, s3 += (n3 = t3[1]) * P3, a3 += n3 * R3, u3 += n3 * D3, h3 += n3 * z3, f3 += n3 * $3, c3 += n3 * V3, l3 += n3 * j3, d3 += n3 * F3, p3 += n3 * H3, y3 += n3 * K3, g3 += n3 * G3, m3 += n3 * q3, w3 += n3 * J3, b3 += n3 * W3, v3 += n3 * Z3, E3 += n3 * Y3, a3 += (n3 = t3[2]) * P3, u3 += n3 * R3, h3 += n3 * D3, f3 += n3 * z3, c3 += n3 * $3, l3 += n3 * V3, d3 += n3 * j3, p3 += n3 * F3, y3 += n3 * H3, g3 += n3 * K3, m3 += n3 * G3, w3 += n3 * q3, b3 += n3 * J3, v3 += n3 * W3, E3 += n3 * Z3, x3 += n3 * Y3, u3 += (n3 = t3[3]) * P3, h3 += n3 * R3, f3 += n3 * D3, c3 += n3 * z3, l3 += n3 * $3, d3 += n3 * V3, p3 += n3 * j3, y3 += n3 * F3, g3 += n3 * H3, m3 += n3 * K3, w3 += n3 * G3, b3 += n3 * q3, v3 += n3 * J3, E3 += n3 * W3, x3 += n3 * Z3, B3 += n3 * Y3, h3 += (n3 = t3[4]) * P3, f3 += n3 * R3, c3 += n3 * D3, l3 += n3 * z3, d3 += n3 * $3, p3 += n3 * V3, y3 += n3 * j3, g3 += n3 * F3, m3 += n3 * H3, w3 += n3 * K3, b3 += n3 * G3, v3 += n3 * q3, E3 += n3 * J3, x3 += n3 * W3, B3 += n3 * Z3, A3 += n3 * Y3, f3 += (n3 = t3[5]) * P3, c3 += n3 * R3, l3 += n3 * D3, d3 += n3 * z3, p3 += n3 * $3, y3 += n3 * V3, g3 += n3 * j3, m3 += n3 * F3, w3 += n3 * H3, b3 += n3 * K3, v3 += n3 * G3, E3 += n3 * q3, x3 += n3 * J3, B3 += n3 * W3, A3 += n3 * Z3, _3 += n3 * Y3, c3 += (n3 = t3[6]) * P3, l3 += n3 * R3, d3 += n3 * D3, p3 += n3 * z3, y3 += n3 * $3, g3 += n3 * V3, m3 += n3 * j3, w3 += n3 * F3, b3 += n3 * H3, v3 += n3 * K3, E3 += n3 * G3, x3 += n3 * q3, B3 += n3 * J3, A3 += n3 * W3, _3 += n3 * Z3, T3 += n3 * Y3, l3 += (n3 = t3[7]) * P3, d3 += n3 * R3, p3 += n3 * D3, y3 += n3 * z3, g3 += n3 * $3, m3 += n3 * V3, w3 += n3 * j3, b3 += n3 * F3, v3 += n3 * H3, E3 += n3 * K3, x3 += n3 * G3, B3 += n3 * q3, A3 += n3 * J3, _3 += n3 * W3, T3 += n3 * Z3, S3 += n3 * Y3, d3 += (n3 = t3[8]) * P3, p3 += n3 * R3, y3 += n3 * D3, g3 += n3 * z3, m3 += n3 * $3, w3 += n3 * V3, b3 += n3 * j3, v3 += n3 * F3, E3 += n3 * H3, x3 += n3 * K3, B3 += n3 * G3, A3 += n3 * q3, _3 += n3 * J3, T3 += n3 * W3, S3 += n3 * Z3, N3 += n3 * Y3, p3 += (n3 = t3[9]) * P3, y3 += n3 * R3, g3 += n3 * D3, m3 += n3 * z3, w3 += n3 * $3, b3 += n3 * V3, v3 += n3 * j3, E3 += n3 * F3, x3 += n3 * H3, B3 += n3 * K3, A3 += n3 * G3, _3 += n3 * q3, T3 += n3 * J3, S3 += n3 * W3, N3 += n3 * Z3, I3 += n3 * Y3, y3 += (n3 = t3[10]) * P3, g3 += n3 * R3, m3 += n3 * D3, w3 += n3 * z3, b3 += n3 * $3, v3 += n3 * V3, E3 += n3 * j3, x3 += n3 * F3, B3 += n3 * H3, A3 += n3 * K3, _3 += n3 * G3, T3 += n3 * q3, S3 += n3 * J3, N3 += n3 * W3, I3 += n3 * Z3, O3 += n3 * Y3, g3 += (n3 = t3[11]) * P3, m3 += n3 * R3, w3 += n3 * D3, b3 += n3 * z3, v3 += n3 * $3, E3 += n3 * V3, x3 += n3 * j3, B3 += n3 * F3, A3 += n3 * H3, _3 += n3 * K3, T3 += n3 * G3, S3 += n3 * q3, N3 += n3 * J3, I3 += n3 * W3, O3 += n3 * Z3, U3 += n3 * Y3, m3 += (n3 = t3[12]) * P3, w3 += n3 * R3, b3 += n3 * D3, v3 += n3 * z3, E3 += n3 * $3, x3 += n3 * V3, B3 += n3 * j3, A3 += n3 * F3, _3 += n3 * H3, T3 += n3 * K3, S3 += n3 * G3, N3 += n3 * q3, I3 += n3 * J3, O3 += n3 * W3, U3 += n3 * Z3, L3 += n3 * Y3, w3 += (n3 = t3[13]) * P3, b3 += n3 * R3, v3 += n3 * D3, E3 += n3 * z3, x3 += n3 * $3, B3 += n3 * V3, A3 += n3 * j3, _3 += n3 * F3, T3 += n3 * H3, S3 += n3 * K3, N3 += n3 * G3, I3 += n3 * q3, O3 += n3 * J3, U3 += n3 * W3, L3 += n3 * Z3, k3 += n3 * Y3, b3 += (n3 = t3[14]) * P3, v3 += n3 * R3, E3 += n3 * D3, x3 += n3 * z3, B3 += n3 * $3, A3 += n3 * V3, _3 += n3 * j3, T3 += n3 * F3, S3 += n3 * H3, N3 += n3 * K3, I3 += n3 * G3, O3 += n3 * q3, U3 += n3 * J3, L3 += n3 * W3, k3 += n3 * Z3, M3 += n3 * Y3, v3 += (n3 = t3[15]) * P3, s3 += 38 * (x3 += n3 * D3), a3 += 38 * (B3 += n3 * z3), u3 += 38 * (A3 += n3 * $3), h3 += 38 * (_3 += n3 * V3), f3 += 38 * (T3 += n3 * j3), c3 += 38 * (S3 += n3 * F3), l3 += 38 * (N3 += n3 * H3), d3 += 38 * (I3 += n3 * K3), p3 += 38 * (O3 += n3 * G3), y3 += 38 * (U3 += n3 * q3), g3 += 38 * (L3 += n3 * J3), m3 += 38 * (k3 += n3 * W3), w3 += 38 * (M3 += n3 * Z3), b3 += 38 * (C3 += n3 * Y3), o3 = (n3 = (o3 += 38 * (E3 += n3 * R3)) + (i3 = 1) + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), s3 = (n3 = s3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), a3 = (n3 = a3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), u3 = (n3 = u3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), h3 = (n3 = h3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), f3 = (n3 = f3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), c3 = (n3 = c3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), l3 = (n3 = l3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), d3 = (n3 = d3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), p3 = (n3 = p3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), y3 = (n3 = y3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), g3 = (n3 = g3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), m3 = (n3 = m3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), w3 = (n3 = w3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), b3 = (n3 = b3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), v3 = (n3 = v3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), o3 = (n3 = (o3 += i3 - 1 + 37 * (i3 - 1)) + (i3 = 1) + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), s3 = (n3 = s3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), a3 = (n3 = a3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), u3 = (n3 = u3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), h3 = (n3 = h3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), f3 = (n3 = f3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), c3 = (n3 = c3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), l3 = (n3 = l3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), d3 = (n3 = d3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), p3 = (n3 = p3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), y3 = (n3 = y3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), g3 = (n3 = g3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), m3 = (n3 = m3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), w3 = (n3 = w3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), b3 = (n3 = b3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), v3 = (n3 = v3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), e4[0] = o3 += i3 - 1 + 37 * (i3 - 1), e4[1] = s3, e4[2] = a3, e4[3] = u3, e4[4] = h3, e4[5] = f3, e4[6] = c3, e4[7] = l3, e4[8] = d3, e4[9] = p3, e4[10] = y3, e4[11] = g3, e4[12] = m3, e4[13] = w3, e4[14] = b3, e4[15] = v3;
    }
    function z2(e4, t3) {
      D2(e4, t3, t3);
    }
    function $2(e4, r3) {
      var n3, i3 = t2();
      for (n3 = 0; n3 < 16; n3++)
        i3[n3] = r3[n3];
      for (n3 = 253; n3 >= 0; n3--)
        z2(i3, i3), 2 !== n3 && 4 !== n3 && D2(i3, i3, r3);
      for (n3 = 0; n3 < 16; n3++)
        e4[n3] = i3[n3];
    }
    function V2(e4, r3) {
      var n3, i3 = t2();
      for (n3 = 0; n3 < 16; n3++)
        i3[n3] = r3[n3];
      for (n3 = 250; n3 >= 0; n3--)
        z2(i3, i3), 1 !== n3 && D2(i3, i3, r3);
      for (n3 = 0; n3 < 16; n3++)
        e4[n3] = i3[n3];
    }
    function j2(e4, r3, n3) {
      var i3, o3, s3 = new Uint8Array(32), u3 = new Float64Array(80), h3 = t2(), f3 = t2(), c3 = t2(), l3 = t2(), d3 = t2(), p3 = t2();
      for (o3 = 0; o3 < 31; o3++)
        s3[o3] = r3[o3];
      for (s3[31] = 127 & r3[31] | 64, s3[0] &= 248, C2(u3, n3), o3 = 0; o3 < 16; o3++)
        f3[o3] = u3[o3], l3[o3] = h3[o3] = c3[o3] = 0;
      for (h3[0] = l3[0] = 1, o3 = 254; o3 >= 0; --o3)
        U2(h3, f3, i3 = s3[o3 >>> 3] >>> (7 & o3) & 1), U2(c3, l3, i3), P2(d3, h3, c3), R2(h3, h3, c3), P2(c3, f3, l3), R2(f3, f3, l3), z2(l3, d3), z2(p3, h3), D2(h3, c3, h3), D2(c3, f3, d3), P2(d3, h3, c3), R2(h3, h3, c3), z2(f3, h3), R2(c3, l3, p3), D2(h3, c3, a2), P2(h3, h3, l3), D2(c3, c3, h3), D2(h3, l3, p3), D2(l3, f3, u3), z2(f3, d3), U2(h3, f3, i3), U2(c3, l3, i3);
      for (o3 = 0; o3 < 16; o3++)
        u3[o3 + 16] = h3[o3], u3[o3 + 32] = c3[o3], u3[o3 + 48] = f3[o3], u3[o3 + 64] = l3[o3];
      var y3 = u3.subarray(32), g3 = u3.subarray(16);
      return $2(y3, y3), D2(g3, g3, y3), L2(e4, g3), 0;
    }
    function F2(e4, t3) {
      return j2(e4, t3, i2);
    }
    function H2(e4, t3) {
      return r2(t3, 32), F2(e4, t3);
    }
    function K2(e4, t3, r3) {
      var i3 = new Uint8Array(32);
      return j2(i3, r3, t3), w2(e4, n2, i3, b2);
    }
    A2.prototype.blocks = function(e4, t3, r3) {
      for (var n3, i3, o3, s3, a3, u3, h3, f3, c3, l3, d3, p3, y3, g3, m3, w3, b3, v3, E3, x3 = this.fin ? 0 : 2048, B3 = this.h[0], A3 = this.h[1], _3 = this.h[2], T3 = this.h[3], S3 = this.h[4], N3 = this.h[5], I3 = this.h[6], O3 = this.h[7], U3 = this.h[8], L3 = this.h[9], k3 = this.r[0], M3 = this.r[1], C3 = this.r[2], P3 = this.r[3], R3 = this.r[4], D3 = this.r[5], z3 = this.r[6], $3 = this.r[7], V3 = this.r[8], j3 = this.r[9]; r3 >= 16; )
        l3 = c3 = 0, l3 += (B3 += 8191 & (n3 = 255 & e4[t3 + 0] | (255 & e4[t3 + 1]) << 8)) * k3, l3 += (A3 += 8191 & (n3 >>> 13 | (i3 = 255 & e4[t3 + 2] | (255 & e4[t3 + 3]) << 8) << 3)) * (5 * j3), l3 += (_3 += 8191 & (i3 >>> 10 | (o3 = 255 & e4[t3 + 4] | (255 & e4[t3 + 5]) << 8) << 6)) * (5 * V3), l3 += (T3 += 8191 & (o3 >>> 7 | (s3 = 255 & e4[t3 + 6] | (255 & e4[t3 + 7]) << 8) << 9)) * (5 * $3), c3 = (l3 += (S3 += 8191 & (s3 >>> 4 | (a3 = 255 & e4[t3 + 8] | (255 & e4[t3 + 9]) << 8) << 12)) * (5 * z3)) >>> 13, l3 &= 8191, l3 += (N3 += a3 >>> 1 & 8191) * (5 * D3), l3 += (I3 += 8191 & (a3 >>> 14 | (u3 = 255 & e4[t3 + 10] | (255 & e4[t3 + 11]) << 8) << 2)) * (5 * R3), l3 += (O3 += 8191 & (u3 >>> 11 | (h3 = 255 & e4[t3 + 12] | (255 & e4[t3 + 13]) << 8) << 5)) * (5 * P3), l3 += (U3 += 8191 & (h3 >>> 8 | (f3 = 255 & e4[t3 + 14] | (255 & e4[t3 + 15]) << 8) << 8)) * (5 * C3), d3 = c3 += (l3 += (L3 += f3 >>> 5 | x3) * (5 * M3)) >>> 13, d3 += B3 * M3, d3 += A3 * k3, d3 += _3 * (5 * j3), d3 += T3 * (5 * V3), c3 = (d3 += S3 * (5 * $3)) >>> 13, d3 &= 8191, d3 += N3 * (5 * z3), d3 += I3 * (5 * D3), d3 += O3 * (5 * R3), d3 += U3 * (5 * P3), c3 += (d3 += L3 * (5 * C3)) >>> 13, d3 &= 8191, p3 = c3, p3 += B3 * C3, p3 += A3 * M3, p3 += _3 * k3, p3 += T3 * (5 * j3), c3 = (p3 += S3 * (5 * V3)) >>> 13, p3 &= 8191, p3 += N3 * (5 * $3), p3 += I3 * (5 * z3), p3 += O3 * (5 * D3), p3 += U3 * (5 * R3), y3 = c3 += (p3 += L3 * (5 * P3)) >>> 13, y3 += B3 * P3, y3 += A3 * C3, y3 += _3 * M3, y3 += T3 * k3, c3 = (y3 += S3 * (5 * j3)) >>> 13, y3 &= 8191, y3 += N3 * (5 * V3), y3 += I3 * (5 * $3), y3 += O3 * (5 * z3), y3 += U3 * (5 * D3), g3 = c3 += (y3 += L3 * (5 * R3)) >>> 13, g3 += B3 * R3, g3 += A3 * P3, g3 += _3 * C3, g3 += T3 * M3, c3 = (g3 += S3 * k3) >>> 13, g3 &= 8191, g3 += N3 * (5 * j3), g3 += I3 * (5 * V3), g3 += O3 * (5 * $3), g3 += U3 * (5 * z3), m3 = c3 += (g3 += L3 * (5 * D3)) >>> 13, m3 += B3 * D3, m3 += A3 * R3, m3 += _3 * P3, m3 += T3 * C3, c3 = (m3 += S3 * M3) >>> 13, m3 &= 8191, m3 += N3 * k3, m3 += I3 * (5 * j3), m3 += O3 * (5 * V3), m3 += U3 * (5 * $3), w3 = c3 += (m3 += L3 * (5 * z3)) >>> 13, w3 += B3 * z3, w3 += A3 * D3, w3 += _3 * R3, w3 += T3 * P3, c3 = (w3 += S3 * C3) >>> 13, w3 &= 8191, w3 += N3 * M3, w3 += I3 * k3, w3 += O3 * (5 * j3), w3 += U3 * (5 * V3), b3 = c3 += (w3 += L3 * (5 * $3)) >>> 13, b3 += B3 * $3, b3 += A3 * z3, b3 += _3 * D3, b3 += T3 * R3, c3 = (b3 += S3 * P3) >>> 13, b3 &= 8191, b3 += N3 * C3, b3 += I3 * M3, b3 += O3 * k3, b3 += U3 * (5 * j3), v3 = c3 += (b3 += L3 * (5 * V3)) >>> 13, v3 += B3 * V3, v3 += A3 * $3, v3 += _3 * z3, v3 += T3 * D3, c3 = (v3 += S3 * R3) >>> 13, v3 &= 8191, v3 += N3 * P3, v3 += I3 * C3, v3 += O3 * M3, v3 += U3 * k3, E3 = c3 += (v3 += L3 * (5 * j3)) >>> 13, E3 += B3 * j3, E3 += A3 * V3, E3 += _3 * $3, E3 += T3 * z3, c3 = (E3 += S3 * D3) >>> 13, E3 &= 8191, E3 += N3 * R3, E3 += I3 * P3, E3 += O3 * C3, E3 += U3 * M3, B3 = l3 = 8191 & (c3 = (c3 = ((c3 += (E3 += L3 * k3) >>> 13) << 2) + c3 | 0) + (l3 &= 8191) | 0), A3 = d3 += c3 >>>= 13, _3 = p3 &= 8191, T3 = y3 &= 8191, S3 = g3 &= 8191, N3 = m3 &= 8191, I3 = w3 &= 8191, O3 = b3 &= 8191, U3 = v3 &= 8191, L3 = E3 &= 8191, t3 += 16, r3 -= 16;
      this.h[0] = B3, this.h[1] = A3, this.h[2] = _3, this.h[3] = T3, this.h[4] = S3, this.h[5] = N3, this.h[6] = I3, this.h[7] = O3, this.h[8] = U3, this.h[9] = L3;
    }, A2.prototype.finish = function(e4, t3) {
      var r3, n3, i3, o3, s3 = new Uint16Array(10);
      if (this.leftover) {
        for (o3 = this.leftover, this.buffer[o3++] = 1; o3 < 16; o3++)
          this.buffer[o3] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (r3 = this.h[1] >>> 13, this.h[1] &= 8191, o3 = 2; o3 < 10; o3++)
        this.h[o3] += r3, r3 = this.h[o3] >>> 13, this.h[o3] &= 8191;
      for (this.h[0] += 5 * r3, r3 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += r3, r3 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += r3, s3[0] = this.h[0] + 5, r3 = s3[0] >>> 13, s3[0] &= 8191, o3 = 1; o3 < 10; o3++)
        s3[o3] = this.h[o3] + r3, r3 = s3[o3] >>> 13, s3[o3] &= 8191;
      for (s3[9] -= 8192, n3 = (1 ^ r3) - 1, o3 = 0; o3 < 10; o3++)
        s3[o3] &= n3;
      for (n3 = ~n3, o3 = 0; o3 < 10; o3++)
        this.h[o3] = this.h[o3] & n3 | s3[o3];
      for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), this.h[0] = 65535 & (i3 = this.h[0] + this.pad[0]), o3 = 1; o3 < 8; o3++)
        this.h[o3] = 65535 & (i3 = (this.h[o3] + this.pad[o3] | 0) + (i3 >>> 16) | 0);
      e4[t3 + 0] = this.h[0] >>> 0 & 255, e4[t3 + 1] = this.h[0] >>> 8 & 255, e4[t3 + 2] = this.h[1] >>> 0 & 255, e4[t3 + 3] = this.h[1] >>> 8 & 255, e4[t3 + 4] = this.h[2] >>> 0 & 255, e4[t3 + 5] = this.h[2] >>> 8 & 255, e4[t3 + 6] = this.h[3] >>> 0 & 255, e4[t3 + 7] = this.h[3] >>> 8 & 255, e4[t3 + 8] = this.h[4] >>> 0 & 255, e4[t3 + 9] = this.h[4] >>> 8 & 255, e4[t3 + 10] = this.h[5] >>> 0 & 255, e4[t3 + 11] = this.h[5] >>> 8 & 255, e4[t3 + 12] = this.h[6] >>> 0 & 255, e4[t3 + 13] = this.h[6] >>> 8 & 255, e4[t3 + 14] = this.h[7] >>> 0 & 255, e4[t3 + 15] = this.h[7] >>> 8 & 255;
    }, A2.prototype.update = function(e4, t3, r3) {
      var n3, i3;
      if (this.leftover) {
        for ((i3 = 16 - this.leftover) > r3 && (i3 = r3), n3 = 0; n3 < i3; n3++)
          this.buffer[this.leftover + n3] = e4[t3 + n3];
        if (r3 -= i3, t3 += i3, this.leftover += i3, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (r3 >= 16 && (this.blocks(e4, t3, i3 = r3 - r3 % 16), t3 += i3, r3 -= i3), r3) {
        for (n3 = 0; n3 < r3; n3++)
          this.buffer[this.leftover + n3] = e4[t3 + n3];
        this.leftover += r3;
      }
    };
    var G2 = S2, q2 = N2, J2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function W2(e4, t3, r3, n3) {
      for (var i3, o3, s3, a3, u3, h3, f3, c3, l3, d3, p3, y3, g3, m3, w3, b3, v3, E3, x3, B3, A3, _3, T3 = new Int32Array(16), S3 = new Int32Array(16), N3 = e4[0], I3 = e4[1], O3 = e4[2], U3 = e4[3], L3 = e4[4], k3 = e4[5], M3 = e4[6], C3 = e4[7], P3 = t3[0], R3 = t3[1], D3 = t3[2], z3 = t3[3], $3 = t3[4], V3 = t3[5], j3 = t3[6], F3 = t3[7], H3 = 0; n3 >= 128; ) {
        for (w3 = 0; w3 < 16; w3++)
          T3[w3] = r3[(b3 = 8 * w3 + H3) + 0] << 24 | r3[b3 + 1] << 16 | r3[b3 + 2] << 8 | r3[b3 + 3], S3[w3] = r3[b3 + 4] << 24 | r3[b3 + 5] << 16 | r3[b3 + 6] << 8 | r3[b3 + 7];
        for (w3 = 0; w3 < 80; w3++)
          if (i3 = I3, o3 = O3, s3 = L3, a3 = k3, u3 = M3, f3 = R3, c3 = D3, l3 = $3, d3 = V3, p3 = j3, x3 = 65535 & (E3 = F3), B3 = E3 >>> 16, A3 = 65535 & (v3 = C3), _3 = v3 >>> 16, x3 += 65535 & (E3 = ($3 >>> 14 | L3 << 18) ^ ($3 >>> 18 | L3 << 14) ^ (L3 >>> 9 | $3 << 23)), B3 += E3 >>> 16, A3 += 65535 & (v3 = (L3 >>> 14 | $3 << 18) ^ (L3 >>> 18 | $3 << 14) ^ ($3 >>> 9 | L3 << 23)), _3 += v3 >>> 16, x3 += 65535 & (E3 = $3 & V3 ^ ~$3 & j3), B3 += E3 >>> 16, A3 += 65535 & (v3 = L3 & k3 ^ ~L3 & M3), _3 += v3 >>> 16, x3 += 65535 & (E3 = J2[2 * w3 + 1]), B3 += E3 >>> 16, A3 += 65535 & (v3 = J2[2 * w3]), _3 += v3 >>> 16, B3 += (E3 = S3[w3 % 16]) >>> 16, A3 += 65535 & (v3 = T3[w3 % 16]), _3 += v3 >>> 16, A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16, x3 = 65535 & (E3 = m3 = 65535 & x3 | B3 << 16), B3 = E3 >>> 16, A3 = 65535 & (v3 = g3 = 65535 & A3 | (_3 += A3 >>> 16) << 16), _3 = v3 >>> 16, x3 += 65535 & (E3 = (P3 >>> 28 | N3 << 4) ^ (N3 >>> 2 | P3 << 30) ^ (N3 >>> 7 | P3 << 25)), B3 += E3 >>> 16, A3 += 65535 & (v3 = (N3 >>> 28 | P3 << 4) ^ (P3 >>> 2 | N3 << 30) ^ (P3 >>> 7 | N3 << 25)), _3 += v3 >>> 16, B3 += (E3 = P3 & R3 ^ P3 & D3 ^ R3 & D3) >>> 16, A3 += 65535 & (v3 = N3 & I3 ^ N3 & O3 ^ I3 & O3), _3 += v3 >>> 16, h3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, y3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = z3), B3 = E3 >>> 16, A3 = 65535 & (v3 = U3), _3 = v3 >>> 16, B3 += (E3 = m3) >>> 16, A3 += 65535 & (v3 = g3), _3 += v3 >>> 16, I3 = N3, O3 = i3, U3 = o3, L3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, k3 = s3, M3 = a3, C3 = u3, N3 = h3, R3 = P3, D3 = f3, z3 = c3, $3 = 65535 & x3 | B3 << 16, V3 = l3, j3 = d3, F3 = p3, P3 = y3, w3 % 16 == 15)
            for (b3 = 0; b3 < 16; b3++)
              x3 = 65535 & (E3 = S3[b3]), B3 = E3 >>> 16, A3 = 65535 & (v3 = T3[b3]), _3 = v3 >>> 16, x3 += 65535 & (E3 = S3[(b3 + 9) % 16]), B3 += E3 >>> 16, A3 += 65535 & (v3 = T3[(b3 + 9) % 16]), _3 += v3 >>> 16, x3 += 65535 & (E3 = ((m3 = S3[(b3 + 1) % 16]) >>> 1 | (g3 = T3[(b3 + 1) % 16]) << 31) ^ (m3 >>> 8 | g3 << 24) ^ (m3 >>> 7 | g3 << 25)), B3 += E3 >>> 16, A3 += 65535 & (v3 = (g3 >>> 1 | m3 << 31) ^ (g3 >>> 8 | m3 << 24) ^ g3 >>> 7), _3 += v3 >>> 16, B3 += (E3 = ((m3 = S3[(b3 + 14) % 16]) >>> 19 | (g3 = T3[(b3 + 14) % 16]) << 13) ^ (g3 >>> 29 | m3 << 3) ^ (m3 >>> 6 | g3 << 26)) >>> 16, A3 += 65535 & (v3 = (g3 >>> 19 | m3 << 13) ^ (m3 >>> 29 | g3 << 3) ^ g3 >>> 6), _3 += v3 >>> 16, T3[b3] = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, S3[b3] = 65535 & x3 | B3 << 16;
        x3 = 65535 & (E3 = P3), B3 = E3 >>> 16, A3 = 65535 & (v3 = N3), _3 = v3 >>> 16, B3 += (E3 = t3[0]) >>> 16, A3 += 65535 & (v3 = e4[0]), _3 += v3 >>> 16, e4[0] = N3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[0] = P3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = R3), B3 = E3 >>> 16, A3 = 65535 & (v3 = I3), _3 = v3 >>> 16, B3 += (E3 = t3[1]) >>> 16, A3 += 65535 & (v3 = e4[1]), _3 += v3 >>> 16, e4[1] = I3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[1] = R3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = D3), B3 = E3 >>> 16, A3 = 65535 & (v3 = O3), _3 = v3 >>> 16, B3 += (E3 = t3[2]) >>> 16, A3 += 65535 & (v3 = e4[2]), _3 += v3 >>> 16, e4[2] = O3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[2] = D3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = z3), B3 = E3 >>> 16, A3 = 65535 & (v3 = U3), _3 = v3 >>> 16, B3 += (E3 = t3[3]) >>> 16, A3 += 65535 & (v3 = e4[3]), _3 += v3 >>> 16, e4[3] = U3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[3] = z3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = $3), B3 = E3 >>> 16, A3 = 65535 & (v3 = L3), _3 = v3 >>> 16, B3 += (E3 = t3[4]) >>> 16, A3 += 65535 & (v3 = e4[4]), _3 += v3 >>> 16, e4[4] = L3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[4] = $3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = V3), B3 = E3 >>> 16, A3 = 65535 & (v3 = k3), _3 = v3 >>> 16, B3 += (E3 = t3[5]) >>> 16, A3 += 65535 & (v3 = e4[5]), _3 += v3 >>> 16, e4[5] = k3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[5] = V3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = j3), B3 = E3 >>> 16, A3 = 65535 & (v3 = M3), _3 = v3 >>> 16, B3 += (E3 = t3[6]) >>> 16, A3 += 65535 & (v3 = e4[6]), _3 += v3 >>> 16, e4[6] = M3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[6] = j3 = 65535 & x3 | B3 << 16, x3 = 65535 & (E3 = F3), B3 = E3 >>> 16, A3 = 65535 & (v3 = C3), _3 = v3 >>> 16, B3 += (E3 = t3[7]) >>> 16, A3 += 65535 & (v3 = e4[7]), _3 += v3 >>> 16, e4[7] = C3 = 65535 & (A3 += (B3 += (x3 += 65535 & E3) >>> 16) >>> 16) | (_3 += A3 >>> 16) << 16, t3[7] = F3 = 65535 & x3 | B3 << 16, H3 += 128, n3 -= 128;
      }
      return n3;
    }
    function Z2(e4, t3, r3) {
      var n3, i3 = new Int32Array(8), o3 = new Int32Array(8), s3 = new Uint8Array(256), a3 = r3;
      for (i3[0] = 1779033703, i3[1] = 3144134277, i3[2] = 1013904242, i3[3] = 2773480762, i3[4] = 1359893119, i3[5] = 2600822924, i3[6] = 528734635, i3[7] = 1541459225, o3[0] = 4089235720, o3[1] = 2227873595, o3[2] = 4271175723, o3[3] = 1595750129, o3[4] = 2917565137, o3[5] = 725511199, o3[6] = 4215389547, o3[7] = 327033209, W2(i3, o3, t3, r3), r3 %= 128, n3 = 0; n3 < r3; n3++)
        s3[n3] = t3[a3 - r3 + n3];
      for (s3[r3] = 128, s3[(r3 = 256 - 128 * (r3 < 112 ? 1 : 0)) - 9] = 0, d2(s3, r3 - 8, a3 / 536870912 | 0, a3 << 3), W2(i3, o3, s3, r3), n3 = 0; n3 < 8; n3++)
        d2(e4, 8 * n3, i3[n3], o3[n3]);
      return 0;
    }
    function Y2(e4, r3) {
      var n3 = t2(), i3 = t2(), o3 = t2(), s3 = t2(), a3 = t2(), u3 = t2(), f3 = t2(), c3 = t2(), l3 = t2();
      R2(n3, e4[1], e4[0]), R2(l3, r3[1], r3[0]), D2(n3, n3, l3), P2(i3, e4[0], e4[1]), P2(l3, r3[0], r3[1]), D2(i3, i3, l3), D2(o3, e4[3], r3[3]), D2(o3, o3, h2), D2(s3, e4[2], r3[2]), P2(s3, s3, s3), R2(a3, i3, n3), R2(u3, s3, o3), P2(f3, s3, o3), P2(c3, i3, n3), D2(e4[0], a3, u3), D2(e4[1], c3, f3), D2(e4[2], f3, u3), D2(e4[3], a3, c3);
    }
    function X2(e4, t3, r3) {
      var n3;
      for (n3 = 0; n3 < 4; n3++)
        U2(e4[n3], t3[n3], r3);
    }
    function Q2(e4, r3) {
      var n3 = t2(), i3 = t2(), o3 = t2();
      $2(o3, r3[2]), D2(n3, r3[0], o3), D2(i3, r3[1], o3), L2(e4, i3), e4[31] ^= M2(n3) << 7;
    }
    function ee2(e4, t3, r3) {
      var n3, i3;
      for (I2(e4[0], o2), I2(e4[1], s2), I2(e4[2], s2), I2(e4[3], o2), i3 = 255; i3 >= 0; --i3)
        X2(e4, t3, n3 = r3[i3 / 8 | 0] >> (7 & i3) & 1), Y2(t3, e4), Y2(e4, e4), X2(e4, t3, n3);
    }
    function te2(e4, r3) {
      var n3 = [t2(), t2(), t2(), t2()];
      I2(n3[0], f2), I2(n3[1], c2), I2(n3[2], s2), D2(n3[3], f2, c2), ee2(e4, n3, r3);
    }
    function re2(e4, n3, i3) {
      var o3, s3 = new Uint8Array(64), a3 = [t2(), t2(), t2(), t2()];
      for (i3 || r2(n3, 32), Z2(s3, n3, 32), s3[0] &= 248, s3[31] &= 127, s3[31] |= 64, te2(a3, s3), Q2(e4, a3), o3 = 0; o3 < 32; o3++)
        n3[o3 + 32] = e4[o3];
      return 0;
    }
    var ne2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function ie2(e4, t3) {
      var r3, n3, i3, o3;
      for (n3 = 63; n3 >= 32; --n3) {
        for (r3 = 0, i3 = n3 - 32, o3 = n3 - 12; i3 < o3; ++i3)
          t3[i3] += r3 - 16 * t3[n3] * ne2[i3 - (n3 - 32)], r3 = Math.floor((t3[i3] + 128) / 256), t3[i3] -= 256 * r3;
        t3[i3] += r3, t3[n3] = 0;
      }
      for (r3 = 0, i3 = 0; i3 < 32; i3++)
        t3[i3] += r3 - (t3[31] >> 4) * ne2[i3], r3 = t3[i3] >> 8, t3[i3] &= 255;
      for (i3 = 0; i3 < 32; i3++)
        t3[i3] -= r3 * ne2[i3];
      for (n3 = 0; n3 < 32; n3++)
        t3[n3 + 1] += t3[n3] >> 8, e4[n3] = 255 & t3[n3];
    }
    function oe2(e4) {
      var t3, r3 = new Float64Array(64);
      for (t3 = 0; t3 < 64; t3++)
        r3[t3] = e4[t3];
      for (t3 = 0; t3 < 64; t3++)
        e4[t3] = 0;
      ie2(e4, r3);
    }
    function se2(e4, r3, n3, i3) {
      var o3, s3, a3 = new Uint8Array(64), u3 = new Uint8Array(64), h3 = new Uint8Array(64), f3 = new Float64Array(64), c3 = [t2(), t2(), t2(), t2()];
      Z2(a3, i3, 32), a3[0] &= 248, a3[31] &= 127, a3[31] |= 64;
      var l3 = n3 + 64;
      for (o3 = 0; o3 < n3; o3++)
        e4[64 + o3] = r3[o3];
      for (o3 = 0; o3 < 32; o3++)
        e4[32 + o3] = a3[32 + o3];
      for (Z2(h3, e4.subarray(32), n3 + 32), oe2(h3), te2(c3, h3), Q2(e4, c3), o3 = 32; o3 < 64; o3++)
        e4[o3] = i3[o3];
      for (Z2(u3, e4, n3 + 64), oe2(u3), o3 = 0; o3 < 64; o3++)
        f3[o3] = 0;
      for (o3 = 0; o3 < 32; o3++)
        f3[o3] = h3[o3];
      for (o3 = 0; o3 < 32; o3++)
        for (s3 = 0; s3 < 32; s3++)
          f3[o3 + s3] += u3[o3] * a3[s3];
      return ie2(e4.subarray(32), f3), l3;
    }
    function ae2(e4, r3, n3, i3) {
      var a3, h3 = new Uint8Array(32), f3 = new Uint8Array(64), c3 = [t2(), t2(), t2(), t2()], d3 = [t2(), t2(), t2(), t2()];
      if (n3 < 64)
        return -1;
      if (function(e5, r4) {
        var n4 = t2(), i4 = t2(), a4 = t2(), h4 = t2(), f4 = t2(), c4 = t2(), d4 = t2();
        return I2(e5[2], s2), C2(e5[1], r4), z2(a4, e5[1]), D2(h4, a4, u2), R2(a4, a4, e5[2]), P2(h4, e5[2], h4), z2(f4, h4), z2(c4, f4), D2(d4, c4, f4), D2(n4, d4, a4), D2(n4, n4, h4), V2(n4, n4), D2(n4, n4, a4), D2(n4, n4, h4), D2(n4, n4, h4), D2(e5[0], n4, h4), z2(i4, e5[0]), D2(i4, i4, h4), k2(i4, a4) && D2(e5[0], e5[0], l2), z2(i4, e5[0]), D2(i4, i4, h4), k2(i4, a4) ? -1 : (M2(e5[0]) === r4[31] >> 7 && R2(e5[0], o2, e5[0]), D2(e5[3], e5[0], e5[1]), 0);
      }(d3, i3))
        return -1;
      for (a3 = 0; a3 < n3; a3++)
        e4[a3] = r3[a3];
      for (a3 = 0; a3 < 32; a3++)
        e4[a3 + 32] = i3[a3];
      if (Z2(f3, e4, n3), oe2(f3), ee2(c3, d3, f3), te2(d3, r3.subarray(32)), Y2(c3, d3), Q2(h3, c3), n3 -= 64, g2(r3, 0, h3, 0)) {
        for (a3 = 0; a3 < n3; a3++)
          e4[a3] = 0;
        return -1;
      }
      for (a3 = 0; a3 < n3; a3++)
        e4[a3] = r3[a3 + 64];
      return n3;
    }
    var ue2 = 64, he2 = 32, fe2 = 64;
    function ce2(e4, t3) {
      if (32 !== e4.length)
        throw new Error("bad key size");
      if (24 !== t3.length)
        throw new Error("bad nonce size");
    }
    function le2() {
      for (var e4 = 0; e4 < arguments.length; e4++)
        if (!(arguments[e4] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function de2(e4) {
      for (var t3 = 0; t3 < e4.length; t3++)
        e4[t3] = 0;
    }
    e3.lowlevel = { crypto_core_hsalsa20: w2, crypto_stream_xor: B2, crypto_stream: x2, crypto_stream_salsa20_xor: v2, crypto_stream_salsa20: E2, crypto_onetimeauth: _2, crypto_onetimeauth_verify: T2, crypto_verify_16: y2, crypto_verify_32: g2, crypto_secretbox: S2, crypto_secretbox_open: N2, crypto_scalarmult: j2, crypto_scalarmult_base: F2, crypto_box_beforenm: K2, crypto_box_afternm: G2, crypto_box: function(e4, t3, r3, n3, i3, o3) {
      var s3 = new Uint8Array(32);
      return K2(s3, i3, o3), G2(e4, t3, r3, n3, s3);
    }, crypto_box_open: function(e4, t3, r3, n3, i3, o3) {
      var s3 = new Uint8Array(32);
      return K2(s3, i3, o3), q2(e4, t3, r3, n3, s3);
    }, crypto_box_keypair: H2, crypto_hash: Z2, crypto_sign: se2, crypto_sign_keypair: re2, crypto_sign_open: ae2, crypto_secretbox_KEYBYTES: 32, crypto_secretbox_NONCEBYTES: 24, crypto_secretbox_ZEROBYTES: 32, crypto_secretbox_BOXZEROBYTES: 16, crypto_scalarmult_BYTES: 32, crypto_scalarmult_SCALARBYTES: 32, crypto_box_PUBLICKEYBYTES: 32, crypto_box_SECRETKEYBYTES: 32, crypto_box_BEFORENMBYTES: 32, crypto_box_NONCEBYTES: 24, crypto_box_ZEROBYTES: 32, crypto_box_BOXZEROBYTES: 16, crypto_sign_BYTES: ue2, crypto_sign_PUBLICKEYBYTES: he2, crypto_sign_SECRETKEYBYTES: fe2, crypto_sign_SEEDBYTES: 32, crypto_hash_BYTES: 64, gf: t2, D: u2, L: ne2, pack25519: L2, unpack25519: C2, M: D2, A: P2, S: z2, Z: R2, pow2523: V2, add: Y2, set25519: I2, modL: ie2, scalarmult: ee2, scalarbase: te2 }, e3.randomBytes = function(e4) {
      var t3 = new Uint8Array(e4);
      return r2(t3, e4), t3;
    }, e3.secretbox = function(e4, t3, r3) {
      le2(e4, t3, r3), ce2(r3, t3);
      for (var n3 = new Uint8Array(32 + e4.length), i3 = new Uint8Array(n3.length), o3 = 0; o3 < e4.length; o3++)
        n3[o3 + 32] = e4[o3];
      return S2(i3, n3, n3.length, t3, r3), i3.subarray(16);
    }, e3.secretbox.open = function(e4, t3, r3) {
      le2(e4, t3, r3), ce2(r3, t3);
      for (var n3 = new Uint8Array(16 + e4.length), i3 = new Uint8Array(n3.length), o3 = 0; o3 < e4.length; o3++)
        n3[o3 + 16] = e4[o3];
      return n3.length < 32 || 0 !== N2(i3, n3, n3.length, t3, r3) ? null : i3.subarray(32);
    }, e3.secretbox.keyLength = 32, e3.secretbox.nonceLength = 24, e3.secretbox.overheadLength = 16, e3.scalarMult = function(e4, t3) {
      if (le2(e4, t3), 32 !== e4.length)
        throw new Error("bad n size");
      if (32 !== t3.length)
        throw new Error("bad p size");
      var r3 = new Uint8Array(32);
      return j2(r3, e4, t3), r3;
    }, e3.scalarMult.base = function(e4) {
      if (le2(e4), 32 !== e4.length)
        throw new Error("bad n size");
      var t3 = new Uint8Array(32);
      return F2(t3, e4), t3;
    }, e3.scalarMult.scalarLength = 32, e3.scalarMult.groupElementLength = 32, e3.box = function(t3, r3, n3, i3) {
      var o3 = e3.box.before(n3, i3);
      return e3.secretbox(t3, r3, o3);
    }, e3.box.before = function(e4, t3) {
      le2(e4, t3), function(e5, t4) {
        if (32 !== e5.length)
          throw new Error("bad public key size");
        if (32 !== t4.length)
          throw new Error("bad secret key size");
      }(e4, t3);
      var r3 = new Uint8Array(32);
      return K2(r3, e4, t3), r3;
    }, e3.box.after = e3.secretbox, e3.box.open = function(t3, r3, n3, i3) {
      var o3 = e3.box.before(n3, i3);
      return e3.secretbox.open(t3, r3, o3);
    }, e3.box.open.after = e3.secretbox.open, e3.box.keyPair = function() {
      var e4 = new Uint8Array(32), t3 = new Uint8Array(32);
      return H2(e4, t3), { publicKey: e4, secretKey: t3 };
    }, e3.box.keyPair.fromSecretKey = function(e4) {
      if (le2(e4), 32 !== e4.length)
        throw new Error("bad secret key size");
      var t3 = new Uint8Array(32);
      return F2(t3, e4), { publicKey: t3, secretKey: new Uint8Array(e4) };
    }, e3.box.publicKeyLength = 32, e3.box.secretKeyLength = 32, e3.box.sharedKeyLength = 32, e3.box.nonceLength = 24, e3.box.overheadLength = e3.secretbox.overheadLength, e3.sign = function(e4, t3) {
      if (le2(e4, t3), t3.length !== fe2)
        throw new Error("bad secret key size");
      var r3 = new Uint8Array(ue2 + e4.length);
      return se2(r3, e4, e4.length, t3), r3;
    }, e3.sign.open = function(e4, t3) {
      if (le2(e4, t3), t3.length !== he2)
        throw new Error("bad public key size");
      var r3 = new Uint8Array(e4.length), n3 = ae2(r3, e4, e4.length, t3);
      if (n3 < 0)
        return null;
      for (var i3 = new Uint8Array(n3), o3 = 0; o3 < i3.length; o3++)
        i3[o3] = r3[o3];
      return i3;
    }, e3.sign.detached = function(t3, r3) {
      for (var n3 = e3.sign(t3, r3), i3 = new Uint8Array(ue2), o3 = 0; o3 < i3.length; o3++)
        i3[o3] = n3[o3];
      return i3;
    }, e3.sign.detached.verify = function(e4, t3, r3) {
      if (le2(e4, t3, r3), t3.length !== ue2)
        throw new Error("bad signature size");
      if (r3.length !== he2)
        throw new Error("bad public key size");
      var n3, i3 = new Uint8Array(ue2 + e4.length), o3 = new Uint8Array(ue2 + e4.length);
      for (n3 = 0; n3 < ue2; n3++)
        i3[n3] = t3[n3];
      for (n3 = 0; n3 < e4.length; n3++)
        i3[n3 + ue2] = e4[n3];
      return ae2(o3, i3, i3.length, r3) >= 0;
    }, e3.sign.keyPair = function() {
      var e4 = new Uint8Array(he2), t3 = new Uint8Array(fe2);
      return re2(e4, t3), { publicKey: e4, secretKey: t3 };
    }, e3.sign.keyPair.fromSecretKey = function(e4) {
      if (le2(e4), e4.length !== fe2)
        throw new Error("bad secret key size");
      for (var t3 = new Uint8Array(he2), r3 = 0; r3 < t3.length; r3++)
        t3[r3] = e4[32 + r3];
      return { publicKey: t3, secretKey: new Uint8Array(e4) };
    }, e3.sign.keyPair.fromSeed = function(e4) {
      if (le2(e4), 32 !== e4.length)
        throw new Error("bad seed size");
      for (var t3 = new Uint8Array(he2), r3 = new Uint8Array(fe2), n3 = 0; n3 < 32; n3++)
        r3[n3] = e4[n3];
      return re2(t3, r3, true), { publicKey: t3, secretKey: r3 };
    }, e3.sign.publicKeyLength = he2, e3.sign.secretKeyLength = fe2, e3.sign.seedLength = 32, e3.sign.signatureLength = ue2, e3.hash = function(e4) {
      le2(e4);
      var t3 = new Uint8Array(64);
      return Z2(t3, e4, e4.length), t3;
    }, e3.hash.hashLength = 64, e3.verify = function(e4, t3) {
      return le2(e4, t3), 0 !== e4.length && 0 !== t3.length && e4.length === t3.length && 0 === p2(e4, 0, t3, 0, e4.length);
    }, e3.setPRNG = function(e4) {
      r2 = e4;
    }, function() {
      var t3 = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
      t3 && t3.getRandomValues ? e3.setPRNG(function(e4, r3) {
        var n3, i3 = new Uint8Array(r3);
        for (n3 = 0; n3 < r3; n3 += 65536)
          t3.getRandomValues(i3.subarray(n3, n3 + Math.min(r3 - n3, 65536)));
        for (n3 = 0; n3 < r3; n3++)
          e4[n3] = i3[n3];
        de2(i3);
      }) : void 0 !== ge && (t3 = me) && t3.randomBytes && e3.setPRNG(function(e4, r3) {
        var n3, i3 = t3.randomBytes(r3);
        for (n3 = 0; n3 < r3; n3++)
          e4[n3] = i3[n3];
        de2(i3);
      });
    }();
  }(e2.exports ? e2.exports : self.nacl = self.nacl || {});
});
function be(e2, t2) {
  if (e2 === t2)
    return true;
  if (e2.length !== t2.length)
    return false;
  for (let r2 = 0; r2 < e2.length; r2++)
    if (e2[r2] !== t2[r2])
      return false;
  return true;
}
var ve = ye(function(e2) {
  !function() {
    var t2 = "input is invalid type", r2 = "object" == typeof window, n2 = r2 ? window : {};
    n2.JS_SHA3_NO_WINDOW && (r2 = false);
    var i2 = !r2 && "object" == typeof self;
    !n2.JS_SHA3_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node ? n2 = pe : i2 && (n2 = self);
    var o2 = !n2.JS_SHA3_NO_COMMON_JS && e2.exports, s2 = !n2.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer, a2 = "0123456789abcdef".split(""), u2 = [4, 1024, 262144, 67108864], h2 = [0, 8, 16, 24], f2 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], c2 = [224, 256, 384, 512], l2 = [128, 256], d2 = ["hex", "buffer", "arrayBuffer", "array", "digest"], p2 = { 128: 168, 256: 136 };
    !n2.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function(e3) {
      return "[object Array]" === Object.prototype.toString.call(e3);
    }), !s2 || !n2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e3) {
      return "object" == typeof e3 && e3.buffer && e3.buffer.constructor === ArrayBuffer;
    });
    for (var y2 = function(e3, t3, r3) {
      return function(n3) {
        return new O2(e3, t3, e3).update(n3)[r3]();
      };
    }, g2 = function(e3, t3, r3) {
      return function(n3, i3) {
        return new O2(e3, t3, i3).update(n3)[r3]();
      };
    }, m2 = function(e3, t3, r3) {
      return function(t4, n3, i3, o3) {
        return x2["cshake" + e3].update(t4, n3, i3, o3)[r3]();
      };
    }, w2 = function(e3, t3, r3) {
      return function(t4, n3, i3, o3) {
        return x2["kmac" + e3].update(t4, n3, i3, o3)[r3]();
      };
    }, b2 = function(e3, t3, r3, n3) {
      for (var i3 = 0; i3 < d2.length; ++i3) {
        var o3 = d2[i3];
        e3[o3] = t3(r3, n3, o3);
      }
      return e3;
    }, v2 = function(e3, t3) {
      var r3 = y2(e3, t3, "hex");
      return r3.create = function() {
        return new O2(e3, t3, e3);
      }, r3.update = function(e4) {
        return r3.create().update(e4);
      }, b2(r3, y2, e3, t3);
    }, E2 = [{ name: "keccak", padding: [1, 256, 65536, 16777216], bits: c2, createMethod: v2 }, { name: "sha3", padding: [6, 1536, 393216, 100663296], bits: c2, createMethod: v2 }, { name: "shake", padding: [31, 7936, 2031616, 520093696], bits: l2, createMethod: function(e3, t3) {
      var r3 = g2(e3, t3, "hex");
      return r3.create = function(r4) {
        return new O2(e3, t3, r4);
      }, r3.update = function(e4, t4) {
        return r3.create(t4).update(e4);
      }, b2(r3, g2, e3, t3);
    } }, { name: "cshake", padding: u2, bits: l2, createMethod: function(e3, t3) {
      var r3 = p2[e3], n3 = m2(e3, 0, "hex");
      return n3.create = function(n4, i3, o3) {
        return i3 || o3 ? new O2(e3, t3, n4).bytepad([i3, o3], r3) : x2["shake" + e3].create(n4);
      }, n3.update = function(e4, t4, r4, i3) {
        return n3.create(t4, r4, i3).update(e4);
      }, b2(n3, m2, e3, t3);
    } }, { name: "kmac", padding: u2, bits: l2, createMethod: function(e3, t3) {
      var r3 = p2[e3], n3 = w2(e3, 0, "hex");
      return n3.create = function(n4, i3, o3) {
        return new U2(e3, t3, i3).bytepad(["KMAC", o3], r3).bytepad([n4], r3);
      }, n3.update = function(e4, t4, r4, i3) {
        return n3.create(e4, r4, i3).update(t4);
      }, b2(n3, w2, e3, t3);
    } }], x2 = {}, B2 = [], A2 = 0; A2 < E2.length; ++A2)
      for (var _2 = E2[A2], T2 = _2.bits, S2 = 0; S2 < T2.length; ++S2) {
        var N2 = _2.name + "_" + T2[S2];
        if (B2.push(N2), x2[N2] = _2.createMethod(T2[S2], _2.padding), "sha3" !== _2.name) {
          var I2 = _2.name + T2[S2];
          B2.push(I2), x2[I2] = x2[N2];
        }
      }
    function O2(e3, t3, r3) {
      this.blocks = [], this.s = [], this.padding = t3, this.outputBits = r3, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (e3 << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = r3 >> 5, this.extraBytes = (31 & r3) >> 3;
      for (var n3 = 0; n3 < 50; ++n3)
        this.s[n3] = 0;
    }
    function U2(e3, t3, r3) {
      O2.call(this, e3, t3, r3);
    }
    O2.prototype.update = function(e3) {
      if (this.finalized)
        throw new Error("finalize already called");
      var r3, n3 = typeof e3;
      if ("string" !== n3) {
        if ("object" !== n3)
          throw new Error(t2);
        if (null === e3)
          throw new Error(t2);
        if (s2 && e3.constructor === ArrayBuffer)
          e3 = new Uint8Array(e3);
        else if (!(Array.isArray(e3) || s2 && ArrayBuffer.isView(e3)))
          throw new Error(t2);
        r3 = true;
      }
      for (var i3, o3, a3 = this.blocks, u3 = this.byteCount, f3 = e3.length, c3 = this.blockCount, l3 = 0, d3 = this.s; l3 < f3; ) {
        if (this.reset)
          for (this.reset = false, a3[0] = this.block, i3 = 1; i3 < c3 + 1; ++i3)
            a3[i3] = 0;
        if (r3)
          for (i3 = this.start; l3 < f3 && i3 < u3; ++l3)
            a3[i3 >> 2] |= e3[l3] << h2[3 & i3++];
        else
          for (i3 = this.start; l3 < f3 && i3 < u3; ++l3)
            (o3 = e3.charCodeAt(l3)) < 128 ? a3[i3 >> 2] |= o3 << h2[3 & i3++] : o3 < 2048 ? (a3[i3 >> 2] |= (192 | o3 >> 6) << h2[3 & i3++], a3[i3 >> 2] |= (128 | 63 & o3) << h2[3 & i3++]) : o3 < 55296 || o3 >= 57344 ? (a3[i3 >> 2] |= (224 | o3 >> 12) << h2[3 & i3++], a3[i3 >> 2] |= (128 | o3 >> 6 & 63) << h2[3 & i3++], a3[i3 >> 2] |= (128 | 63 & o3) << h2[3 & i3++]) : (o3 = 65536 + ((1023 & o3) << 10 | 1023 & e3.charCodeAt(++l3)), a3[i3 >> 2] |= (240 | o3 >> 18) << h2[3 & i3++], a3[i3 >> 2] |= (128 | o3 >> 12 & 63) << h2[3 & i3++], a3[i3 >> 2] |= (128 | o3 >> 6 & 63) << h2[3 & i3++], a3[i3 >> 2] |= (128 | 63 & o3) << h2[3 & i3++]);
        if (this.lastByteIndex = i3, i3 >= u3) {
          for (this.start = i3 - u3, this.block = a3[c3], i3 = 0; i3 < c3; ++i3)
            d3[i3] ^= a3[i3];
          L2(d3), this.reset = true;
        } else
          this.start = i3;
      }
      return this;
    }, O2.prototype.encode = function(e3, t3) {
      var r3 = 255 & e3, n3 = 1, i3 = [r3];
      for (r3 = 255 & (e3 >>= 8); r3 > 0; )
        i3.unshift(r3), r3 = 255 & (e3 >>= 8), ++n3;
      return t3 ? i3.push(n3) : i3.unshift(n3), this.update(i3), i3.length;
    }, O2.prototype.encodeString = function(e3) {
      var r3, n3 = typeof e3;
      if ("string" !== n3) {
        if ("object" !== n3)
          throw new Error(t2);
        if (null === e3)
          throw new Error(t2);
        if (s2 && e3.constructor === ArrayBuffer)
          e3 = new Uint8Array(e3);
        else if (!(Array.isArray(e3) || s2 && ArrayBuffer.isView(e3)))
          throw new Error(t2);
        r3 = true;
      }
      var i3 = 0;
      if (r3)
        i3 = e3.length;
      else
        for (var o3 = 0; o3 < e3.length; ++o3) {
          var a3 = e3.charCodeAt(o3);
          a3 < 128 ? i3 += 1 : a3 < 2048 ? i3 += 2 : a3 < 55296 || a3 >= 57344 ? i3 += 3 : (a3 = 65536 + ((1023 & a3) << 10 | 1023 & e3.charCodeAt(++o3)), i3 += 4);
        }
      return i3 += this.encode(8 * i3), this.update(e3), i3;
    }, O2.prototype.bytepad = function(e3, t3) {
      for (var r3 = this.encode(t3), n3 = 0; n3 < e3.length; ++n3)
        r3 += this.encodeString(e3[n3]);
      var i3 = [];
      return i3.length = t3 - r3 % t3, this.update(i3), this;
    }, O2.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var e3 = this.blocks, t3 = this.lastByteIndex, r3 = this.blockCount, n3 = this.s;
        if (e3[t3 >> 2] |= this.padding[3 & t3], this.lastByteIndex === this.byteCount)
          for (e3[0] = e3[r3], t3 = 1; t3 < r3 + 1; ++t3)
            e3[t3] = 0;
        for (e3[r3 - 1] |= 2147483648, t3 = 0; t3 < r3; ++t3)
          n3[t3] ^= e3[t3];
        L2(n3);
      }
    }, O2.prototype.toString = O2.prototype.hex = function() {
      this.finalize();
      for (var e3, t3 = this.blockCount, r3 = this.s, n3 = this.outputBlocks, i3 = this.extraBytes, o3 = 0, s3 = 0, u3 = ""; s3 < n3; ) {
        for (o3 = 0; o3 < t3 && s3 < n3; ++o3, ++s3)
          u3 += a2[(e3 = r3[o3]) >> 4 & 15] + a2[15 & e3] + a2[e3 >> 12 & 15] + a2[e3 >> 8 & 15] + a2[e3 >> 20 & 15] + a2[e3 >> 16 & 15] + a2[e3 >> 28 & 15] + a2[e3 >> 24 & 15];
        s3 % t3 == 0 && (L2(r3), o3 = 0);
      }
      return i3 && (u3 += a2[(e3 = r3[o3]) >> 4 & 15] + a2[15 & e3], i3 > 1 && (u3 += a2[e3 >> 12 & 15] + a2[e3 >> 8 & 15]), i3 > 2 && (u3 += a2[e3 >> 20 & 15] + a2[e3 >> 16 & 15])), u3;
    }, O2.prototype.arrayBuffer = function() {
      this.finalize();
      var e3, t3 = this.blockCount, r3 = this.s, n3 = this.outputBlocks, i3 = this.extraBytes, o3 = 0, s3 = 0, a3 = this.outputBits >> 3;
      e3 = i3 ? new ArrayBuffer(n3 + 1 << 2) : new ArrayBuffer(a3);
      for (var u3 = new Uint32Array(e3); s3 < n3; ) {
        for (o3 = 0; o3 < t3 && s3 < n3; ++o3, ++s3)
          u3[s3] = r3[o3];
        s3 % t3 == 0 && L2(r3);
      }
      return i3 && (u3[o3] = r3[o3], e3 = e3.slice(0, a3)), e3;
    }, O2.prototype.buffer = O2.prototype.arrayBuffer, O2.prototype.digest = O2.prototype.array = function() {
      this.finalize();
      for (var e3, t3, r3 = this.blockCount, n3 = this.s, i3 = this.outputBlocks, o3 = this.extraBytes, s3 = 0, a3 = 0, u3 = []; a3 < i3; ) {
        for (s3 = 0; s3 < r3 && a3 < i3; ++s3, ++a3)
          u3[e3 = a3 << 2] = 255 & (t3 = n3[s3]), u3[e3 + 1] = t3 >> 8 & 255, u3[e3 + 2] = t3 >> 16 & 255, u3[e3 + 3] = t3 >> 24 & 255;
        a3 % r3 == 0 && L2(n3);
      }
      return o3 && (u3[e3 = a3 << 2] = 255 & (t3 = n3[s3]), o3 > 1 && (u3[e3 + 1] = t3 >> 8 & 255), o3 > 2 && (u3[e3 + 2] = t3 >> 16 & 255)), u3;
    }, (U2.prototype = new O2()).finalize = function() {
      return this.encode(this.outputBits, true), O2.prototype.finalize.call(this);
    };
    var L2 = function(e3) {
      var t3, r3, n3, i3, o3, s3, a3, u3, h3, c3, l3, d3, p3, y3, g3, m3, w3, b3, v3, E3, x3, B3, A3, _3, T3, S3, N3, I3, O3, U3, L3, k2, M2, C2, P2, R2, D2, z2, $2, V2, j2, F2, H2, K2, G2, q2, J2, W2, Z2, Y2, X2, Q2, ee2, te2, re2, ne2, ie2, oe2, se2, ae2, ue2, he2, fe2;
      for (n3 = 0; n3 < 48; n3 += 2)
        i3 = e3[0] ^ e3[10] ^ e3[20] ^ e3[30] ^ e3[40], o3 = e3[1] ^ e3[11] ^ e3[21] ^ e3[31] ^ e3[41], u3 = e3[4] ^ e3[14] ^ e3[24] ^ e3[34] ^ e3[44], h3 = e3[5] ^ e3[15] ^ e3[25] ^ e3[35] ^ e3[45], c3 = e3[6] ^ e3[16] ^ e3[26] ^ e3[36] ^ e3[46], l3 = e3[7] ^ e3[17] ^ e3[27] ^ e3[37] ^ e3[47], r3 = (p3 = e3[9] ^ e3[19] ^ e3[29] ^ e3[39] ^ e3[49]) ^ ((a3 = e3[3] ^ e3[13] ^ e3[23] ^ e3[33] ^ e3[43]) << 1 | (s3 = e3[2] ^ e3[12] ^ e3[22] ^ e3[32] ^ e3[42]) >>> 31), e3[0] ^= t3 = (d3 = e3[8] ^ e3[18] ^ e3[28] ^ e3[38] ^ e3[48]) ^ (s3 << 1 | a3 >>> 31), e3[1] ^= r3, e3[10] ^= t3, e3[11] ^= r3, e3[20] ^= t3, e3[21] ^= r3, e3[30] ^= t3, e3[31] ^= r3, e3[40] ^= t3, e3[41] ^= r3, r3 = o3 ^ (h3 << 1 | u3 >>> 31), e3[2] ^= t3 = i3 ^ (u3 << 1 | h3 >>> 31), e3[3] ^= r3, e3[12] ^= t3, e3[13] ^= r3, e3[22] ^= t3, e3[23] ^= r3, e3[32] ^= t3, e3[33] ^= r3, e3[42] ^= t3, e3[43] ^= r3, r3 = a3 ^ (l3 << 1 | c3 >>> 31), e3[4] ^= t3 = s3 ^ (c3 << 1 | l3 >>> 31), e3[5] ^= r3, e3[14] ^= t3, e3[15] ^= r3, e3[24] ^= t3, e3[25] ^= r3, e3[34] ^= t3, e3[35] ^= r3, e3[44] ^= t3, e3[45] ^= r3, r3 = h3 ^ (p3 << 1 | d3 >>> 31), e3[6] ^= t3 = u3 ^ (d3 << 1 | p3 >>> 31), e3[7] ^= r3, e3[16] ^= t3, e3[17] ^= r3, e3[26] ^= t3, e3[27] ^= r3, e3[36] ^= t3, e3[37] ^= r3, e3[46] ^= t3, e3[47] ^= r3, r3 = l3 ^ (o3 << 1 | i3 >>> 31), e3[8] ^= t3 = c3 ^ (i3 << 1 | o3 >>> 31), e3[9] ^= r3, e3[18] ^= t3, e3[19] ^= r3, e3[28] ^= t3, e3[29] ^= r3, e3[38] ^= t3, e3[39] ^= r3, e3[48] ^= t3, e3[49] ^= r3, g3 = e3[1], q2 = e3[11] << 4 | e3[10] >>> 28, J2 = e3[10] << 4 | e3[11] >>> 28, I3 = e3[20] << 3 | e3[21] >>> 29, O3 = e3[21] << 3 | e3[20] >>> 29, ae2 = e3[31] << 9 | e3[30] >>> 23, ue2 = e3[30] << 9 | e3[31] >>> 23, F2 = e3[40] << 18 | e3[41] >>> 14, H2 = e3[41] << 18 | e3[40] >>> 14, C2 = e3[2] << 1 | e3[3] >>> 31, P2 = e3[3] << 1 | e3[2] >>> 31, w3 = e3[12] << 12 | e3[13] >>> 20, W2 = e3[22] << 10 | e3[23] >>> 22, Z2 = e3[23] << 10 | e3[22] >>> 22, U3 = e3[33] << 13 | e3[32] >>> 19, L3 = e3[32] << 13 | e3[33] >>> 19, he2 = e3[42] << 2 | e3[43] >>> 30, fe2 = e3[43] << 2 | e3[42] >>> 30, te2 = e3[5] << 30 | e3[4] >>> 2, re2 = e3[4] << 30 | e3[5] >>> 2, R2 = e3[14] << 6 | e3[15] >>> 26, D2 = e3[15] << 6 | e3[14] >>> 26, v3 = e3[24] << 11 | e3[25] >>> 21, Y2 = e3[34] << 15 | e3[35] >>> 17, X2 = e3[35] << 15 | e3[34] >>> 17, k2 = e3[45] << 29 | e3[44] >>> 3, M2 = e3[44] << 29 | e3[45] >>> 3, _3 = e3[6] << 28 | e3[7] >>> 4, T3 = e3[7] << 28 | e3[6] >>> 4, ne2 = e3[17] << 23 | e3[16] >>> 9, ie2 = e3[16] << 23 | e3[17] >>> 9, z2 = e3[26] << 25 | e3[27] >>> 7, $2 = e3[27] << 25 | e3[26] >>> 7, E3 = e3[36] << 21 | e3[37] >>> 11, x3 = e3[37] << 21 | e3[36] >>> 11, Q2 = e3[47] << 24 | e3[46] >>> 8, ee2 = e3[46] << 24 | e3[47] >>> 8, K2 = e3[8] << 27 | e3[9] >>> 5, G2 = e3[9] << 27 | e3[8] >>> 5, S3 = e3[18] << 20 | e3[19] >>> 12, N3 = e3[19] << 20 | e3[18] >>> 12, oe2 = e3[29] << 7 | e3[28] >>> 25, se2 = e3[28] << 7 | e3[29] >>> 25, V2 = e3[38] << 8 | e3[39] >>> 24, j2 = e3[39] << 8 | e3[38] >>> 24, B3 = e3[48] << 14 | e3[49] >>> 18, A3 = e3[49] << 14 | e3[48] >>> 18, e3[0] = (y3 = e3[0]) ^ ~(m3 = e3[13] << 12 | e3[12] >>> 20) & (b3 = e3[25] << 11 | e3[24] >>> 21), e3[1] = g3 ^ ~w3 & v3, e3[10] = _3 ^ ~S3 & I3, e3[11] = T3 ^ ~N3 & O3, e3[20] = C2 ^ ~R2 & z2, e3[21] = P2 ^ ~D2 & $2, e3[30] = K2 ^ ~q2 & W2, e3[31] = G2 ^ ~J2 & Z2, e3[40] = te2 ^ ~ne2 & oe2, e3[41] = re2 ^ ~ie2 & se2, e3[2] = m3 ^ ~b3 & E3, e3[3] = w3 ^ ~v3 & x3, e3[12] = S3 ^ ~I3 & U3, e3[13] = N3 ^ ~O3 & L3, e3[22] = R2 ^ ~z2 & V2, e3[23] = D2 ^ ~$2 & j2, e3[32] = q2 ^ ~W2 & Y2, e3[33] = J2 ^ ~Z2 & X2, e3[42] = ne2 ^ ~oe2 & ae2, e3[43] = ie2 ^ ~se2 & ue2, e3[4] = b3 ^ ~E3 & B3, e3[5] = v3 ^ ~x3 & A3, e3[14] = I3 ^ ~U3 & k2, e3[15] = O3 ^ ~L3 & M2, e3[24] = z2 ^ ~V2 & F2, e3[25] = $2 ^ ~j2 & H2, e3[34] = W2 ^ ~Y2 & Q2, e3[35] = Z2 ^ ~X2 & ee2, e3[44] = oe2 ^ ~ae2 & he2, e3[45] = se2 ^ ~ue2 & fe2, e3[6] = E3 ^ ~B3 & y3, e3[7] = x3 ^ ~A3 & g3, e3[16] = U3 ^ ~k2 & _3, e3[17] = L3 ^ ~M2 & T3, e3[26] = V2 ^ ~F2 & C2, e3[27] = j2 ^ ~H2 & P2, e3[36] = Y2 ^ ~Q2 & K2, e3[37] = X2 ^ ~ee2 & G2, e3[46] = ae2 ^ ~he2 & te2, e3[47] = ue2 ^ ~fe2 & re2, e3[8] = B3 ^ ~y3 & m3, e3[9] = A3 ^ ~g3 & w3, e3[18] = k2 ^ ~_3 & S3, e3[19] = M2 ^ ~T3 & N3, e3[28] = F2 ^ ~C2 & R2, e3[29] = H2 ^ ~P2 & D2, e3[38] = Q2 ^ ~K2 & q2, e3[39] = ee2 ^ ~G2 & J2, e3[48] = he2 ^ ~te2 & ne2, e3[49] = fe2 ^ ~re2 & ie2, e3[0] ^= f2[n3], e3[1] ^= f2[n3 + 1];
    };
    if (o2)
      e2.exports = x2;
    else
      for (A2 = 0; A2 < B2.length; ++A2)
        n2[B2[A2]] = x2[B2[A2]];
  }();
});
function Ee(e2) {
  if (!Number.isSafeInteger(e2) || e2 < 0)
    throw new Error(`Wrong positive integer: ${e2}`);
}
function xe(e2, ...t2) {
  if (!(e2 instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t2.length > 0 && !t2.includes(e2.length))
    throw new TypeError(`Expected Uint8Array of length ${t2}, not of length=${e2.length}`);
}
var Be = { number: Ee, bool: function(e2) {
  if ("boolean" != typeof e2)
    throw new Error(`Expected boolean, not ${e2}`);
}, bytes: xe, hash: function(e2) {
  if ("function" != typeof e2 || "function" != typeof e2.create)
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ee(e2.outputLen), Ee(e2.blockLen);
}, exists: function(e2, t2 = true) {
  if (e2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t2 && e2.finished)
    throw new Error("Hash#digest() has already been called");
}, output: function(e2, t2) {
  xe(e2);
  const r2 = t2.outputLen;
  if (e2.length < r2)
    throw new Error(`digestInto() expects output buffer of length at least ${r2}`);
} };
var Ae = (e2) => new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
var _e = (e2, t2) => e2 << 32 - t2 | e2 >>> t2;
if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0])
  throw new Error("Non little-endian hardware is not supported");
var Te = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function Se(e2) {
  if ("string" != typeof e2)
    throw new TypeError("utf8ToBytes expected string, got " + typeof e2);
  return new TextEncoder().encode(e2);
}
function Ne(e2) {
  if ("string" == typeof e2 && (e2 = Se(e2)), !(e2 instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e2})`);
  return e2;
}
function Ie(...e2) {
  if (!e2.every((e3) => e3 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (1 === e2.length)
    return e2[0];
  const t2 = e2.reduce((e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(t2);
  for (let t3 = 0, n2 = 0; t3 < e2.length; t3++) {
    const i2 = e2[t3];
    r2.set(i2, n2), n2 += i2.length;
  }
  return r2;
}
var Oe = class {
  clone() {
    return this._cloneInto();
  }
};
function Ue(e2) {
  const t2 = (t3) => e2().update(Ne(t3)).digest(), r2 = e2();
  return t2.outputLen = r2.outputLen, t2.blockLen = r2.blockLen, t2.create = () => e2(), t2;
}
var Le = class extends Oe {
  constructor(e2, t2, r2, n2) {
    super(), this.blockLen = e2, this.outputLen = t2, this.padOffset = r2, this.isLE = n2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e2), this.view = Ae(this.buffer);
  }
  update(e2) {
    Be.exists(this);
    const { view: t2, buffer: r2, blockLen: n2 } = this, i2 = (e2 = Ne(e2)).length;
    for (let o2 = 0; o2 < i2; ) {
      const s2 = Math.min(n2 - this.pos, i2 - o2);
      if (s2 !== n2)
        r2.set(e2.subarray(o2, o2 + s2), this.pos), this.pos += s2, o2 += s2, this.pos === n2 && (this.process(t2, 0), this.pos = 0);
      else {
        const t3 = Ae(e2);
        for (; n2 <= i2 - o2; o2 += n2)
          this.process(t3, o2);
      }
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    Be.exists(this), Be.output(e2, this), this.finished = true;
    const { buffer: t2, view: r2, blockLen: n2, isLE: i2 } = this;
    let { pos: o2 } = this;
    t2[o2++] = 128, this.buffer.subarray(o2).fill(0), this.padOffset > n2 - o2 && (this.process(r2, 0), o2 = 0);
    for (let e3 = o2; e3 < n2; e3++)
      t2[e3] = 0;
    !function(e3, t3, r3, n3) {
      if ("function" == typeof e3.setBigUint64)
        return e3.setBigUint64(t3, r3, n3);
      const i3 = BigInt(32), o3 = BigInt(4294967295), s3 = Number(r3 >> i3 & o3), a3 = Number(r3 & o3), u3 = n3 ? 0 : 4;
      e3.setUint32(t3 + (n3 ? 4 : 0), s3, n3), e3.setUint32(t3 + u3, a3, n3);
    }(r2, n2 - 8, BigInt(8 * this.length), i2), this.process(r2, 0);
    const s2 = Ae(e2), a2 = this.outputLen;
    if (a2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u2 = a2 / 4, h2 = this.get();
    if (u2 > h2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let e3 = 0; e3 < u2; e3++)
      s2.setUint32(4 * e3, h2[e3], i2);
  }
  digest() {
    const { buffer: e2, outputLen: t2 } = this;
    this.digestInto(e2);
    const r2 = e2.slice(0, t2);
    return this.destroy(), r2;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: t2, buffer: r2, length: n2, finished: i2, destroyed: o2, pos: s2 } = this;
    return e2.length = n2, e2.pos = s2, e2.finished = i2, e2.destroyed = o2, n2 % t2 && e2.buffer.set(r2), e2;
  }
};
var ke = BigInt(2 ** 32 - 1);
var Me = BigInt(32);
function Ce(e2, t2 = false) {
  return t2 ? { h: Number(e2 & ke), l: Number(e2 >> Me & ke) } : { h: 0 | Number(e2 >> Me & ke), l: 0 | Number(e2 & ke) };
}
var Pe = (e2, t2, r2) => e2 >>> r2;
var Re = (e2, t2, r2) => e2 << 32 - r2 | t2 >>> r2;
var De = (e2, t2, r2) => e2 >>> r2 | t2 << 32 - r2;
var ze = (e2, t2, r2) => e2 << 32 - r2 | t2 >>> r2;
var $e = (e2, t2, r2) => e2 << 64 - r2 | t2 >>> r2 - 32;
var Ve = (e2, t2, r2) => e2 >>> r2 - 32 | t2 << 64 - r2;
var je = function(e2, t2, r2, n2) {
  const i2 = (t2 >>> 0) + (n2 >>> 0);
  return { h: e2 + r2 + (i2 / 2 ** 32 | 0) | 0, l: 0 | i2 };
};
var Fe = (e2, t2, r2) => (e2 >>> 0) + (t2 >>> 0) + (r2 >>> 0);
var He = (e2, t2, r2, n2) => t2 + r2 + n2 + (e2 / 2 ** 32 | 0) | 0;
var Ke = (e2, t2, r2, n2) => (e2 >>> 0) + (t2 >>> 0) + (r2 >>> 0) + (n2 >>> 0);
var Ge = (e2, t2, r2, n2, i2) => t2 + r2 + n2 + i2 + (e2 / 2 ** 32 | 0) | 0;
var qe = (e2, t2, r2, n2, i2, o2) => t2 + r2 + n2 + i2 + o2 + (e2 / 2 ** 32 | 0) | 0;
var Je = (e2, t2, r2, n2, i2) => (e2 >>> 0) + (t2 >>> 0) + (r2 >>> 0) + (n2 >>> 0) + (i2 >>> 0);
var [We, Ze] = function(e2, t2 = false) {
  let r2 = new Uint32Array(e2.length), n2 = new Uint32Array(e2.length);
  for (let i2 = 0; i2 < e2.length; i2++) {
    const { h: o2, l: s2 } = Ce(e2[i2], t2);
    [r2[i2], n2[i2]] = [o2, s2];
  }
  return [r2, n2];
}(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e2) => BigInt(e2)));
var Ye = new Uint32Array(80);
var Xe = new Uint32Array(80);
var Qe = class extends Le {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e2, Al: t2, Bh: r2, Bl: n2, Ch: i2, Cl: o2, Dh: s2, Dl: a2, Eh: u2, El: h2, Fh: f2, Fl: c2, Gh: l2, Gl: d2, Hh: p2, Hl: y2 } = this;
    return [e2, t2, r2, n2, i2, o2, s2, a2, u2, h2, f2, c2, l2, d2, p2, y2];
  }
  set(e2, t2, r2, n2, i2, o2, s2, a2, u2, h2, f2, c2, l2, d2, p2, y2) {
    this.Ah = 0 | e2, this.Al = 0 | t2, this.Bh = 0 | r2, this.Bl = 0 | n2, this.Ch = 0 | i2, this.Cl = 0 | o2, this.Dh = 0 | s2, this.Dl = 0 | a2, this.Eh = 0 | u2, this.El = 0 | h2, this.Fh = 0 | f2, this.Fl = 0 | c2, this.Gh = 0 | l2, this.Gl = 0 | d2, this.Hh = 0 | p2, this.Hl = 0 | y2;
  }
  process(e2, t2) {
    for (let r3 = 0; r3 < 16; r3++, t2 += 4)
      Ye[r3] = e2.getUint32(t2), Xe[r3] = e2.getUint32(t2 += 4);
    for (let e3 = 16; e3 < 80; e3++) {
      const t3 = 0 | Ye[e3 - 15], r3 = 0 | Xe[e3 - 15], n3 = De(t3, r3, 1) ^ De(t3, r3, 8) ^ Pe(t3, 0, 7), i3 = ze(t3, r3, 1) ^ ze(t3, r3, 8) ^ Re(t3, r3, 7), o3 = 0 | Ye[e3 - 2], s3 = 0 | Xe[e3 - 2], a3 = De(o3, s3, 19) ^ $e(o3, s3, 61) ^ Pe(o3, 0, 6), u3 = ze(o3, s3, 19) ^ Ve(o3, s3, 61) ^ Re(o3, s3, 6), h3 = Ke(i3, u3, Xe[e3 - 7], Xe[e3 - 16]), f3 = Ge(h3, n3, a3, Ye[e3 - 7], Ye[e3 - 16]);
      Ye[e3] = 0 | f3, Xe[e3] = 0 | h3;
    }
    let { Ah: r2, Al: n2, Bh: i2, Bl: o2, Ch: s2, Cl: a2, Dh: u2, Dl: h2, Eh: f2, El: c2, Fh: l2, Fl: d2, Gh: p2, Gl: y2, Hh: g2, Hl: m2 } = this;
    for (let e3 = 0; e3 < 80; e3++) {
      const t3 = De(f2, c2, 14) ^ De(f2, c2, 18) ^ $e(f2, c2, 41), w2 = ze(f2, c2, 14) ^ ze(f2, c2, 18) ^ Ve(f2, c2, 41), b2 = f2 & l2 ^ ~f2 & p2, v2 = Je(m2, w2, c2 & d2 ^ ~c2 & y2, Ze[e3], Xe[e3]), E2 = qe(v2, g2, t3, b2, We[e3], Ye[e3]), x2 = 0 | v2, B2 = De(r2, n2, 28) ^ $e(r2, n2, 34) ^ $e(r2, n2, 39), A2 = ze(r2, n2, 28) ^ Ve(r2, n2, 34) ^ Ve(r2, n2, 39), _2 = r2 & i2 ^ r2 & s2 ^ i2 & s2, T2 = n2 & o2 ^ n2 & a2 ^ o2 & a2;
      g2 = 0 | p2, m2 = 0 | y2, p2 = 0 | l2, y2 = 0 | d2, l2 = 0 | f2, d2 = 0 | c2, { h: f2, l: c2 } = je(0 | u2, 0 | h2, 0 | E2, 0 | x2), u2 = 0 | s2, h2 = 0 | a2, s2 = 0 | i2, a2 = 0 | o2, i2 = 0 | r2, o2 = 0 | n2;
      const S2 = Fe(x2, A2, T2);
      r2 = He(S2, E2, B2, _2), n2 = 0 | S2;
    }
    ({ h: r2, l: n2 } = je(0 | this.Ah, 0 | this.Al, 0 | r2, 0 | n2)), { h: i2, l: o2 } = je(0 | this.Bh, 0 | this.Bl, 0 | i2, 0 | o2), { h: s2, l: a2 } = je(0 | this.Ch, 0 | this.Cl, 0 | s2, 0 | a2), { h: u2, l: h2 } = je(0 | this.Dh, 0 | this.Dl, 0 | u2, 0 | h2), { h: f2, l: c2 } = je(0 | this.Eh, 0 | this.El, 0 | f2, 0 | c2), { h: l2, l: d2 } = je(0 | this.Fh, 0 | this.Fl, 0 | l2, 0 | d2), { h: p2, l: y2 } = je(0 | this.Gh, 0 | this.Gl, 0 | p2, 0 | y2), { h: g2, l: m2 } = je(0 | this.Hh, 0 | this.Hl, 0 | g2, 0 | m2), this.set(r2, n2, i2, o2, s2, a2, u2, h2, f2, c2, l2, d2, p2, y2, g2, m2);
  }
  roundClean() {
    Ye.fill(0), Xe.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var et = class extends Qe {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
var tt = class extends Qe {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
var rt = class extends Qe {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
var nt = Ue(() => new Qe());
Ue(() => new et()), Ue(() => new tt()), Ue(() => new rt());
var it = class extends Oe {
  constructor(e2, t2) {
    super(), this.finished = false, this.destroyed = false, Be.hash(e2);
    const r2 = Ne(t2);
    if (this.iHash = e2.create(), "function" != typeof this.iHash.update)
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n2 = this.blockLen, i2 = new Uint8Array(n2);
    i2.set(r2.length > n2 ? e2.create().update(r2).digest() : r2);
    for (let e3 = 0; e3 < i2.length; e3++)
      i2[e3] ^= 54;
    this.iHash.update(i2), this.oHash = e2.create();
    for (let e3 = 0; e3 < i2.length; e3++)
      i2[e3] ^= 106;
    this.oHash.update(i2), i2.fill(0);
  }
  update(e2) {
    return Be.exists(this), this.iHash.update(e2), this;
  }
  digestInto(e2) {
    Be.exists(this), Be.bytes(e2, this.outputLen), this.finished = true, this.iHash.digestInto(e2), this.oHash.update(e2), this.oHash.digestInto(e2), this.destroy();
  }
  digest() {
    const e2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e2), e2;
  }
  _cloneInto(e2) {
    e2 || (e2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t2, iHash: r2, finished: n2, destroyed: i2, blockLen: o2, outputLen: s2 } = this;
    return e2.finished = n2, e2.destroyed = i2, e2.blockLen = o2, e2.outputLen = s2, e2.oHash = t2._cloneInto(e2.oHash), e2.iHash = r2._cloneInto(e2.iHash), e2;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ot = (e2, t2, r2) => new it(e2, t2).update(r2).digest();
ot.create = (e2, t2) => new it(e2, t2);
var st = new RegExp("^m(\\/[0-9]+')+$");
var at = (e2) => e2.replace("'", "");
function ut(e2) {
  let t2 = e2.replace("0x", "").match(/.{1,2}/g).map((e3) => parseInt(e3, 16));
  if (null === t2)
    throw new Error(`Unable to parse HEX: ${e2}`);
  return Uint8Array.from(t2);
}
function ht(e2) {
  return e2.reduce((e3, t2) => e3 + t2.toString(16).padStart(2, "0"), "");
}
function ft(e2, t2) {
  for (var r2, n2, i2, o2 = e2.replace(/[^A-Za-z0-9+/]/g, ""), s2 = o2.length, a2 = t2 ? Math.ceil((3 * s2 + 1 >> 2) / t2) * t2 : 3 * s2 + 1 >> 2, u2 = new Uint8Array(a2), h2 = 0, f2 = 0, c2 = 0; c2 < s2; c2++)
    if (n2 = 3 & c2, h2 |= ((i2 = o2.charCodeAt(c2)) > 64 && i2 < 91 ? i2 - 65 : i2 > 96 && i2 < 123 ? i2 - 71 : i2 > 47 && i2 < 58 ? i2 + 4 : 43 === i2 ? 62 : 47 === i2 ? 63 : 0) << 6 * (3 - n2), 3 === n2 || s2 - c2 == 1) {
      for (r2 = 0; r2 < 3 && f2 < a2; r2++, f2++)
        u2[f2] = h2 >>> (16 >>> r2 & 24) & 255;
      h2 = 0;
    }
  return u2;
}
function ct(e2) {
  return e2 < 26 ? e2 + 65 : e2 < 52 ? e2 + 71 : e2 < 62 ? e2 - 4 : 62 === e2 ? 43 : 63 === e2 ? 47 : 65;
}
function lt(e2) {
  for (var t2 = 2, r2 = "", n2 = e2.length, i2 = 0, o2 = 0; o2 < n2; o2++)
    o2 > 0 && 4 * o2 / 3 % 76 == 0 && (r2 += ""), i2 |= e2[o2] << (16 >>> (t2 = o2 % 3) & 24), 2 !== t2 && e2.length - o2 != 1 || (r2 += String.fromCodePoint(ct(i2 >>> 18 & 63), ct(i2 >>> 12 & 63), ct(i2 >>> 6 & 63), ct(63 & i2)), i2 = 0);
  return r2.slice(0, r2.length - 2 + t2) + (2 === t2 ? "" : 1 === t2 ? "=" : "==");
}
var dt = class {
  constructor(e2) {
    if (this.data = void 0, this.data = "string" == typeof e2 ? ft(e2) : e2 instanceof Uint8Array ? e2 : Uint8Array.from(e2), 32 !== this.data.length)
      throw new Error(`Invalid public key input. Expected 32 bytes, got ${this.data.length}`);
  }
  equals(e2) {
    return be(this.toBytes(), e2.toBytes());
  }
  toBase64() {
    return lt(this.toBytes());
  }
  toBytes() {
    return this.data;
  }
  toAddress() {
    let e2 = new Uint8Array(33);
    return e2.set([0]), e2.set(this.toBytes(), 1), "0x" + ve.sha3_256(e2).slice(0, 40);
  }
};
var pt = ye(function(e2, t2) {
  function r2(e3) {
    if (!Number.isSafeInteger(e3) || e3 < 0)
      throw new Error(`Wrong positive integer: ${e3}`);
  }
  function n2(e3) {
    if ("boolean" != typeof e3)
      throw new Error(`Expected boolean, not ${e3}`);
  }
  function i2(e3, ...t3) {
    if (!(e3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (t3.length > 0 && !t3.includes(e3.length))
      throw new TypeError(`Expected Uint8Array of length ${t3}, not of length=${e3.length}`);
  }
  function o2(e3) {
    if ("function" != typeof e3 || "function" != typeof e3.create)
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    r2(e3.outputLen), r2(e3.blockLen);
  }
  function s2(e3, t3 = true) {
    if (e3.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (t3 && e3.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function a2(e3, t3) {
    i2(e3);
    const r3 = t3.outputLen;
    if (e3.length < r3)
      throw new Error(`digestInto() expects output buffer of length at least ${r3}`);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.output = t2.exists = t2.hash = t2.bytes = t2.bool = t2.number = void 0, t2.number = r2, t2.bool = n2, t2.bytes = i2, t2.hash = o2, t2.exists = s2, t2.output = a2, t2.default = { number: r2, bool: n2, bytes: i2, hash: o2, exists: s2, output: a2 };
});
var yt = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.crypto = void 0, t2.crypto = { node: void 0, web: "object" == typeof self && "crypto" in self ? self.crypto : void 0 };
});
var gt = ye(function(e2, t2) {
  if (Object.defineProperty(t2, "__esModule", { value: true }), t2.randomBytes = t2.wrapConstructorWithOpts = t2.wrapConstructor = t2.checkOpts = t2.Hash = t2.concatBytes = t2.toBytes = t2.utf8ToBytes = t2.asyncLoop = t2.nextTick = t2.hexToBytes = t2.bytesToHex = t2.isLE = t2.rotr = t2.createView = t2.u32 = t2.u8 = void 0, t2.u8 = (e3) => new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength), t2.u32 = (e3) => new Uint32Array(e3.buffer, e3.byteOffset, Math.floor(e3.byteLength / 4)), t2.createView = (e3) => new DataView(e3.buffer, e3.byteOffset, e3.byteLength), t2.rotr = (e3, t3) => e3 << 32 - t3 | e3 >>> t3, t2.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t2.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const r2 = Array.from({ length: 256 }, (e3, t3) => t3.toString(16).padStart(2, "0"));
  function n2(e3) {
    if ("string" != typeof e3)
      throw new TypeError("utf8ToBytes expected string, got " + typeof e3);
    return new TextEncoder().encode(e3);
  }
  function i2(e3) {
    if ("string" == typeof e3 && (e3 = n2(e3)), !(e3 instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof e3})`);
    return e3;
  }
  t2.bytesToHex = function(e3) {
    if (!(e3 instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let t3 = "";
    for (let n3 = 0; n3 < e3.length; n3++)
      t3 += r2[e3[n3]];
    return t3;
  }, t2.hexToBytes = function(e3) {
    if ("string" != typeof e3)
      throw new TypeError("hexToBytes: expected string, got " + typeof e3);
    if (e3.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const t3 = new Uint8Array(e3.length / 2);
    for (let r3 = 0; r3 < t3.length; r3++) {
      const n3 = 2 * r3, i3 = e3.slice(n3, n3 + 2), o2 = Number.parseInt(i3, 16);
      if (Number.isNaN(o2) || o2 < 0)
        throw new Error("Invalid byte sequence");
      t3[r3] = o2;
    }
    return t3;
  }, t2.nextTick = async () => {
  }, t2.asyncLoop = async function(e3, r3, n3) {
    let i3 = Date.now();
    for (let o2 = 0; o2 < e3; o2++) {
      n3(o2);
      const e4 = Date.now() - i3;
      e4 >= 0 && e4 < r3 || (await (0, t2.nextTick)(), i3 += e4);
    }
  }, t2.utf8ToBytes = n2, t2.toBytes = i2, t2.concatBytes = function(...e3) {
    if (!e3.every((e4) => e4 instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (1 === e3.length)
      return e3[0];
    const t3 = e3.reduce((e4, t4) => e4 + t4.length, 0), r3 = new Uint8Array(t3);
    for (let t4 = 0, n3 = 0; t4 < e3.length; t4++) {
      const i3 = e3[t4];
      r3.set(i3, n3), n3 += i3.length;
    }
    return r3;
  }, t2.Hash = class {
    clone() {
      return this._cloneInto();
    }
  }, t2.checkOpts = function(e3, t3) {
    if (void 0 !== t3 && ("object" != typeof t3 || (r3 = t3, "[object Object]" !== Object.prototype.toString.call(r3) || r3.constructor !== Object)))
      throw new TypeError("Options should be object or undefined");
    var r3;
    return Object.assign(e3, t3);
  }, t2.wrapConstructor = function(e3) {
    const t3 = (t4) => e3().update(i2(t4)).digest(), r3 = e3();
    return t3.outputLen = r3.outputLen, t3.blockLen = r3.blockLen, t3.create = () => e3(), t3;
  }, t2.wrapConstructorWithOpts = function(e3) {
    const t3 = (t4, r4) => e3(r4).update(i2(t4)).digest(), r3 = e3({});
    return t3.outputLen = r3.outputLen, t3.blockLen = r3.blockLen, t3.create = (t4) => e3(t4), t3;
  }, t2.randomBytes = function(e3 = 32) {
    if (yt.crypto.web)
      return yt.crypto.web.getRandomValues(new Uint8Array(e3));
    if (yt.crypto.node)
      return new Uint8Array(yt.crypto.node.randomBytes(e3).buffer);
    throw new Error("The environment doesn't have randomBytes function");
  };
});
var mt = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.hmac = void 0;
  class r2 extends gt.Hash {
    constructor(e3, t3) {
      super(), this.finished = false, this.destroyed = false, pt.default.hash(e3);
      const r3 = (0, gt.toBytes)(t3);
      if (this.iHash = e3.create(), "function" != typeof this.iHash.update)
        throw new TypeError("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const n2 = this.blockLen, i2 = new Uint8Array(n2);
      i2.set(r3.length > n2 ? e3.create().update(r3).digest() : r3);
      for (let e4 = 0; e4 < i2.length; e4++)
        i2[e4] ^= 54;
      this.iHash.update(i2), this.oHash = e3.create();
      for (let e4 = 0; e4 < i2.length; e4++)
        i2[e4] ^= 106;
      this.oHash.update(i2), i2.fill(0);
    }
    update(e3) {
      return pt.default.exists(this), this.iHash.update(e3), this;
    }
    digestInto(e3) {
      pt.default.exists(this), pt.default.bytes(e3, this.outputLen), this.finished = true, this.iHash.digestInto(e3), this.oHash.update(e3), this.oHash.digestInto(e3), this.destroy();
    }
    digest() {
      const e3 = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(e3), e3;
    }
    _cloneInto(e3) {
      e3 || (e3 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: t3, iHash: r3, finished: n2, destroyed: i2, blockLen: o2, outputLen: s2 } = this;
      return e3.finished = n2, e3.destroyed = i2, e3.blockLen = o2, e3.outputLen = s2, e3.oHash = t3._cloneInto(e3.oHash), e3.iHash = r3._cloneInto(e3.iHash), e3;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  t2.hmac = (e3, t3, n2) => new r2(e3, t3).update(n2).digest(), t2.hmac.create = (e3, t3) => new r2(e3, t3);
});
var wt = ye(function(e2, t2) {
  function r2(e3, t3, r3, n3) {
    pt.default.hash(e3);
    const i2 = (0, gt.checkOpts)({ dkLen: 32, asyncTick: 10 }, n3), { c: o2, dkLen: s2, asyncTick: a2 } = i2;
    if (pt.default.number(o2), pt.default.number(s2), pt.default.number(a2), o2 < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const u2 = (0, gt.toBytes)(t3), h2 = (0, gt.toBytes)(r3), f2 = new Uint8Array(s2), c2 = mt.hmac.create(e3, u2), l2 = c2._cloneInto().update(h2);
    return { c: o2, dkLen: s2, asyncTick: a2, DK: f2, PRF: c2, PRFSalt: l2 };
  }
  function n2(e3, t3, r3, n3, i2) {
    return e3.destroy(), t3.destroy(), n3 && n3.destroy(), i2.fill(0), r3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.pbkdf2Async = t2.pbkdf2 = void 0, t2.pbkdf2 = function(e3, t3, i2, o2) {
    const { c: s2, dkLen: a2, DK: u2, PRF: h2, PRFSalt: f2 } = r2(e3, t3, i2, o2);
    let c2;
    const l2 = new Uint8Array(4), d2 = (0, gt.createView)(l2), p2 = new Uint8Array(h2.outputLen);
    for (let e4 = 1, t4 = 0; t4 < a2; e4++, t4 += h2.outputLen) {
      const r3 = u2.subarray(t4, t4 + h2.outputLen);
      d2.setInt32(0, e4, false), (c2 = f2._cloneInto(c2)).update(l2).digestInto(p2), r3.set(p2.subarray(0, r3.length));
      for (let e5 = 1; e5 < s2; e5++) {
        h2._cloneInto(c2).update(p2).digestInto(p2);
        for (let e6 = 0; e6 < r3.length; e6++)
          r3[e6] ^= p2[e6];
      }
    }
    return n2(h2, f2, u2, c2, p2);
  }, t2.pbkdf2Async = async function(e3, t3, i2, o2) {
    const { c: s2, dkLen: a2, asyncTick: u2, DK: h2, PRF: f2, PRFSalt: c2 } = r2(e3, t3, i2, o2);
    let l2;
    const d2 = new Uint8Array(4), p2 = (0, gt.createView)(d2), y2 = new Uint8Array(f2.outputLen);
    for (let e4 = 1, t4 = 0; t4 < a2; e4++, t4 += f2.outputLen) {
      const r3 = h2.subarray(t4, t4 + f2.outputLen);
      p2.setInt32(0, e4, false), (l2 = c2._cloneInto(l2)).update(d2).digestInto(y2), r3.set(y2.subarray(0, r3.length)), await (0, gt.asyncLoop)(s2 - 1, u2, (e5) => {
        f2._cloneInto(l2).update(y2).digestInto(y2);
        for (let e6 = 0; e6 < r3.length; e6++)
          r3[e6] ^= y2[e6];
      });
    }
    return n2(f2, c2, h2, l2, y2);
  };
});
var bt = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.SHA2 = void 0, t2.SHA2 = class extends gt.Hash {
    constructor(e3, t3, r2, n2) {
      super(), this.blockLen = e3, this.outputLen = t3, this.padOffset = r2, this.isLE = n2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e3), this.view = (0, gt.createView)(this.buffer);
    }
    update(e3) {
      pt.default.exists(this);
      const { view: t3, buffer: r2, blockLen: n2 } = this, i2 = (e3 = (0, gt.toBytes)(e3)).length;
      for (let o2 = 0; o2 < i2; ) {
        const s2 = Math.min(n2 - this.pos, i2 - o2);
        if (s2 !== n2)
          r2.set(e3.subarray(o2, o2 + s2), this.pos), this.pos += s2, o2 += s2, this.pos === n2 && (this.process(t3, 0), this.pos = 0);
        else {
          const t4 = (0, gt.createView)(e3);
          for (; n2 <= i2 - o2; o2 += n2)
            this.process(t4, o2);
        }
      }
      return this.length += e3.length, this.roundClean(), this;
    }
    digestInto(e3) {
      pt.default.exists(this), pt.default.output(e3, this), this.finished = true;
      const { buffer: t3, view: r2, blockLen: n2, isLE: i2 } = this;
      let { pos: o2 } = this;
      t3[o2++] = 128, this.buffer.subarray(o2).fill(0), this.padOffset > n2 - o2 && (this.process(r2, 0), o2 = 0);
      for (let e4 = o2; e4 < n2; e4++)
        t3[e4] = 0;
      !function(e4, t4, r3, n3) {
        if ("function" == typeof e4.setBigUint64)
          return e4.setBigUint64(t4, r3, n3);
        const i3 = BigInt(32), o3 = BigInt(4294967295), s3 = Number(r3 >> i3 & o3), a3 = Number(r3 & o3), u3 = n3 ? 0 : 4;
        e4.setUint32(t4 + (n3 ? 4 : 0), s3, n3), e4.setUint32(t4 + u3, a3, n3);
      }(r2, n2 - 8, BigInt(8 * this.length), i2), this.process(r2, 0);
      const s2 = (0, gt.createView)(e3), a2 = this.outputLen;
      if (a2 % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const u2 = a2 / 4, h2 = this.get();
      if (u2 > h2.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let e4 = 0; e4 < u2; e4++)
        s2.setUint32(4 * e4, h2[e4], i2);
    }
    digest() {
      const { buffer: e3, outputLen: t3 } = this;
      this.digestInto(e3);
      const r2 = e3.slice(0, t3);
      return this.destroy(), r2;
    }
    _cloneInto(e3) {
      e3 || (e3 = new this.constructor()), e3.set(...this.get());
      const { blockLen: t3, buffer: r2, length: n2, finished: i2, destroyed: o2, pos: s2 } = this;
      return e3.length = n2, e3.pos = s2, e3.finished = i2, e3.destroyed = o2, n2 % t3 && e3.buffer.set(r2), e3;
    }
  };
});
var vt = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.sha224 = t2.sha256 = void 0;
  const r2 = (e3, t3, r3) => e3 & t3 ^ e3 & r3 ^ t3 & r3, n2 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), i2 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), o2 = new Uint32Array(64);
  class s2 extends bt.SHA2 {
    constructor() {
      super(64, 32, 8, false), this.A = 0 | i2[0], this.B = 0 | i2[1], this.C = 0 | i2[2], this.D = 0 | i2[3], this.E = 0 | i2[4], this.F = 0 | i2[5], this.G = 0 | i2[6], this.H = 0 | i2[7];
    }
    get() {
      const { A: e3, B: t3, C: r3, D: n3, E: i3, F: o3, G: s3, H: a3 } = this;
      return [e3, t3, r3, n3, i3, o3, s3, a3];
    }
    set(e3, t3, r3, n3, i3, o3, s3, a3) {
      this.A = 0 | e3, this.B = 0 | t3, this.C = 0 | r3, this.D = 0 | n3, this.E = 0 | i3, this.F = 0 | o3, this.G = 0 | s3, this.H = 0 | a3;
    }
    process(e3, t3) {
      for (let r3 = 0; r3 < 16; r3++, t3 += 4)
        o2[r3] = e3.getUint32(t3, false);
      for (let e4 = 16; e4 < 64; e4++) {
        const t4 = o2[e4 - 15], r3 = o2[e4 - 2], n3 = (0, gt.rotr)(t4, 7) ^ (0, gt.rotr)(t4, 18) ^ t4 >>> 3, i4 = (0, gt.rotr)(r3, 17) ^ (0, gt.rotr)(r3, 19) ^ r3 >>> 10;
        o2[e4] = i4 + o2[e4 - 7] + n3 + o2[e4 - 16] | 0;
      }
      let { A: i3, B: s3, C: a3, D: u2, E: h2, F: f2, G: c2, H: l2 } = this;
      for (let e4 = 0; e4 < 64; e4++) {
        const t4 = l2 + ((0, gt.rotr)(h2, 6) ^ (0, gt.rotr)(h2, 11) ^ (0, gt.rotr)(h2, 25)) + ((d2 = h2) & f2 ^ ~d2 & c2) + n2[e4] + o2[e4] | 0, p2 = ((0, gt.rotr)(i3, 2) ^ (0, gt.rotr)(i3, 13) ^ (0, gt.rotr)(i3, 22)) + r2(i3, s3, a3) | 0;
        l2 = c2, c2 = f2, f2 = h2, h2 = u2 + t4 | 0, u2 = a3, a3 = s3, s3 = i3, i3 = t4 + p2 | 0;
      }
      var d2;
      i3 = i3 + this.A | 0, s3 = s3 + this.B | 0, a3 = a3 + this.C | 0, u2 = u2 + this.D | 0, h2 = h2 + this.E | 0, f2 = f2 + this.F | 0, c2 = c2 + this.G | 0, l2 = l2 + this.H | 0, this.set(i3, s3, a3, u2, h2, f2, c2, l2);
    }
    roundClean() {
      o2.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  }
  class a2 extends s2 {
    constructor() {
      super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
  }
  t2.sha256 = (0, gt.wrapConstructor)(() => new s2()), t2.sha224 = (0, gt.wrapConstructor)(() => new a2());
});
var Et = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.add = t2.toBig = t2.split = t2.fromBig = void 0;
  const r2 = BigInt(2 ** 32 - 1), n2 = BigInt(32);
  function i2(e3, t3 = false) {
    return t3 ? { h: Number(e3 & r2), l: Number(e3 >> n2 & r2) } : { h: 0 | Number(e3 >> n2 & r2), l: 0 | Number(e3 & r2) };
  }
  function o2(e3, t3 = false) {
    let r3 = new Uint32Array(e3.length), n3 = new Uint32Array(e3.length);
    for (let o3 = 0; o3 < e3.length; o3++) {
      const { h: s3, l: a2 } = i2(e3[o3], t3);
      [r3[o3], n3[o3]] = [s3, a2];
    }
    return [r3, n3];
  }
  function s2(e3, t3, r3, n3) {
    const i3 = (t3 >>> 0) + (n3 >>> 0);
    return { h: e3 + r3 + (i3 / 2 ** 32 | 0) | 0, l: 0 | i3 };
  }
  t2.fromBig = i2, t2.split = o2, t2.toBig = (e3, t3) => BigInt(e3 >>> 0) << n2 | BigInt(t3 >>> 0), t2.add = s2, t2.default = { fromBig: i2, split: o2, toBig: t2.toBig, shrSH: (e3, t3, r3) => e3 >>> r3, shrSL: (e3, t3, r3) => e3 << 32 - r3 | t3 >>> r3, rotrSH: (e3, t3, r3) => e3 >>> r3 | t3 << 32 - r3, rotrSL: (e3, t3, r3) => e3 << 32 - r3 | t3 >>> r3, rotrBH: (e3, t3, r3) => e3 << 64 - r3 | t3 >>> r3 - 32, rotrBL: (e3, t3, r3) => e3 >>> r3 - 32 | t3 << 64 - r3, rotr32H: (e3, t3) => t3, rotr32L: (e3, t3) => e3, rotlSH: (e3, t3, r3) => e3 << r3 | t3 >>> 32 - r3, rotlSL: (e3, t3, r3) => t3 << r3 | e3 >>> 32 - r3, rotlBH: (e3, t3, r3) => t3 << r3 - 32 | e3 >>> 64 - r3, rotlBL: (e3, t3, r3) => e3 << r3 - 32 | t3 >>> 64 - r3, add: s2, add3L: (e3, t3, r3) => (e3 >>> 0) + (t3 >>> 0) + (r3 >>> 0), add3H: (e3, t3, r3, n3) => t3 + r3 + n3 + (e3 / 2 ** 32 | 0) | 0, add4L: (e3, t3, r3, n3) => (e3 >>> 0) + (t3 >>> 0) + (r3 >>> 0) + (n3 >>> 0), add4H: (e3, t3, r3, n3, i3) => t3 + r3 + n3 + i3 + (e3 / 2 ** 32 | 0) | 0, add5H: (e3, t3, r3, n3, i3, o3) => t3 + r3 + n3 + i3 + o3 + (e3 / 2 ** 32 | 0) | 0, add5L: (e3, t3, r3, n3, i3) => (e3 >>> 0) + (t3 >>> 0) + (r3 >>> 0) + (n3 >>> 0) + (i3 >>> 0) };
});
var xt = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.sha384 = t2.sha512_256 = t2.sha512_224 = t2.sha512 = t2.SHA512 = void 0;
  const [r2, n2] = Et.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e3) => BigInt(e3))), i2 = new Uint32Array(80), o2 = new Uint32Array(80);
  class s2 extends bt.SHA2 {
    constructor() {
      super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    get() {
      const { Ah: e3, Al: t3, Bh: r3, Bl: n3, Ch: i3, Cl: o3, Dh: s3, Dl: a3, Eh: u3, El: h3, Fh: f2, Fl: c2, Gh: l2, Gl: d2, Hh: p2, Hl: y2 } = this;
      return [e3, t3, r3, n3, i3, o3, s3, a3, u3, h3, f2, c2, l2, d2, p2, y2];
    }
    set(e3, t3, r3, n3, i3, o3, s3, a3, u3, h3, f2, c2, l2, d2, p2, y2) {
      this.Ah = 0 | e3, this.Al = 0 | t3, this.Bh = 0 | r3, this.Bl = 0 | n3, this.Ch = 0 | i3, this.Cl = 0 | o3, this.Dh = 0 | s3, this.Dl = 0 | a3, this.Eh = 0 | u3, this.El = 0 | h3, this.Fh = 0 | f2, this.Fl = 0 | c2, this.Gh = 0 | l2, this.Gl = 0 | d2, this.Hh = 0 | p2, this.Hl = 0 | y2;
    }
    process(e3, t3) {
      for (let r3 = 0; r3 < 16; r3++, t3 += 4)
        i2[r3] = e3.getUint32(t3), o2[r3] = e3.getUint32(t3 += 4);
      for (let e4 = 16; e4 < 80; e4++) {
        const t4 = 0 | i2[e4 - 15], r3 = 0 | o2[e4 - 15], n3 = Et.default.rotrSH(t4, r3, 1) ^ Et.default.rotrSH(t4, r3, 8) ^ Et.default.shrSH(t4, r3, 7), s4 = Et.default.rotrSL(t4, r3, 1) ^ Et.default.rotrSL(t4, r3, 8) ^ Et.default.shrSL(t4, r3, 7), a4 = 0 | i2[e4 - 2], u4 = 0 | o2[e4 - 2], h4 = Et.default.rotrSH(a4, u4, 19) ^ Et.default.rotrBH(a4, u4, 61) ^ Et.default.shrSH(a4, u4, 6), f3 = Et.default.rotrSL(a4, u4, 19) ^ Et.default.rotrBL(a4, u4, 61) ^ Et.default.shrSL(a4, u4, 6), c3 = Et.default.add4L(s4, f3, o2[e4 - 7], o2[e4 - 16]), l3 = Et.default.add4H(c3, n3, h4, i2[e4 - 7], i2[e4 - 16]);
        i2[e4] = 0 | l3, o2[e4] = 0 | c3;
      }
      let { Ah: s3, Al: a3, Bh: u3, Bl: h3, Ch: f2, Cl: c2, Dh: l2, Dl: d2, Eh: p2, El: y2, Fh: g2, Fl: m2, Gh: w2, Gl: b2, Hh: v2, Hl: E2 } = this;
      for (let e4 = 0; e4 < 80; e4++) {
        const t4 = Et.default.rotrSH(p2, y2, 14) ^ Et.default.rotrSH(p2, y2, 18) ^ Et.default.rotrBH(p2, y2, 41), x2 = Et.default.rotrSL(p2, y2, 14) ^ Et.default.rotrSL(p2, y2, 18) ^ Et.default.rotrBL(p2, y2, 41), B2 = p2 & g2 ^ ~p2 & w2, A2 = Et.default.add5L(E2, x2, y2 & m2 ^ ~y2 & b2, n2[e4], o2[e4]), _2 = Et.default.add5H(A2, v2, t4, B2, r2[e4], i2[e4]), T2 = 0 | A2, S2 = Et.default.rotrSH(s3, a3, 28) ^ Et.default.rotrBH(s3, a3, 34) ^ Et.default.rotrBH(s3, a3, 39), N2 = Et.default.rotrSL(s3, a3, 28) ^ Et.default.rotrBL(s3, a3, 34) ^ Et.default.rotrBL(s3, a3, 39), I2 = s3 & u3 ^ s3 & f2 ^ u3 & f2, O2 = a3 & h3 ^ a3 & c2 ^ h3 & c2;
        v2 = 0 | w2, E2 = 0 | b2, w2 = 0 | g2, b2 = 0 | m2, g2 = 0 | p2, m2 = 0 | y2, { h: p2, l: y2 } = Et.default.add(0 | l2, 0 | d2, 0 | _2, 0 | T2), l2 = 0 | f2, d2 = 0 | c2, f2 = 0 | u3, c2 = 0 | h3, u3 = 0 | s3, h3 = 0 | a3;
        const U2 = Et.default.add3L(T2, N2, O2);
        s3 = Et.default.add3H(U2, _2, S2, I2), a3 = 0 | U2;
      }
      ({ h: s3, l: a3 } = Et.default.add(0 | this.Ah, 0 | this.Al, 0 | s3, 0 | a3)), { h: u3, l: h3 } = Et.default.add(0 | this.Bh, 0 | this.Bl, 0 | u3, 0 | h3), { h: f2, l: c2 } = Et.default.add(0 | this.Ch, 0 | this.Cl, 0 | f2, 0 | c2), { h: l2, l: d2 } = Et.default.add(0 | this.Dh, 0 | this.Dl, 0 | l2, 0 | d2), { h: p2, l: y2 } = Et.default.add(0 | this.Eh, 0 | this.El, 0 | p2, 0 | y2), { h: g2, l: m2 } = Et.default.add(0 | this.Fh, 0 | this.Fl, 0 | g2, 0 | m2), { h: w2, l: b2 } = Et.default.add(0 | this.Gh, 0 | this.Gl, 0 | w2, 0 | b2), { h: v2, l: E2 } = Et.default.add(0 | this.Hh, 0 | this.Hl, 0 | v2, 0 | E2), this.set(s3, a3, u3, h3, f2, c2, l2, d2, p2, y2, g2, m2, w2, b2, v2, E2);
    }
    roundClean() {
      i2.fill(0), o2.fill(0);
    }
    destroy() {
      this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  t2.SHA512 = s2;
  class a2 extends s2 {
    constructor() {
      super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
    }
  }
  class u2 extends s2 {
    constructor() {
      super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
    }
  }
  class h2 extends s2 {
    constructor() {
      super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
    }
  }
  t2.sha512 = (0, gt.wrapConstructor)(() => new s2()), t2.sha512_224 = (0, gt.wrapConstructor)(() => new a2()), t2.sha512_256 = (0, gt.wrapConstructor)(() => new u2()), t2.sha384 = (0, gt.wrapConstructor)(() => new h2());
});
var Bt = ye(function(e2, t2) {
  function r2(e3) {
    if (!Number.isSafeInteger(e3))
      throw new Error(`Wrong integer: ${e3}`);
  }
  function n2(...e3) {
    const t3 = (e4, t4) => (r4) => e4(t4(r4)), r3 = Array.from(e3).reverse().reduce((e4, r4) => e4 ? t3(e4, r4.encode) : r4.encode, void 0), n3 = e3.reduce((e4, r4) => e4 ? t3(e4, r4.decode) : r4.decode, void 0);
    return { encode: r3, decode: n3 };
  }
  function i2(e3) {
    return { encode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0])
        throw new Error("alphabet.encode input should be an array of numbers");
      return t3.map((t4) => {
        if (r2(t4), t4 < 0 || t4 >= e3.length)
          throw new Error(`Digit index outside alphabet: ${t4} (alphabet: ${e3.length})`);
        return e3[t4];
      });
    }, decode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0])
        throw new Error("alphabet.decode input should be array of strings");
      return t3.map((t4) => {
        if ("string" != typeof t4)
          throw new Error(`alphabet.decode: not string element=${t4}`);
        const r3 = e3.indexOf(t4);
        if (-1 === r3)
          throw new Error(`Unknown letter: "${t4}". Allowed: ${e3}`);
        return r3;
      });
    } };
  }
  function o2(e3 = "") {
    if ("string" != typeof e3)
      throw new Error("join separator should be string");
    return { encode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0])
        throw new Error("join.encode input should be array of strings");
      for (let e4 of t3)
        if ("string" != typeof e4)
          throw new Error(`join.encode: non-string input=${e4}`);
      return t3.join(e3);
    }, decode: (t3) => {
      if ("string" != typeof t3)
        throw new Error("join.decode input should be string");
      return t3.split(e3);
    } };
  }
  function s2(e3, t3 = "=") {
    if (r2(e3), "string" != typeof t3)
      throw new Error("padding chr should be string");
    return { encode(r3) {
      if (!Array.isArray(r3) || r3.length && "string" != typeof r3[0])
        throw new Error("padding.encode input should be array of strings");
      for (let e4 of r3)
        if ("string" != typeof e4)
          throw new Error(`padding.encode: non-string input=${e4}`);
      for (; r3.length * e3 % 8; )
        r3.push(t3);
      return r3;
    }, decode(r3) {
      if (!Array.isArray(r3) || r3.length && "string" != typeof r3[0])
        throw new Error("padding.encode input should be array of strings");
      for (let e4 of r3)
        if ("string" != typeof e4)
          throw new Error(`padding.decode: non-string input=${e4}`);
      let n3 = r3.length;
      if (n3 * e3 % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n3 > 0 && r3[n3 - 1] === t3; n3--)
        if (!((n3 - 1) * e3 % 8))
          throw new Error("Invalid padding: string has too much padding");
      return r3.slice(0, n3);
    } };
  }
  function a2(e3) {
    if ("function" != typeof e3)
      throw new Error("normalize fn should be function");
    return { encode: (e4) => e4, decode: (t3) => e3(t3) };
  }
  function u2(e3, t3, n3) {
    if (t3 < 2)
      throw new Error(`convertRadix: wrong from=${t3}, base cannot be less than 2`);
    if (n3 < 2)
      throw new Error(`convertRadix: wrong to=${n3}, base cannot be less than 2`);
    if (!Array.isArray(e3))
      throw new Error("convertRadix: data should be array");
    if (!e3.length)
      return [];
    let i3 = 0;
    const o3 = [], s3 = Array.from(e3);
    for (s3.forEach((e4) => {
      if (r2(e4), e4 < 0 || e4 >= t3)
        throw new Error(`Wrong integer: ${e4}`);
    }); ; ) {
      let e4 = 0, r3 = true;
      for (let o4 = i3; o4 < s3.length; o4++) {
        const a3 = s3[o4], u3 = t3 * e4 + a3;
        if (!Number.isSafeInteger(u3) || t3 * e4 / t3 !== e4 || u3 - a3 != t3 * e4)
          throw new Error("convertRadix: carry overflow");
        if (e4 = u3 % n3, s3[o4] = Math.floor(u3 / n3), !Number.isSafeInteger(s3[o4]) || s3[o4] * n3 + e4 !== u3)
          throw new Error("convertRadix: carry overflow");
        r3 && (s3[o4] ? r3 = false : i3 = o4);
      }
      if (o3.push(e4), r3)
        break;
    }
    for (let t4 = 0; t4 < e3.length - 1 && 0 === e3[t4]; t4++)
      o3.push(0);
    return o3.reverse();
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.bytes = t2.stringToBytes = t2.str = t2.bytesToString = t2.hex = t2.utf8 = t2.bech32m = t2.bech32 = t2.base58check = t2.base58xmr = t2.base58xrp = t2.base58flickr = t2.base58 = t2.base64url = t2.base64 = t2.base32crockford = t2.base32hex = t2.base32 = t2.base16 = t2.utils = t2.assertNumber = void 0, t2.assertNumber = r2;
  const h2 = (e3, t3) => t3 ? h2(t3, e3 % t3) : e3, f2 = (e3, t3) => e3 + (t3 - h2(e3, t3));
  function c2(e3, t3, n3, i3) {
    if (!Array.isArray(e3))
      throw new Error("convertRadix2: data should be array");
    if (t3 <= 0 || t3 > 32)
      throw new Error(`convertRadix2: wrong from=${t3}`);
    if (n3 <= 0 || n3 > 32)
      throw new Error(`convertRadix2: wrong to=${n3}`);
    if (f2(t3, n3) > 32)
      throw new Error(`convertRadix2: carry overflow from=${t3} to=${n3} carryBits=${f2(t3, n3)}`);
    let o3 = 0, s3 = 0;
    const a3 = 2 ** n3 - 1, u3 = [];
    for (const i4 of e3) {
      if (r2(i4), i4 >= 2 ** t3)
        throw new Error(`convertRadix2: invalid data word=${i4} from=${t3}`);
      if (o3 = o3 << t3 | i4, s3 + t3 > 32)
        throw new Error(`convertRadix2: carry overflow pos=${s3} from=${t3}`);
      for (s3 += t3; s3 >= n3; s3 -= n3)
        u3.push((o3 >> s3 - n3 & a3) >>> 0);
      o3 &= 2 ** s3 - 1;
    }
    if (o3 = o3 << n3 - s3 & a3, !i3 && s3 >= t3)
      throw new Error("Excess padding");
    if (!i3 && o3)
      throw new Error(`Non-zero padding: ${o3}`);
    return i3 && s3 > 0 && u3.push(o3 >>> 0), u3;
  }
  function l2(e3) {
    return r2(e3), { encode: (t3) => {
      if (!(t3 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return u2(Array.from(t3), 256, e3);
    }, decode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0])
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(u2(t3, e3, 256));
    } };
  }
  function d2(e3, t3 = false) {
    if (r2(e3), e3 <= 0 || e3 > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (f2(8, e3) > 32 || f2(e3, 8) > 32)
      throw new Error("radix2: carry overflow");
    return { encode: (r3) => {
      if (!(r3 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return c2(Array.from(r3), 8, e3, !t3);
    }, decode: (r3) => {
      if (!Array.isArray(r3) || r3.length && "number" != typeof r3[0])
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(c2(r3, e3, 8, t3));
    } };
  }
  function p2(e3) {
    if ("function" != typeof e3)
      throw new Error("unsafeWrapper fn should be function");
    return function(...t3) {
      try {
        return e3.apply(null, t3);
      } catch (e4) {
      }
    };
  }
  function y2(e3, t3) {
    if (r2(e3), "function" != typeof t3)
      throw new Error("checksum fn should be function");
    return { encode(r3) {
      if (!(r3 instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n3 = t3(r3).slice(0, e3), i3 = new Uint8Array(r3.length + e3);
      return i3.set(r3), i3.set(n3, r3.length), i3;
    }, decode(r3) {
      if (!(r3 instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n3 = r3.slice(0, -e3), i3 = t3(n3).slice(0, e3), o3 = r3.slice(-e3);
      for (let t4 = 0; t4 < e3; t4++)
        if (i3[t4] !== o3[t4])
          throw new Error("Invalid checksum");
      return n3;
    } };
  }
  t2.utils = { alphabet: i2, chain: n2, checksum: y2, radix: l2, radix2: d2, join: o2, padding: s2 }, t2.base16 = n2(d2(4), i2("0123456789ABCDEF"), o2("")), t2.base32 = n2(d2(5), i2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), s2(5), o2("")), t2.base32hex = n2(d2(5), i2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), s2(5), o2("")), t2.base32crockford = n2(d2(5), i2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), o2(""), a2((e3) => e3.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), t2.base64 = n2(d2(6), i2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), s2(6), o2("")), t2.base64url = n2(d2(6), i2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), s2(6), o2(""));
  const g2 = (e3) => n2(l2(58), i2(e3), o2(""));
  t2.base58 = g2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), t2.base58flickr = g2("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), t2.base58xrp = g2("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const m2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  t2.base58xmr = { encode(e3) {
    let r3 = "";
    for (let n3 = 0; n3 < e3.length; n3 += 8) {
      const i3 = e3.subarray(n3, n3 + 8);
      r3 += t2.base58.encode(i3).padStart(m2[i3.length], "1");
    }
    return r3;
  }, decode(e3) {
    let r3 = [];
    for (let n3 = 0; n3 < e3.length; n3 += 11) {
      const i3 = e3.slice(n3, n3 + 11), o3 = m2.indexOf(i3.length), s3 = t2.base58.decode(i3);
      for (let e4 = 0; e4 < s3.length - o3; e4++)
        if (0 !== s3[e4])
          throw new Error("base58xmr: wrong padding");
      r3 = r3.concat(Array.from(s3.slice(s3.length - o3)));
    }
    return Uint8Array.from(r3);
  } }, t2.base58check = (e3) => n2(y2(4, (t3) => e3(e3(t3))), t2.base58);
  const w2 = n2(i2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), o2("")), b2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function v2(e3) {
    const t3 = e3 >> 25;
    let r3 = (33554431 & e3) << 5;
    for (let e4 = 0; e4 < b2.length; e4++)
      1 == (t3 >> e4 & 1) && (r3 ^= b2[e4]);
    return r3;
  }
  function E2(e3, t3, r3 = 1) {
    const n3 = e3.length;
    let i3 = 1;
    for (let t4 = 0; t4 < n3; t4++) {
      const r4 = e3.charCodeAt(t4);
      if (r4 < 33 || r4 > 126)
        throw new Error(`Invalid prefix (${e3})`);
      i3 = v2(i3) ^ r4 >> 5;
    }
    i3 = v2(i3);
    for (let t4 = 0; t4 < n3; t4++)
      i3 = v2(i3) ^ 31 & e3.charCodeAt(t4);
    for (let e4 of t3)
      i3 = v2(i3) ^ e4;
    for (let e4 = 0; e4 < 6; e4++)
      i3 = v2(i3);
    return i3 ^= r3, w2.encode(c2([i3 % 2 ** 30], 30, 5, false));
  }
  function x2(e3) {
    const t3 = "bech32" === e3 ? 1 : 734539939, r3 = d2(5), n3 = r3.decode, i3 = r3.encode, o3 = p2(n3);
    function s3(e4, r4 = 90) {
      if ("string" != typeof e4)
        throw new Error("bech32.decode input should be string, not " + typeof e4);
      if (e4.length < 8 || false !== r4 && e4.length > r4)
        throw new TypeError(`Wrong string length: ${e4.length} (${e4}). Expected (8..${r4})`);
      const n4 = e4.toLowerCase();
      if (e4 !== n4 && e4 !== e4.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      const i4 = (e4 = n4).lastIndexOf("1");
      if (0 === i4 || -1 === i4)
        throw new Error('Letter "1" must be present between prefix and data only');
      const o4 = e4.slice(0, i4), s4 = e4.slice(i4 + 1);
      if (s4.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const a3 = w2.decode(s4).slice(0, -6), u3 = E2(o4, a3, t3);
      if (!s4.endsWith(u3))
        throw new Error(`Invalid checksum in ${e4}: expected "${u3}"`);
      return { prefix: o4, words: a3 };
    }
    return { encode: function(e4, r4, n4 = 90) {
      if ("string" != typeof e4)
        throw new Error("bech32.encode prefix should be string, not " + typeof e4);
      if (!Array.isArray(r4) || r4.length && "number" != typeof r4[0])
        throw new Error("bech32.encode words should be array of numbers, not " + typeof r4);
      const i4 = e4.length + 7 + r4.length;
      if (false !== n4 && i4 > n4)
        throw new TypeError(`Length ${i4} exceeds limit ${n4}`);
      return `${e4 = e4.toLowerCase()}1${w2.encode(r4)}${E2(e4, r4, t3)}`;
    }, decode: s3, decodeToBytes: function(e4) {
      const { prefix: t4, words: r4 } = s3(e4, false);
      return { prefix: t4, words: r4, bytes: n3(r4) };
    }, decodeUnsafe: p2(s3), fromWords: n3, fromWordsUnsafe: o3, toWords: i3 };
  }
  t2.bech32 = x2("bech32"), t2.bech32m = x2("bech32m"), t2.utf8 = { encode: (e3) => new TextDecoder().decode(e3), decode: (e3) => new TextEncoder().encode(e3) }, t2.hex = n2(d2(4), i2("0123456789abcdef"), o2(""), a2((e3) => {
    if ("string" != typeof e3 || e3.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof e3} with length ${e3.length}`);
    return e3.toLowerCase();
  }));
  const B2 = { utf8: t2.utf8, hex: t2.hex, base16: t2.base16, base32: t2.base32, base64: t2.base64, base64url: t2.base64url, base58: t2.base58, base58xmr: t2.base58xmr }, A2 = `Invalid encoding type. Available types: ${Object.keys(B2).join(", ")}`;
  t2.bytesToString = (e3, t3) => {
    if ("string" != typeof e3 || !B2.hasOwnProperty(e3))
      throw new TypeError(A2);
    if (!(t3 instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return B2[e3].encode(t3);
  }, t2.str = t2.bytesToString, t2.stringToBytes = (e3, t3) => {
    if (!B2.hasOwnProperty(e3))
      throw new TypeError(A2);
    if ("string" != typeof t3)
      throw new TypeError("stringToBytes() expects string");
    return B2[e3].decode(t3);
  }, t2.bytes = t2.stringToBytes;
});
var At = ye(function(e2, t2) {
  function r2(e3) {
    if ("string" != typeof e3)
      throw new TypeError("Invalid mnemonic type: " + typeof e3);
    return e3.normalize("NFKD");
  }
  function n2(e3) {
    const t3 = r2(e3), n3 = t3.split(" ");
    if (![12, 15, 18, 21, 24].includes(n3.length))
      throw new Error("Invalid mnemonic");
    return { nfkd: t3, words: n3 };
  }
  function i2(e3) {
    pt.default.bytes(e3, 16, 20, 24, 28, 32);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.mnemonicToSeedSync = t2.mnemonicToSeed = t2.validateMnemonic = t2.entropyToMnemonic = t2.mnemonicToEntropy = t2.generateMnemonic = void 0, t2.generateMnemonic = function(e3, t3 = 128) {
    if (pt.default.number(t3), t3 % 32 != 0 || t3 > 256)
      throw new TypeError("Invalid entropy");
    return u2((0, gt.randomBytes)(t3 / 8), e3);
  };
  const o2 = (e3) => {
    const t3 = 8 - e3.length / 4;
    return new Uint8Array([(0, vt.sha256)(e3)[0] >> t3 << t3]);
  };
  function s2(e3) {
    if (!Array.isArray(e3) || 2048 !== e3.length || "string" != typeof e3[0])
      throw new Error("Worlist: expected array of 2048 strings");
    return e3.forEach((e4) => {
      if ("string" != typeof e4)
        throw new Error(`Wordlist: non-string element: ${e4}`);
    }), Bt.utils.chain(Bt.utils.checksum(1, o2), Bt.utils.radix2(11, true), Bt.utils.alphabet(e3));
  }
  function a2(e3, t3) {
    const { words: r3 } = n2(e3), o3 = s2(t3).decode(r3);
    return i2(o3), o3;
  }
  function u2(e3, t3) {
    return i2(e3), s2(t3).encode(e3).join(((e4) => "\u3042\u3044\u3053\u304F\u3057\u3093" === e4[0])(t3) ? "\u3000" : " ");
  }
  t2.mnemonicToEntropy = a2, t2.entropyToMnemonic = u2, t2.validateMnemonic = function(e3, t3) {
    try {
      a2(e3, t3);
    } catch (e4) {
      return false;
    }
    return true;
  };
  const h2 = (e3) => r2(`mnemonic${e3}`);
  t2.mnemonicToSeed = function(e3, t3 = "") {
    return (0, wt.pbkdf2Async)(xt.sha512, n2(e3).nfkd, h2(t3), { c: 2048, dkLen: 64 });
  }, t2.mnemonicToSeedSync = function(e3, t3 = "") {
    return (0, wt.pbkdf2)(xt.sha512, n2(e3).nfkd, h2(t3), { c: 2048, dkLen: 64 });
  };
});
function _t(e2) {
  return At.mnemonicToSeedSync(e2, "");
}
var Tt = class {
  constructor(e2) {
    this.keypair = void 0, this.keypair = e2 || we.sign.keyPair();
  }
  static generate() {
    return new Tt(we.sign.keyPair());
  }
  static fromSecretKey(e2) {
    const t2 = e2.length;
    if (64 !== t2) {
      if (32 === t2)
        throw new Error("Wrong secretKey size. Expected 64 bytes, got 32. Similar function exists: fromSeed(seed: Uint8Array)");
      throw new Error(`Wrong secretKey size. Expected 64 bytes, got ${t2}.`);
    }
    const r2 = we.sign.keyPair.fromSecretKey(e2);
    return new Tt(r2);
  }
  getKeyScheme() {
    return "ED25519";
  }
  static fromSeed(e2) {
    const t2 = e2.length;
    if (32 != t2)
      throw new Error(`Wrong seed size. Expected 32 bytes, got ${t2}.`);
    return new Tt(we.sign.keyPair.fromSeed(e2));
  }
  signData(e2) {
    const t2 = we.sign.detached(e2, this.keypair.secretKey);
    var r2 = new Uint8Array(97);
    return r2[0] = 0, r2.set(t2, 1), r2.set(this.keypair.publicKey, 65), r2;
  }
  static deriveKeypair(e2, t2) {
    if (null == t2 && (t2 = "m/44'/784'/0'/0'/0'"), !function(e3) {
      return !!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e3);
    }(t2))
      throw new Error("Invalid derivation path");
    const { key: r2 } = ((e3, t3, r3 = 2147483648) => {
      if (!((e4) => !!st.test(e4) && !e4.split("/").slice(1).map(at).some(isNaN))(e3))
        throw new Error("Invalid derivation path");
      const { key: n3, chainCode: i3 } = ((e4) => {
        const t4 = ot.create(nt, "ed25519 seed").update(ut(e4)).digest();
        return { key: t4.slice(0, 32), chainCode: t4.slice(32) };
      })(t3);
      return e3.split("/").slice(1).map(at).map((e4) => parseInt(e4, 10)).reduce((e4, t4) => (({ key: e5, chainCode: t5 }, r4) => {
        const n4 = new ArrayBuffer(4);
        new DataView(n4).setUint32(0, r4);
        const i4 = new Uint8Array(1 + e5.length + n4.byteLength);
        i4.set(new Uint8Array(1).fill(0)), i4.set(e5, 1), i4.set(new Uint8Array(n4, 0, n4.byteLength), e5.length + 1);
        const o2 = ot.create(nt, t5).update(i4).digest();
        return { key: o2.slice(0, 32), chainCode: o2.slice(32) };
      })(e4, t4 + r3), { key: n3, chainCode: i3 });
    })(t2, function(e3) {
      return ht(_t(e3));
    }(e2)), n2 = ((e3, t3 = true) => {
      const r3 = we.sign.keyPair.fromSeed(e3).secretKey.subarray(32), n3 = new Uint8Array(r3.length + 1);
      return n3.set([0]), n3.set(r3, 1), t3 ? n3 : r3;
    })(r2, false);
    let i2 = new Uint8Array(64);
    return i2.set(r2), i2.set(n2, 32), new Tt({ publicKey: n2, secretKey: i2 });
  }
  getPublicKey() {
    return new dt(this.keypair.publicKey);
  }
  export() {
    return { schema: "ED25519", privateKey: lt(this.keypair.secretKey) };
  }
};
var St = BigInt(0);
var Nt = BigInt(1);
var It = BigInt(2);
var Ot = BigInt(3);
var Ut = BigInt(8);
var Lt = Object.freeze({ a: St, b: BigInt(7), P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), h: Nt, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee") });
function kt(e2) {
  const { a: t2, b: r2 } = Lt, n2 = er(e2 * e2), i2 = er(n2 * e2);
  return er(i2 + t2 * e2 + r2);
}
var Mt = Lt.a === St;
var Ct = class extends Error {
  constructor(e2) {
    super(e2);
  }
};
var Pt = class {
  constructor(e2, t2, r2) {
    this.x = e2, this.y = t2, this.z = r2;
  }
  static fromAffine(e2) {
    if (!(e2 instanceof Dt))
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    return new Pt(e2.x, e2.y, Nt);
  }
  static toAffineBatch(e2) {
    const t2 = function(e3, t3 = Lt.P) {
      const r2 = new Array(e3.length), n2 = e3.reduce((e4, n3, i3) => n3 === St ? e4 : (r2[i3] = e4, er(e4 * n3, t3)), Nt), i2 = rr(n2, t3);
      return e3.reduceRight((e4, n3, i3) => n3 === St ? e4 : (r2[i3] = er(e4 * r2[i3], t3), er(e4 * n3, t3)), i2), r2;
    }(e2.map((e3) => e3.z));
    return e2.map((e3, r2) => e3.toAffine(t2[r2]));
  }
  static normalizeZ(e2) {
    return Pt.toAffineBatch(e2).map(Pt.fromAffine);
  }
  equals(e2) {
    if (!(e2 instanceof Pt))
      throw new TypeError("JacobianPoint expected");
    const { x: t2, y: r2, z: n2 } = this, { x: i2, y: o2, z: s2 } = e2, a2 = er(n2 * n2), u2 = er(s2 * s2), h2 = er(t2 * u2), f2 = er(i2 * a2), c2 = er(er(r2 * s2) * u2), l2 = er(er(o2 * n2) * a2);
    return h2 === f2 && c2 === l2;
  }
  negate() {
    return new Pt(this.x, er(-this.y), this.z);
  }
  double() {
    const { x: e2, y: t2, z: r2 } = this, n2 = er(e2 * e2), i2 = er(t2 * t2), o2 = er(i2 * i2), s2 = e2 + i2, a2 = er(It * (er(s2 * s2) - n2 - o2)), u2 = er(Ot * n2), h2 = er(u2 * u2), f2 = er(h2 - It * a2), c2 = er(u2 * (a2 - f2) - Ut * o2), l2 = er(It * t2 * r2);
    return new Pt(f2, c2, l2);
  }
  add(e2) {
    if (!(e2 instanceof Pt))
      throw new TypeError("JacobianPoint expected");
    const { x: t2, y: r2, z: n2 } = this, { x: i2, y: o2, z: s2 } = e2;
    if (i2 === St || o2 === St)
      return this;
    if (t2 === St || r2 === St)
      return e2;
    const a2 = er(n2 * n2), u2 = er(s2 * s2), h2 = er(t2 * u2), f2 = er(i2 * a2), c2 = er(er(r2 * s2) * u2), l2 = er(er(o2 * n2) * a2), d2 = er(f2 - h2), p2 = er(l2 - c2);
    if (d2 === St)
      return p2 === St ? this.double() : Pt.ZERO;
    const y2 = er(d2 * d2), g2 = er(d2 * y2), m2 = er(h2 * y2), w2 = er(p2 * p2 - g2 - It * m2), b2 = er(p2 * (m2 - w2) - c2 * g2), v2 = er(n2 * s2 * d2);
    return new Pt(w2, b2, v2);
  }
  subtract(e2) {
    return this.add(e2.negate());
  }
  multiplyUnsafe(e2) {
    const t2 = Pt.ZERO;
    if ("bigint" == typeof e2 && e2 === St)
      return t2;
    let r2 = Qt(e2);
    if (r2 === Nt)
      return this;
    if (!Mt) {
      let e3 = t2, n3 = this;
      for (; r2 > St; )
        r2 & Nt && (e3 = e3.add(n3)), n3 = n3.double(), r2 >>= Nt;
      return e3;
    }
    let { k1neg: n2, k1: i2, k2neg: o2, k2: s2 } = or(r2), a2 = t2, u2 = t2, h2 = this;
    for (; i2 > St || s2 > St; )
      i2 & Nt && (a2 = a2.add(h2)), s2 & Nt && (u2 = u2.add(h2)), h2 = h2.double(), i2 >>= Nt, s2 >>= Nt;
    return n2 && (a2 = a2.negate()), o2 && (u2 = u2.negate()), u2 = new Pt(er(u2.x * Lt.beta), u2.y, u2.z), a2.add(u2);
  }
  precomputeWindow(e2) {
    const t2 = Mt ? 128 / e2 + 1 : 256 / e2 + 1, r2 = [];
    let n2 = this, i2 = n2;
    for (let o2 = 0; o2 < t2; o2++) {
      i2 = n2, r2.push(i2);
      for (let t3 = 1; t3 < 2 ** (e2 - 1); t3++)
        i2 = i2.add(n2), r2.push(i2);
      n2 = i2.double();
    }
    return r2;
  }
  wNAF(e2, t2) {
    !t2 && this.equals(Pt.BASE) && (t2 = Dt.BASE);
    const r2 = t2 && t2._WINDOW_SIZE || 1;
    if (256 % r2)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let n2 = t2 && Rt.get(t2);
    n2 || (n2 = this.precomputeWindow(r2), t2 && 1 !== r2 && (n2 = Pt.normalizeZ(n2), Rt.set(t2, n2)));
    let i2 = Pt.ZERO, o2 = Pt.ZERO;
    const s2 = 1 + (Mt ? 128 / r2 : 256 / r2), a2 = 2 ** (r2 - 1), u2 = BigInt(2 ** r2 - 1), h2 = 2 ** r2, f2 = BigInt(r2);
    for (let t3 = 0; t3 < s2; t3++) {
      const r3 = t3 * a2;
      let s3 = Number(e2 & u2);
      if (e2 >>= f2, s3 > a2 && (s3 -= h2, e2 += Nt), 0 === s3) {
        let e3 = n2[r3];
        t3 % 2 && (e3 = e3.negate()), o2 = o2.add(e3);
      } else {
        let e3 = n2[r3 + Math.abs(s3) - 1];
        s3 < 0 && (e3 = e3.negate()), i2 = i2.add(e3);
      }
    }
    return { p: i2, f: o2 };
  }
  multiply(e2, t2) {
    let r2, n2, i2 = Qt(e2);
    if (Mt) {
      const { k1neg: e3, k1: o2, k2neg: s2, k2: a2 } = or(i2);
      let { p: u2, f: h2 } = this.wNAF(o2, t2), { p: f2, f: c2 } = this.wNAF(a2, t2);
      e3 && (u2 = u2.negate()), s2 && (f2 = f2.negate()), f2 = new Pt(er(f2.x * Lt.beta), f2.y, f2.z), r2 = u2.add(f2), n2 = h2.add(c2);
    } else {
      const { p: e3, f: o2 } = this.wNAF(i2, t2);
      r2 = e3, n2 = o2;
    }
    return Pt.normalizeZ([r2, n2])[0];
  }
  toAffine(e2 = rr(this.z)) {
    const { x: t2, y: r2, z: n2 } = this, i2 = e2, o2 = er(i2 * i2), s2 = er(o2 * i2), a2 = er(t2 * o2), u2 = er(r2 * s2);
    if (er(n2 * i2) !== Nt)
      throw new Error("invZ was invalid");
    return new Dt(a2, u2);
  }
};
Pt.BASE = new Pt(Lt.Gx, Lt.Gy, Nt), Pt.ZERO = new Pt(St, Nt, St);
var Rt = /* @__PURE__ */ new WeakMap();
var Dt = class {
  constructor(e2, t2) {
    this.x = e2, this.y = t2;
  }
  _setWindowSize(e2) {
    this._WINDOW_SIZE = e2, Rt.delete(this);
  }
  hasEvenY() {
    return this.y % It === St;
  }
  static fromCompressedHex(e2) {
    const t2 = 32 === e2.length, r2 = Yt(t2 ? e2 : e2.subarray(1));
    if (!fr(r2))
      throw new Error("Point is not on curve");
    let n2 = function(e3) {
      const { P: t3 } = Lt, r3 = BigInt(6), n3 = BigInt(11), i3 = BigInt(22), o3 = BigInt(23), s2 = BigInt(44), a2 = BigInt(88), u2 = e3 * e3 * e3 % t3, h2 = u2 * u2 * e3 % t3, f2 = tr(h2, Ot) * h2 % t3, c2 = tr(f2, Ot) * h2 % t3, l2 = tr(c2, It) * u2 % t3, d2 = tr(l2, n3) * l2 % t3, p2 = tr(d2, i3) * d2 % t3, y2 = tr(p2, s2) * p2 % t3, g2 = tr(y2, a2) * y2 % t3, m2 = tr(g2, s2) * p2 % t3, w2 = tr(m2, Ot) * h2 % t3, b2 = tr(w2, o3) * d2 % t3, v2 = tr(b2, r3) * u2 % t3;
      return tr(v2, It);
    }(kt(r2));
    const i2 = (n2 & Nt) === Nt;
    t2 ? i2 && (n2 = er(-n2)) : 1 == (1 & e2[0]) !== i2 && (n2 = er(-n2));
    const o2 = new Dt(r2, n2);
    return o2.assertValidity(), o2;
  }
  static fromUncompressedHex(e2) {
    const t2 = Yt(e2.subarray(1, 33)), r2 = Yt(e2.subarray(33, 65)), n2 = new Dt(t2, r2);
    return n2.assertValidity(), n2;
  }
  static fromHex(e2) {
    const t2 = Xt(e2), r2 = t2.length, n2 = t2[0];
    if (32 === r2 || 33 === r2 && (2 === n2 || 3 === n2))
      return this.fromCompressedHex(t2);
    if (65 === r2 && 4 === n2)
      return this.fromUncompressedHex(t2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r2}`);
  }
  static fromPrivateKey(e2) {
    return Dt.BASE.multiply(lr(e2));
  }
  static fromSignature(e2, t2, r2) {
    const n2 = function(e3) {
      const { n: t3 } = Lt, r3 = 8 * e3.length - 256;
      let n3 = Yt(e3);
      return r3 > 0 && (n3 >>= BigInt(r3)), n3 >= t3 && (n3 -= t3), n3;
    }(e2 = Xt(e2)), { r: i2, s: o2 } = function(e3) {
      if (e3 instanceof Vt)
        return e3.assertValidity(), e3;
      try {
        return Vt.fromDER(e3);
      } catch (t3) {
        return Vt.fromCompact(e3);
      }
    }(t2);
    if (0 !== r2 && 1 !== r2)
      throw new Error("Cannot recover signature: invalid recovery bit");
    const s2 = Dt.fromHex((1 & r2 ? "03" : "02") + Gt(i2)), { n: a2 } = Lt, u2 = rr(i2, a2), h2 = er(-n2 * u2, a2), f2 = er(o2 * u2, a2), c2 = Dt.BASE.multiplyAndAddUnsafe(s2, h2, f2);
    if (!c2)
      throw new Error("Cannot recover signature: point at infinify");
    return c2.assertValidity(), c2;
  }
  toRawBytes(e2 = false) {
    return Zt(this.toHex(e2));
  }
  toHex(e2 = false) {
    const t2 = Gt(this.x);
    return e2 ? `${this.hasEvenY() ? "02" : "03"}${t2}` : `04${t2}${Gt(this.y)}`;
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const e2 = "Point is not on elliptic curve", { x: t2, y: r2 } = this;
    if (!fr(t2) || !fr(r2))
      throw new Error(e2);
    const n2 = er(r2 * r2);
    if (er(n2 - kt(t2)) !== St)
      throw new Error(e2);
  }
  equals(e2) {
    return this.x === e2.x && this.y === e2.y;
  }
  negate() {
    return new Dt(this.x, er(-this.y));
  }
  double() {
    return Pt.fromAffine(this).double().toAffine();
  }
  add(e2) {
    return Pt.fromAffine(this).add(Pt.fromAffine(e2)).toAffine();
  }
  subtract(e2) {
    return this.add(e2.negate());
  }
  multiply(e2) {
    return Pt.fromAffine(this).multiply(e2, this).toAffine();
  }
  multiplyAndAddUnsafe(e2, t2, r2) {
    const n2 = Pt.fromAffine(this), i2 = t2 === St || t2 === Nt || this !== Dt.BASE ? n2.multiplyUnsafe(t2) : n2.multiply(t2), o2 = Pt.fromAffine(e2).multiplyUnsafe(r2), s2 = i2.add(o2);
    return s2.equals(Pt.ZERO) ? void 0 : s2.toAffine();
  }
};
function zt(e2) {
  return Number.parseInt(e2[0], 16) >= 8 ? "00" + e2 : e2;
}
function $t(e2) {
  if (e2.length < 2 || 2 !== e2[0])
    throw new Error(`Invalid signature integer tag: ${Ht(e2)}`);
  const t2 = e2[1], r2 = e2.subarray(2, t2 + 2);
  if (!t2 || r2.length !== t2)
    throw new Error("Invalid signature integer: wrong length");
  if (0 === r2[0] && r2[1] <= 127)
    throw new Error("Invalid signature integer: trailing length");
  return { data: Yt(r2), left: e2.subarray(t2 + 2) };
}
Dt.BASE = new Dt(Lt.Gx, Lt.Gy), Dt.ZERO = new Dt(St, St);
var Vt = class {
  constructor(e2, t2) {
    this.r = e2, this.s = t2, this.assertValidity();
  }
  static fromCompact(e2) {
    const t2 = e2 instanceof Uint8Array, r2 = "Signature.fromCompact";
    if ("string" != typeof e2 && !t2)
      throw new TypeError(`${r2}: Expected string or Uint8Array`);
    const n2 = t2 ? Ht(e2) : e2;
    if (128 !== n2.length)
      throw new Error(`${r2}: Expected 64-byte hex`);
    return new Vt(Wt(n2.slice(0, 64)), Wt(n2.slice(64, 128)));
  }
  static fromDER(e2) {
    const t2 = e2 instanceof Uint8Array;
    if ("string" != typeof e2 && !t2)
      throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
    const { r: r2, s: n2 } = function(e3) {
      if (e3.length < 2 || 48 != e3[0])
        throw new Error(`Invalid signature tag: ${Ht(e3)}`);
      if (e3[1] !== e3.length - 2)
        throw new Error("Invalid signature: incorrect length");
      const { data: t3, left: r3 } = $t(e3.subarray(2)), { data: n3, left: i2 } = $t(r3);
      if (i2.length)
        throw new Error(`Invalid signature: left bytes after parsing: ${Ht(i2)}`);
      return { r: t3, s: n3 };
    }(t2 ? e2 : Zt(e2));
    return new Vt(r2, n2);
  }
  static fromHex(e2) {
    return this.fromDER(e2);
  }
  assertValidity() {
    const { r: e2, s: t2 } = this;
    if (!hr(e2))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!hr(t2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    return this.s > Lt.n >> Nt;
  }
  normalizeS() {
    return this.hasHighS() ? new Vt(this.r, Lt.n - this.s) : this;
  }
  toDERRawBytes(e2 = false) {
    return Zt(this.toDERHex(e2));
  }
  toDERHex(e2 = false) {
    const t2 = zt(Jt(this.s));
    if (e2)
      return t2;
    const r2 = zt(Jt(this.r)), n2 = Jt(r2.length / 2), i2 = Jt(t2.length / 2);
    return `30${Jt(r2.length / 2 + t2.length / 2 + 4)}02${n2}${r2}02${i2}${t2}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return Zt(this.toCompactHex());
  }
  toCompactHex() {
    return Gt(this.r) + Gt(this.s);
  }
};
function jt(...e2) {
  if (!e2.every((e3) => e3 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (1 === e2.length)
    return e2[0];
  const t2 = e2.reduce((e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(t2);
  for (let t3 = 0, n2 = 0; t3 < e2.length; t3++) {
    const i2 = e2[t3];
    r2.set(i2, n2), n2 += i2.length;
  }
  return r2;
}
var Ft = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function Ht(e2) {
  if (!(e2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let t2 = "";
  for (let r2 = 0; r2 < e2.length; r2++)
    t2 += Ft[e2[r2]];
  return t2;
}
var Kt = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function Gt(e2) {
  if ("bigint" != typeof e2)
    throw new Error("Expected bigint");
  if (!(St <= e2 && e2 < Kt))
    throw new Error("Expected number < 2^256");
  return e2.toString(16).padStart(64, "0");
}
function qt(e2) {
  const t2 = Zt(Gt(e2));
  if (32 !== t2.length)
    throw new Error("Error: expected 32 bytes");
  return t2;
}
function Jt(e2) {
  const t2 = e2.toString(16);
  return 1 & t2.length ? `0${t2}` : t2;
}
function Wt(e2) {
  if ("string" != typeof e2)
    throw new TypeError("hexToNumber: expected string, got " + typeof e2);
  return BigInt(`0x${e2}`);
}
function Zt(e2) {
  if ("string" != typeof e2)
    throw new TypeError("hexToBytes: expected string, got " + typeof e2);
  if (e2.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + e2.length);
  const t2 = new Uint8Array(e2.length / 2);
  for (let r2 = 0; r2 < t2.length; r2++) {
    const n2 = 2 * r2, i2 = e2.slice(n2, n2 + 2), o2 = Number.parseInt(i2, 16);
    if (Number.isNaN(o2) || o2 < 0)
      throw new Error("Invalid byte sequence");
    t2[r2] = o2;
  }
  return t2;
}
function Yt(e2) {
  return Wt(Ht(e2));
}
function Xt(e2) {
  return e2 instanceof Uint8Array ? Uint8Array.from(e2) : Zt(e2);
}
function Qt(e2) {
  if ("number" == typeof e2 && Number.isSafeInteger(e2) && e2 > 0)
    return BigInt(e2);
  if ("bigint" == typeof e2 && hr(e2))
    return e2;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function er(e2, t2 = Lt.P) {
  const r2 = e2 % t2;
  return r2 >= St ? r2 : t2 + r2;
}
function tr(e2, t2) {
  const { P: r2 } = Lt;
  let n2 = e2;
  for (; t2-- > St; )
    n2 *= n2, n2 %= r2;
  return n2;
}
function rr(e2, t2 = Lt.P) {
  if (e2 === St || t2 <= St)
    throw new Error(`invert: expected positive integers, got n=${e2} mod=${t2}`);
  let r2 = er(e2, t2), n2 = t2, i2 = St, o2 = Nt;
  for (; r2 !== St; ) {
    const e3 = n2 % r2, t3 = i2 - o2 * (n2 / r2);
    n2 = r2, r2 = e3, i2 = o2, o2 = t3;
  }
  if (n2 !== Nt)
    throw new Error("invert: does not exist");
  return er(i2, t2);
}
var nr = (e2, t2) => (e2 + t2 / It) / t2;
var ir = { a1: BigInt("0x3086d221a7d46bcde86c90e49284eb15"), b1: -Nt * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), a2: BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), b2: BigInt("0x3086d221a7d46bcde86c90e49284eb15"), POW_2_128: BigInt("0x100000000000000000000000000000000") };
function or(e2) {
  const { n: t2 } = Lt, { a1: r2, b1: n2, a2: i2, b2: o2, POW_2_128: s2 } = ir, a2 = nr(o2 * e2, t2), u2 = nr(-n2 * e2, t2);
  let h2 = er(e2 - a2 * r2 - u2 * i2, t2), f2 = er(-a2 * n2 - u2 * o2, t2);
  const c2 = h2 > s2, l2 = f2 > s2;
  if (c2 && (h2 = t2 - h2), l2 && (f2 = t2 - f2), h2 > s2 || f2 > s2)
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + e2);
  return { k1neg: c2, k1: h2, k2neg: l2, k2: f2 };
}
var sr;
var ar;
var ur = class {
  constructor() {
    this.v = new Uint8Array(32).fill(1), this.k = new Uint8Array(32).fill(0), this.counter = 0;
  }
  hmac(...e2) {
    return vr.hmacSha256(this.k, ...e2);
  }
  hmacSync(...e2) {
    return ar(this.k, ...e2);
  }
  checkSync() {
    if ("function" != typeof ar)
      throw new Ct("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(e2 = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), e2), this.v = await this.hmac(this.v), 0 !== e2.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e2), this.v = await this.hmac(this.v));
  }
  reseedSync(e2 = new Uint8Array()) {
    this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), e2), this.v = this.hmacSync(this.v), 0 !== e2.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e2), this.v = this.hmacSync(this.v));
  }
  async generate() {
    return this.incr(), this.v = await this.hmac(this.v), this.v;
  }
  generateSync() {
    return this.checkSync(), this.incr(), this.v = this.hmacSync(this.v), this.v;
  }
};
function hr(e2) {
  return St < e2 && e2 < Lt.n;
}
function fr(e2) {
  return St < e2 && e2 < Lt.P;
}
function cr(e2, t2, r2) {
  const n2 = Yt(e2);
  if (!hr(n2))
    return;
  const { n: i2 } = Lt, o2 = Dt.BASE.multiply(n2), s2 = er(o2.x, i2);
  if (s2 === St)
    return;
  const a2 = er(rr(n2, i2) * er(t2 + r2 * s2, i2), i2);
  if (a2 === St)
    return;
  const u2 = new Vt(s2, a2);
  return { sig: u2, recovery: (o2.x === u2.r ? 0 : 2) | Number(o2.y & Nt) };
}
function lr(e2) {
  let t2;
  if ("bigint" == typeof e2)
    t2 = e2;
  else if ("number" == typeof e2 && Number.isSafeInteger(e2) && e2 > 0)
    t2 = BigInt(e2);
  else if ("string" == typeof e2) {
    if (64 !== e2.length)
      throw new Error("Expected 32 bytes of private key");
    t2 = Wt(e2);
  } else {
    if (!(e2 instanceof Uint8Array))
      throw new TypeError("Expected valid private key");
    if (32 !== e2.length)
      throw new Error("Expected 32 bytes of private key");
    t2 = Yt(e2);
  }
  if (!hr(t2))
    throw new Error("Expected private key: 0 < key < n");
  return t2;
}
function dr(e2, t2 = false) {
  return Dt.fromPrivateKey(e2).toRawBytes(t2);
}
function pr(e2, t2, r2, n2 = false) {
  return Dt.fromSignature(e2, t2, r2).toRawBytes(n2);
}
function yr(e2) {
  return Yt(e2.length > 32 ? e2.slice(0, 32) : e2);
}
function gr(e2) {
  const t2 = yr(e2), r2 = er(t2, Lt.n);
  return mr(r2 < St ? t2 : r2);
}
function mr(e2) {
  return qt(e2);
}
Dt.BASE._setWindowSize(8);
var wr = { node: me, web: "object" == typeof self && "crypto" in self ? self.crypto : void 0 };
var br = {};
var vr = { bytesToHex: Ht, hexToBytes: Zt, concatBytes: jt, mod: er, invert: rr, isValidPrivateKey(e2) {
  try {
    return lr(e2), true;
  } catch (e3) {
    return false;
  }
}, _bigintTo32Bytes: qt, _normalizePrivateKey: lr, hashToPrivateKey: (e2) => {
  if ((e2 = Xt(e2)).length < 40 || e2.length > 1024)
    throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
  return qt(er(Yt(e2), Lt.n - Nt) + Nt);
}, randomBytes: (e2 = 32) => {
  if (wr.web)
    return wr.web.getRandomValues(new Uint8Array(e2));
  if (wr.node) {
    const { randomBytes: t2 } = wr.node;
    return Uint8Array.from(t2(e2));
  }
  throw new Error("The environment doesn't have randomBytes function");
}, randomPrivateKey: () => vr.hashToPrivateKey(vr.randomBytes(40)), sha256: async (...e2) => {
  if (wr.web) {
    const t2 = await wr.web.subtle.digest("SHA-256", jt(...e2));
    return new Uint8Array(t2);
  }
  if (wr.node) {
    const { createHash: t2 } = wr.node, r2 = t2("sha256");
    return e2.forEach((e3) => r2.update(e3)), Uint8Array.from(r2.digest());
  }
  throw new Error("The environment doesn't have sha256 function");
}, hmacSha256: async (e2, ...t2) => {
  if (wr.web) {
    const r2 = await wr.web.subtle.importKey("raw", e2, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), n2 = jt(...t2), i2 = await wr.web.subtle.sign("HMAC", r2, n2);
    return new Uint8Array(i2);
  }
  if (wr.node) {
    const { createHmac: r2 } = wr.node, n2 = r2("sha256", e2);
    return t2.forEach((e3) => n2.update(e3)), Uint8Array.from(n2.digest());
  }
  throw new Error("The environment doesn't have hmac-sha256 function");
}, sha256Sync: void 0, hmacSha256Sync: void 0, taggedHash: async (e2, ...t2) => {
  let r2 = br[e2];
  if (void 0 === r2) {
    const t3 = await vr.sha256(Uint8Array.from(e2, (e3) => e3.charCodeAt(0)));
    r2 = jt(t3, t3), br[e2] = r2;
  }
  return vr.sha256(r2, ...t2);
}, taggedHashSync: (e2, ...t2) => {
  if ("function" != typeof sr)
    throw new Ct("sha256Sync is undefined, you need to set it");
  let r2 = br[e2];
  if (void 0 === r2) {
    const t3 = sr(Uint8Array.from(e2, (e3) => e3.charCodeAt(0)));
    r2 = jt(t3, t3), br[e2] = r2;
  }
  return sr(r2, ...t2);
}, precompute(e2 = 8, t2 = Dt.BASE) {
  const r2 = t2 === Dt.BASE ? t2 : new Dt(t2.x, t2.y);
  return r2._setWindowSize(e2), r2.multiply(Ot), r2;
} };
Object.defineProperties(vr, { sha256Sync: { configurable: false, get: () => sr, set(e2) {
  sr || (sr = e2);
} }, hmacSha256Sync: { configurable: false, get: () => ar, set(e2) {
  ar || (ar = e2);
} } });
var Er = (e2, t2, r2) => e2 & t2 ^ e2 & r2 ^ t2 & r2;
var xr = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var Br = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var Ar = new Uint32Array(64);
var _r = class extends Le {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | Br[0], this.B = 0 | Br[1], this.C = 0 | Br[2], this.D = 0 | Br[3], this.E = 0 | Br[4], this.F = 0 | Br[5], this.G = 0 | Br[6], this.H = 0 | Br[7];
  }
  get() {
    const { A: e2, B: t2, C: r2, D: n2, E: i2, F: o2, G: s2, H: a2 } = this;
    return [e2, t2, r2, n2, i2, o2, s2, a2];
  }
  set(e2, t2, r2, n2, i2, o2, s2, a2) {
    this.A = 0 | e2, this.B = 0 | t2, this.C = 0 | r2, this.D = 0 | n2, this.E = 0 | i2, this.F = 0 | o2, this.G = 0 | s2, this.H = 0 | a2;
  }
  process(e2, t2) {
    for (let r3 = 0; r3 < 16; r3++, t2 += 4)
      Ar[r3] = e2.getUint32(t2, false);
    for (let e3 = 16; e3 < 64; e3++) {
      const t3 = Ar[e3 - 15], r3 = Ar[e3 - 2], n3 = _e(t3, 7) ^ _e(t3, 18) ^ t3 >>> 3, i3 = _e(r3, 17) ^ _e(r3, 19) ^ r3 >>> 10;
      Ar[e3] = i3 + Ar[e3 - 7] + n3 + Ar[e3 - 16] | 0;
    }
    let { A: r2, B: n2, C: i2, D: o2, E: s2, F: a2, G: u2, H: h2 } = this;
    for (let e3 = 0; e3 < 64; e3++) {
      const t3 = h2 + (_e(s2, 6) ^ _e(s2, 11) ^ _e(s2, 25)) + ((f2 = s2) & a2 ^ ~f2 & u2) + xr[e3] + Ar[e3] | 0, c2 = (_e(r2, 2) ^ _e(r2, 13) ^ _e(r2, 22)) + Er(r2, n2, i2) | 0;
      h2 = u2, u2 = a2, a2 = s2, s2 = o2 + t3 | 0, o2 = i2, i2 = n2, n2 = r2, r2 = t3 + c2 | 0;
    }
    var f2;
    r2 = r2 + this.A | 0, n2 = n2 + this.B | 0, i2 = i2 + this.C | 0, o2 = o2 + this.D | 0, s2 = s2 + this.E | 0, a2 = a2 + this.F | 0, u2 = u2 + this.G | 0, h2 = h2 + this.H | 0, this.set(r2, n2, i2, o2, s2, a2, u2, h2);
  }
  roundClean() {
    Ar.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Tr = class extends _r {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var Sr = Ue(() => new _r());
Ue(() => new Tr());
var Nr = class {
  constructor(e2) {
    if (this.data = void 0, this.data = "string" == typeof e2 ? ft(e2) : e2 instanceof Uint8Array ? e2 : Uint8Array.from(e2), 33 !== this.data.length)
      throw new Error(`Invalid public key input. Expected 33 bytes, got ${this.data.length}`);
  }
  equals(e2) {
    return be(this.toBytes(), e2.toBytes());
  }
  toBase64() {
    return lt(this.toBytes());
  }
  toBytes() {
    return this.data;
  }
  toString() {
    return this.toBase64();
  }
  toAddress() {
    let e2 = new Uint8Array(34);
    return e2.set([1]), e2.set(this.toBytes(), 1), "0x" + ve.sha3_256(e2).slice(0, 40);
  }
};
var Ir = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Or = Uint8Array.from({ length: 16 }, (e2, t2) => t2);
var Ur = Or.map((e2) => (9 * e2 + 5) % 16);
var Lr = [Or];
var kr = [Ur];
for (let e2 = 0; e2 < 4; e2++)
  for (let t2 of [Lr, kr])
    t2.push(t2[e2].map((e3) => Ir[e3]));
var Mr = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((e2) => new Uint8Array(e2));
var Cr = Lr.map((e2, t2) => e2.map((e3) => Mr[t2][e3]));
var Pr = kr.map((e2, t2) => e2.map((e3) => Mr[t2][e3]));
var Rr = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var Dr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var zr = (e2, t2) => e2 << t2 | e2 >>> 32 - t2;
function $r(e2, t2, r2, n2) {
  return 0 === e2 ? t2 ^ r2 ^ n2 : 1 === e2 ? t2 & r2 | ~t2 & n2 : 2 === e2 ? (t2 | ~r2) ^ n2 : 3 === e2 ? t2 & n2 | r2 & ~n2 : t2 ^ (r2 | ~n2);
}
var Vr = new Uint32Array(16);
var jr = class extends Le {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e2, h1: t2, h2: r2, h3: n2, h4: i2 } = this;
    return [e2, t2, r2, n2, i2];
  }
  set(e2, t2, r2, n2, i2) {
    this.h0 = 0 | e2, this.h1 = 0 | t2, this.h2 = 0 | r2, this.h3 = 0 | n2, this.h4 = 0 | i2;
  }
  process(e2, t2) {
    for (let r3 = 0; r3 < 16; r3++, t2 += 4)
      Vr[r3] = e2.getUint32(t2, true);
    let r2 = 0 | this.h0, n2 = r2, i2 = 0 | this.h1, o2 = i2, s2 = 0 | this.h2, a2 = s2, u2 = 0 | this.h3, h2 = u2, f2 = 0 | this.h4, c2 = f2;
    for (let e3 = 0; e3 < 5; e3++) {
      const t3 = 4 - e3, l2 = Rr[e3], d2 = Dr[e3], p2 = Lr[e3], y2 = kr[e3], g2 = Cr[e3], m2 = Pr[e3];
      for (let t4 = 0; t4 < 16; t4++) {
        const n3 = zr(r2 + $r(e3, i2, s2, u2) + Vr[p2[t4]] + l2, g2[t4]) + f2 | 0;
        r2 = f2, f2 = u2, u2 = 0 | zr(s2, 10), s2 = i2, i2 = n3;
      }
      for (let e4 = 0; e4 < 16; e4++) {
        const r3 = zr(n2 + $r(t3, o2, a2, h2) + Vr[y2[e4]] + d2, m2[e4]) + c2 | 0;
        n2 = c2, c2 = h2, h2 = 0 | zr(a2, 10), a2 = o2, o2 = r3;
      }
    }
    this.set(this.h1 + s2 + h2 | 0, this.h2 + u2 + c2 | 0, this.h3 + f2 + n2 | 0, this.h4 + r2 + o2 | 0, this.h0 + i2 + a2 | 0);
  }
  roundClean() {
    Vr.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
var Fr = Ue(() => new jr());
var Hr = BigInt(0);
var Kr = BigInt(1);
var Gr = BigInt(2);
var qr = BigInt(3);
var Jr = BigInt(8);
var Wr = Object.freeze({ a: Hr, b: BigInt(7), P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), h: Kr, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee") });
var Zr = (e2, t2) => (e2 + t2 / Gr) / t2;
var Yr = { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar(e2) {
  const { n: t2 } = Wr, r2 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n2 = -Kr * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o2 = r2, s2 = BigInt("0x100000000000000000000000000000000"), a2 = Zr(o2 * e2, t2), u2 = Zr(-n2 * e2, t2);
  let h2 = xn(e2 - a2 * r2 - u2 * i2, t2), f2 = xn(-a2 * n2 - u2 * o2, t2);
  const c2 = h2 > s2, l2 = f2 > s2;
  if (c2 && (h2 = t2 - h2), l2 && (f2 = t2 - f2), h2 > s2 || f2 > s2)
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + e2);
  return { k1neg: c2, k1: h2, k2neg: l2, k2: f2 };
} };
function Xr(e2) {
  const { a: t2, b: r2 } = Wr, n2 = xn(e2 * e2), i2 = xn(n2 * e2);
  return xn(i2 + t2 * e2 + r2);
}
var Qr = Wr.a === Hr;
var en = class extends Error {
  constructor(e2) {
    super(e2);
  }
};
function tn(e2) {
  if (!(e2 instanceof rn))
    throw new TypeError("JacobianPoint expected");
}
var rn = class {
  constructor(e2, t2, r2) {
    this.x = e2, this.y = t2, this.z = r2;
  }
  static fromAffine(e2) {
    if (!(e2 instanceof sn))
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    return e2.equals(sn.ZERO) ? rn.ZERO : new rn(e2.x, e2.y, Kr);
  }
  static toAffineBatch(e2) {
    const t2 = function(e3, t3 = Wr.P) {
      const r2 = new Array(e3.length), n2 = e3.reduce((e4, n3, i3) => n3 === Hr ? e4 : (r2[i3] = e4, xn(e4 * n3, t3)), Kr), i2 = An(n2, t3);
      return e3.reduceRight((e4, n3, i3) => n3 === Hr ? e4 : (r2[i3] = xn(e4 * r2[i3], t3), xn(e4 * n3, t3)), i2), r2;
    }(e2.map((e3) => e3.z));
    return e2.map((e3, r2) => e3.toAffine(t2[r2]));
  }
  static normalizeZ(e2) {
    return rn.toAffineBatch(e2).map(rn.fromAffine);
  }
  equals(e2) {
    tn(e2);
    const { x: t2, y: r2, z: n2 } = this, { x: i2, y: o2, z: s2 } = e2, a2 = xn(n2 * n2), u2 = xn(s2 * s2), h2 = xn(t2 * u2), f2 = xn(i2 * a2), c2 = xn(xn(r2 * s2) * u2), l2 = xn(xn(o2 * n2) * a2);
    return h2 === f2 && c2 === l2;
  }
  negate() {
    return new rn(this.x, xn(-this.y), this.z);
  }
  double() {
    const { x: e2, y: t2, z: r2 } = this, n2 = xn(e2 * e2), i2 = xn(t2 * t2), o2 = xn(i2 * i2), s2 = e2 + i2, a2 = xn(Gr * (xn(s2 * s2) - n2 - o2)), u2 = xn(qr * n2), h2 = xn(u2 * u2), f2 = xn(h2 - Gr * a2), c2 = xn(u2 * (a2 - f2) - Jr * o2), l2 = xn(Gr * t2 * r2);
    return new rn(f2, c2, l2);
  }
  add(e2) {
    tn(e2);
    const { x: t2, y: r2, z: n2 } = this, { x: i2, y: o2, z: s2 } = e2;
    if (i2 === Hr || o2 === Hr)
      return this;
    if (t2 === Hr || r2 === Hr)
      return e2;
    const a2 = xn(n2 * n2), u2 = xn(s2 * s2), h2 = xn(t2 * u2), f2 = xn(i2 * a2), c2 = xn(xn(r2 * s2) * u2), l2 = xn(xn(o2 * n2) * a2), d2 = xn(f2 - h2), p2 = xn(l2 - c2);
    if (d2 === Hr)
      return p2 === Hr ? this.double() : rn.ZERO;
    const y2 = xn(d2 * d2), g2 = xn(d2 * y2), m2 = xn(h2 * y2), w2 = xn(p2 * p2 - g2 - Gr * m2), b2 = xn(p2 * (m2 - w2) - c2 * g2), v2 = xn(n2 * s2 * d2);
    return new rn(w2, b2, v2);
  }
  subtract(e2) {
    return this.add(e2.negate());
  }
  multiplyUnsafe(e2) {
    const t2 = rn.ZERO;
    if ("bigint" == typeof e2 && e2 === Hr)
      return t2;
    let r2 = En(e2);
    if (r2 === Kr)
      return this;
    if (!Qr) {
      let e3 = t2, n3 = this;
      for (; r2 > Hr; )
        r2 & Kr && (e3 = e3.add(n3)), n3 = n3.double(), r2 >>= Kr;
      return e3;
    }
    let { k1neg: n2, k1: i2, k2neg: o2, k2: s2 } = Yr.splitScalar(r2), a2 = t2, u2 = t2, h2 = this;
    for (; i2 > Hr || s2 > Hr; )
      i2 & Kr && (a2 = a2.add(h2)), s2 & Kr && (u2 = u2.add(h2)), h2 = h2.double(), i2 >>= Kr, s2 >>= Kr;
    return n2 && (a2 = a2.negate()), o2 && (u2 = u2.negate()), u2 = new rn(xn(u2.x * Yr.beta), u2.y, u2.z), a2.add(u2);
  }
  precomputeWindow(e2) {
    const t2 = Qr ? 128 / e2 + 1 : 256 / e2 + 1, r2 = [];
    let n2 = this, i2 = n2;
    for (let o2 = 0; o2 < t2; o2++) {
      i2 = n2, r2.push(i2);
      for (let t3 = 1; t3 < 2 ** (e2 - 1); t3++)
        i2 = i2.add(n2), r2.push(i2);
      n2 = i2.double();
    }
    return r2;
  }
  wNAF(e2, t2) {
    !t2 && this.equals(rn.BASE) && (t2 = sn.BASE);
    const r2 = t2 && t2._WINDOW_SIZE || 1;
    if (256 % r2)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let n2 = t2 && on.get(t2);
    n2 || (n2 = this.precomputeWindow(r2), t2 && 1 !== r2 && (n2 = rn.normalizeZ(n2), on.set(t2, n2)));
    let i2 = rn.ZERO, o2 = rn.BASE;
    const s2 = 1 + (Qr ? 128 / r2 : 256 / r2), a2 = 2 ** (r2 - 1), u2 = BigInt(2 ** r2 - 1), h2 = 2 ** r2, f2 = BigInt(r2);
    for (let t3 = 0; t3 < s2; t3++) {
      const r3 = t3 * a2;
      let s3 = Number(e2 & u2);
      e2 >>= f2, s3 > a2 && (s3 -= h2, e2 += Kr);
      const c2 = r3, l2 = r3 + Math.abs(s3) - 1, d2 = s3 < 0;
      0 === s3 ? o2 = o2.add(nn(t3 % 2 != 0, n2[c2])) : i2 = i2.add(nn(d2, n2[l2]));
    }
    return { p: i2, f: o2 };
  }
  multiply(e2, t2) {
    let r2, n2, i2 = En(e2);
    if (Qr) {
      const { k1neg: e3, k1: o2, k2neg: s2, k2: a2 } = Yr.splitScalar(i2);
      let { p: u2, f: h2 } = this.wNAF(o2, t2), { p: f2, f: c2 } = this.wNAF(a2, t2);
      u2 = nn(e3, u2), f2 = nn(s2, f2), f2 = new rn(xn(f2.x * Yr.beta), f2.y, f2.z), r2 = u2.add(f2), n2 = h2.add(c2);
    } else {
      const { p: e3, f: o2 } = this.wNAF(i2, t2);
      r2 = e3, n2 = o2;
    }
    return rn.normalizeZ([r2, n2])[0];
  }
  toAffine(e2) {
    const { x: t2, y: r2, z: n2 } = this, i2 = this.equals(rn.ZERO);
    null == e2 && (e2 = i2 ? Jr : An(n2));
    const o2 = e2, s2 = xn(o2 * o2), a2 = xn(s2 * o2), u2 = xn(t2 * s2), h2 = xn(r2 * a2), f2 = xn(n2 * o2);
    if (i2)
      return sn.ZERO;
    if (f2 !== Kr)
      throw new Error("invZ was invalid");
    return new sn(u2, h2);
  }
};
function nn(e2, t2) {
  const r2 = t2.negate();
  return e2 ? r2 : t2;
}
rn.BASE = new rn(Wr.Gx, Wr.Gy, Kr), rn.ZERO = new rn(Hr, Kr, Hr);
var on = /* @__PURE__ */ new WeakMap();
var sn = class {
  constructor(e2, t2) {
    this.x = e2, this.y = t2;
  }
  _setWindowSize(e2) {
    this._WINDOW_SIZE = e2, on.delete(this);
  }
  hasEvenY() {
    return this.y % Gr === Hr;
  }
  static fromCompressedHex(e2) {
    const t2 = 32 === e2.length, r2 = bn(t2 ? e2 : e2.subarray(1));
    if (!On(r2))
      throw new Error("Point is not on curve");
    let n2 = function(e3) {
      const { P: t3 } = Wr, r3 = BigInt(6), n3 = BigInt(11), i3 = BigInt(22), o3 = BigInt(23), s2 = BigInt(44), a2 = BigInt(88), u2 = e3 * e3 * e3 % t3, h2 = u2 * u2 * e3 % t3, f2 = Bn(h2, qr) * h2 % t3, c2 = Bn(f2, qr) * h2 % t3, l2 = Bn(c2, Gr) * u2 % t3, d2 = Bn(l2, n3) * l2 % t3, p2 = Bn(d2, i3) * d2 % t3, y2 = Bn(p2, s2) * p2 % t3, g2 = Bn(y2, a2) * y2 % t3, m2 = Bn(g2, s2) * p2 % t3, w2 = Bn(m2, qr) * h2 % t3, b2 = Bn(w2, o3) * d2 % t3, v2 = Bn(b2, r3) * u2 % t3, E2 = Bn(v2, Gr);
      if (E2 * E2 % t3 !== e3)
        throw new Error("Cannot find square root");
      return E2;
    }(Xr(r2));
    const i2 = (n2 & Kr) === Kr;
    t2 ? i2 && (n2 = xn(-n2)) : 1 == (1 & e2[0]) !== i2 && (n2 = xn(-n2));
    const o2 = new sn(r2, n2);
    return o2.assertValidity(), o2;
  }
  static fromUncompressedHex(e2) {
    const t2 = bn(e2.subarray(1, 33)), r2 = bn(e2.subarray(33, 65)), n2 = new sn(t2, r2);
    return n2.assertValidity(), n2;
  }
  static fromHex(e2) {
    const t2 = vn(e2), r2 = t2.length, n2 = t2[0];
    if (32 === r2)
      return this.fromCompressedHex(t2);
    if (33 === r2 && (2 === n2 || 3 === n2))
      return this.fromCompressedHex(t2);
    if (65 === r2 && 4 === n2)
      return this.fromUncompressedHex(t2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r2}`);
  }
  static fromPrivateKey(e2) {
    return sn.BASE.multiply(Ln(e2));
  }
  static fromSignature(e2, t2, r2) {
    const { r: n2, s: i2 } = kn(t2);
    if (![0, 1, 2, 3].includes(r2))
      throw new Error("Cannot recover: invalid recovery bit");
    const o2 = _n(vn(e2)), { n: s2 } = Wr, a2 = 2 === r2 || 3 === r2 ? n2 + s2 : n2, u2 = An(a2, s2), h2 = xn(-o2 * u2, s2), f2 = xn(i2 * u2, s2), c2 = sn.fromHex((1 & r2 ? "03" : "02") + pn(a2)), l2 = sn.BASE.multiplyAndAddUnsafe(c2, h2, f2);
    if (!l2)
      throw new Error("Cannot recover signature: point at infinify");
    return l2.assertValidity(), l2;
  }
  toRawBytes(e2 = false) {
    return wn(this.toHex(e2));
  }
  toHex(e2 = false) {
    const t2 = pn(this.x);
    return e2 ? `${this.hasEvenY() ? "02" : "03"}${t2}` : `04${t2}${pn(this.y)}`;
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const e2 = "Point is not on elliptic curve", { x: t2, y: r2 } = this;
    if (!On(t2) || !On(r2))
      throw new Error(e2);
    const n2 = xn(r2 * r2);
    if (xn(n2 - Xr(t2)) !== Hr)
      throw new Error(e2);
  }
  equals(e2) {
    return this.x === e2.x && this.y === e2.y;
  }
  negate() {
    return new sn(this.x, xn(-this.y));
  }
  double() {
    return rn.fromAffine(this).double().toAffine();
  }
  add(e2) {
    return rn.fromAffine(this).add(rn.fromAffine(e2)).toAffine();
  }
  subtract(e2) {
    return this.add(e2.negate());
  }
  multiply(e2) {
    return rn.fromAffine(this).multiply(e2, this).toAffine();
  }
  multiplyAndAddUnsafe(e2, t2, r2) {
    const n2 = rn.fromAffine(this), i2 = t2 === Hr || t2 === Kr || this !== sn.BASE ? n2.multiplyUnsafe(t2) : n2.multiply(t2), o2 = rn.fromAffine(e2).multiplyUnsafe(r2), s2 = i2.add(o2);
    return s2.equals(rn.ZERO) ? void 0 : s2.toAffine();
  }
};
function an(e2) {
  return Number.parseInt(e2[0], 16) >= 8 ? "00" + e2 : e2;
}
function un(e2) {
  if (e2.length < 2 || 2 !== e2[0])
    throw new Error(`Invalid signature integer tag: ${ln(e2)}`);
  const t2 = e2[1], r2 = e2.subarray(2, t2 + 2);
  if (!t2 || r2.length !== t2)
    throw new Error("Invalid signature integer: wrong length");
  if (0 === r2[0] && r2[1] <= 127)
    throw new Error("Invalid signature integer: trailing length");
  return { data: bn(r2), left: e2.subarray(t2 + 2) };
}
sn.BASE = new sn(Wr.Gx, Wr.Gy), sn.ZERO = new sn(Hr, Hr);
var hn = class {
  constructor(e2, t2) {
    this.r = e2, this.s = t2, this.assertValidity();
  }
  static fromCompact(e2) {
    const t2 = e2 instanceof Uint8Array, r2 = "Signature.fromCompact";
    if ("string" != typeof e2 && !t2)
      throw new TypeError(`${r2}: Expected string or Uint8Array`);
    const n2 = t2 ? ln(e2) : e2;
    if (128 !== n2.length)
      throw new Error(`${r2}: Expected 64-byte hex`);
    return new hn(mn(n2.slice(0, 64)), mn(n2.slice(64, 128)));
  }
  static fromDER(e2) {
    const t2 = e2 instanceof Uint8Array;
    if ("string" != typeof e2 && !t2)
      throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
    const { r: r2, s: n2 } = function(e3) {
      if (e3.length < 2 || 48 != e3[0])
        throw new Error(`Invalid signature tag: ${ln(e3)}`);
      if (e3[1] !== e3.length - 2)
        throw new Error("Invalid signature: incorrect length");
      const { data: t3, left: r3 } = un(e3.subarray(2)), { data: n3, left: i2 } = un(r3);
      if (i2.length)
        throw new Error(`Invalid signature: left bytes after parsing: ${ln(i2)}`);
      return { r: t3, s: n3 };
    }(t2 ? e2 : wn(e2));
    return new hn(r2, n2);
  }
  static fromHex(e2) {
    return this.fromDER(e2);
  }
  assertValidity() {
    const { r: e2, s: t2 } = this;
    if (!In(e2))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!In(t2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    return this.s > Wr.n >> Kr;
  }
  normalizeS() {
    return this.hasHighS() ? new hn(this.r, xn(-this.s, Wr.n)) : this;
  }
  toDERRawBytes() {
    return wn(this.toDERHex());
  }
  toDERHex() {
    const e2 = an(gn(this.s)), t2 = an(gn(this.r)), r2 = e2.length / 2, n2 = t2.length / 2, i2 = gn(r2), o2 = gn(n2);
    return `30${gn(n2 + r2 + 4)}02${o2}${t2}02${i2}${e2}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return wn(this.toCompactHex());
  }
  toCompactHex() {
    return pn(this.r) + pn(this.s);
  }
};
function fn(...e2) {
  if (!e2.every((e3) => e3 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (1 === e2.length)
    return e2[0];
  const t2 = e2.reduce((e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(t2);
  for (let t3 = 0, n2 = 0; t3 < e2.length; t3++) {
    const i2 = e2[t3];
    r2.set(i2, n2), n2 += i2.length;
  }
  return r2;
}
var cn = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function ln(e2) {
  if (!(e2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let t2 = "";
  for (let r2 = 0; r2 < e2.length; r2++)
    t2 += cn[e2[r2]];
  return t2;
}
var dn = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function pn(e2) {
  if ("bigint" != typeof e2)
    throw new Error("Expected bigint");
  if (!(Hr <= e2 && e2 < dn))
    throw new Error("Expected number 0 <= n < 2^256");
  return e2.toString(16).padStart(64, "0");
}
function yn(e2) {
  const t2 = wn(pn(e2));
  if (32 !== t2.length)
    throw new Error("Error: expected 32 bytes");
  return t2;
}
function gn(e2) {
  const t2 = e2.toString(16);
  return 1 & t2.length ? `0${t2}` : t2;
}
function mn(e2) {
  if ("string" != typeof e2)
    throw new TypeError("hexToNumber: expected string, got " + typeof e2);
  return BigInt(`0x${e2}`);
}
function wn(e2) {
  if ("string" != typeof e2)
    throw new TypeError("hexToBytes: expected string, got " + typeof e2);
  if (e2.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + e2.length);
  const t2 = new Uint8Array(e2.length / 2);
  for (let r2 = 0; r2 < t2.length; r2++) {
    const n2 = 2 * r2, i2 = e2.slice(n2, n2 + 2), o2 = Number.parseInt(i2, 16);
    if (Number.isNaN(o2) || o2 < 0)
      throw new Error("Invalid byte sequence");
    t2[r2] = o2;
  }
  return t2;
}
function bn(e2) {
  return mn(ln(e2));
}
function vn(e2) {
  return e2 instanceof Uint8Array ? Uint8Array.from(e2) : wn(e2);
}
function En(e2) {
  if ("number" == typeof e2 && Number.isSafeInteger(e2) && e2 > 0)
    return BigInt(e2);
  if ("bigint" == typeof e2 && In(e2))
    return e2;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function xn(e2, t2 = Wr.P) {
  const r2 = e2 % t2;
  return r2 >= Hr ? r2 : t2 + r2;
}
function Bn(e2, t2) {
  const { P: r2 } = Wr;
  let n2 = e2;
  for (; t2-- > Hr; )
    n2 *= n2, n2 %= r2;
  return n2;
}
function An(e2, t2 = Wr.P) {
  if (e2 === Hr || t2 <= Hr)
    throw new Error(`invert: expected positive integers, got n=${e2} mod=${t2}`);
  let r2 = xn(e2, t2), n2 = t2, i2 = Hr, o2 = Kr;
  for (; r2 !== Hr; ) {
    const e3 = n2 % r2, t3 = i2 - o2 * (n2 / r2);
    n2 = r2, r2 = e3, i2 = o2, o2 = t3;
  }
  if (n2 !== Kr)
    throw new Error("invert: does not exist");
  return xn(i2, t2);
}
function _n(e2, t2 = false) {
  const r2 = function(e3) {
    const t3 = 8 * e3.length - 256, r3 = bn(e3);
    return t3 > 0 ? r3 >> BigInt(t3) : r3;
  }(e2);
  if (t2)
    return r2;
  const { n: n2 } = Wr;
  return r2 >= n2 ? r2 - n2 : r2;
}
var Tn;
var Sn;
var Nn = class {
  constructor(e2, t2) {
    if (this.hashLen = e2, this.qByteLen = t2, "number" != typeof e2 || e2 < 2)
      throw new Error("hashLen must be a number");
    if ("number" != typeof t2 || t2 < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(e2).fill(1), this.k = new Uint8Array(e2).fill(0), this.counter = 0;
  }
  hmac(...e2) {
    return $n.hmacSha256(this.k, ...e2);
  }
  hmacSync(...e2) {
    return Sn(this.k, ...e2);
  }
  checkSync() {
    if ("function" != typeof Sn)
      throw new en("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(e2 = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), e2), this.v = await this.hmac(this.v), 0 !== e2.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e2), this.v = await this.hmac(this.v));
  }
  reseedSync(e2 = new Uint8Array()) {
    this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), e2), this.v = this.hmacSync(this.v), 0 !== e2.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e2), this.v = this.hmacSync(this.v));
  }
  async generate() {
    this.incr();
    let e2 = 0;
    const t2 = [];
    for (; e2 < this.qByteLen; ) {
      this.v = await this.hmac(this.v);
      const r2 = this.v.slice();
      t2.push(r2), e2 += this.v.length;
    }
    return fn(...t2);
  }
  generateSync() {
    this.checkSync(), this.incr();
    let e2 = 0;
    const t2 = [];
    for (; e2 < this.qByteLen; ) {
      this.v = this.hmacSync(this.v);
      const r2 = this.v.slice();
      t2.push(r2), e2 += this.v.length;
    }
    return fn(...t2);
  }
};
function In(e2) {
  return Hr < e2 && e2 < Wr.n;
}
function On(e2) {
  return Hr < e2 && e2 < Wr.P;
}
function Un(e2, t2, r2, n2 = true) {
  const { n: i2 } = Wr, o2 = _n(e2, true);
  if (!In(o2))
    return;
  const s2 = An(o2, i2), a2 = sn.BASE.multiply(o2), u2 = xn(a2.x, i2);
  if (u2 === Hr)
    return;
  const h2 = xn(s2 * xn(t2 + r2 * u2, i2), i2);
  if (h2 === Hr)
    return;
  let f2 = new hn(u2, h2), c2 = (a2.x === f2.r ? 0 : 2) | Number(a2.y & Kr);
  return n2 && f2.hasHighS() && (f2 = f2.normalizeS(), c2 ^= 1), { sig: f2, recovery: c2 };
}
function Ln(e2) {
  let t2;
  if ("bigint" == typeof e2)
    t2 = e2;
  else if ("number" == typeof e2 && Number.isSafeInteger(e2) && e2 > 0)
    t2 = BigInt(e2);
  else if ("string" == typeof e2) {
    if (64 !== e2.length)
      throw new Error("Expected 32 bytes of private key");
    t2 = mn(e2);
  } else {
    if (!(e2 instanceof Uint8Array))
      throw new TypeError("Expected valid private key");
    if (32 !== e2.length)
      throw new Error("Expected 32 bytes of private key");
    t2 = bn(e2);
  }
  if (!In(t2))
    throw new Error("Expected private key: 0 < key < n");
  return t2;
}
function kn(e2) {
  if (e2 instanceof hn)
    return e2.assertValidity(), e2;
  try {
    return hn.fromDER(e2);
  } catch (t2) {
    return hn.fromCompact(e2);
  }
}
function Mn(e2) {
  return bn(e2.length > 32 ? e2.slice(0, 32) : e2);
}
function Cn(e2) {
  const t2 = Mn(e2), r2 = xn(t2, Wr.n);
  return Pn(r2 < Hr ? t2 : r2);
}
function Pn(e2) {
  return yn(e2);
}
var Rn = { strict: true };
sn.BASE._setWindowSize(8);
var Dn = { node: me, web: "object" == typeof self && "crypto" in self ? self.crypto : void 0 };
var zn = {};
var $n = { bytesToHex: ln, hexToBytes: wn, concatBytes: fn, mod: xn, invert: An, isValidPrivateKey(e2) {
  try {
    return Ln(e2), true;
  } catch (e3) {
    return false;
  }
}, _bigintTo32Bytes: yn, _normalizePrivateKey: Ln, hashToPrivateKey: (e2) => {
  if ((e2 = vn(e2)).length < 40 || e2.length > 1024)
    throw new Error("Expected valid bytes of private key as per FIPS 186");
  return yn(xn(bn(e2), Wr.n - Kr) + Kr);
}, randomBytes: (e2 = 32) => {
  if (Dn.web)
    return Dn.web.getRandomValues(new Uint8Array(e2));
  if (Dn.node) {
    const { randomBytes: t2 } = Dn.node;
    return Uint8Array.from(t2(e2));
  }
  throw new Error("The environment doesn't have randomBytes function");
}, randomPrivateKey: () => $n.hashToPrivateKey($n.randomBytes(40)), precompute(e2 = 8, t2 = sn.BASE) {
  const r2 = t2 === sn.BASE ? t2 : new sn(t2.x, t2.y);
  return r2._setWindowSize(e2), r2.multiply(qr), r2;
}, sha256: async (...e2) => {
  if (Dn.web) {
    const t2 = await Dn.web.subtle.digest("SHA-256", fn(...e2));
    return new Uint8Array(t2);
  }
  if (Dn.node) {
    const { createHash: t2 } = Dn.node, r2 = t2("sha256");
    return e2.forEach((e3) => r2.update(e3)), Uint8Array.from(r2.digest());
  }
  throw new Error("The environment doesn't have sha256 function");
}, hmacSha256: async (e2, ...t2) => {
  if (Dn.web) {
    const r2 = await Dn.web.subtle.importKey("raw", e2, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), n2 = fn(...t2), i2 = await Dn.web.subtle.sign("HMAC", r2, n2);
    return new Uint8Array(i2);
  }
  if (Dn.node) {
    const { createHmac: r2 } = Dn.node, n2 = r2("sha256", e2);
    return t2.forEach((e3) => n2.update(e3)), Uint8Array.from(n2.digest());
  }
  throw new Error("The environment doesn't have hmac-sha256 function");
}, sha256Sync: void 0, hmacSha256Sync: void 0, taggedHash: async (e2, ...t2) => {
  let r2 = zn[e2];
  if (void 0 === r2) {
    const t3 = await $n.sha256(Uint8Array.from(e2, (e3) => e3.charCodeAt(0)));
    r2 = fn(t3, t3), zn[e2] = r2;
  }
  return $n.sha256(r2, ...t2);
}, taggedHashSync: (e2, ...t2) => {
  if ("function" != typeof Tn)
    throw new en("sha256Sync is undefined, you need to set it");
  let r2 = zn[e2];
  if (void 0 === r2) {
    const t3 = Tn(Uint8Array.from(e2, (e3) => e3.charCodeAt(0)));
    r2 = fn(t3, t3), zn[e2] = r2;
  }
  return Tn(r2, ...t2);
}, _JacobianPoint: rn };
function Vn(e2) {
  if (!Number.isSafeInteger(e2))
    throw new Error(`Wrong integer: ${e2}`);
}
function jn(...e2) {
  const t2 = (e3, t3) => (r3) => e3(t3(r3)), r2 = Array.from(e2).reverse().reduce((e3, r3) => e3 ? t2(e3, r3.encode) : r3.encode, void 0), n2 = e2.reduce((e3, r3) => e3 ? t2(e3, r3.decode) : r3.decode, void 0);
  return { encode: r2, decode: n2 };
}
function Fn(e2) {
  return { encode: (t2) => {
    if (!Array.isArray(t2) || t2.length && "number" != typeof t2[0])
      throw new Error("alphabet.encode input should be an array of numbers");
    return t2.map((t3) => {
      if (Vn(t3), t3 < 0 || t3 >= e2.length)
        throw new Error(`Digit index outside alphabet: ${t3} (alphabet: ${e2.length})`);
      return e2[t3];
    });
  }, decode: (t2) => {
    if (!Array.isArray(t2) || t2.length && "string" != typeof t2[0])
      throw new Error("alphabet.decode input should be array of strings");
    return t2.map((t3) => {
      if ("string" != typeof t3)
        throw new Error(`alphabet.decode: not string element=${t3}`);
      const r2 = e2.indexOf(t3);
      if (-1 === r2)
        throw new Error(`Unknown letter: "${t3}". Allowed: ${e2}`);
      return r2;
    });
  } };
}
function Hn(e2 = "") {
  if ("string" != typeof e2)
    throw new Error("join separator should be string");
  return { encode: (t2) => {
    if (!Array.isArray(t2) || t2.length && "string" != typeof t2[0])
      throw new Error("join.encode input should be array of strings");
    for (let e3 of t2)
      if ("string" != typeof e3)
        throw new Error(`join.encode: non-string input=${e3}`);
    return t2.join(e2);
  }, decode: (t2) => {
    if ("string" != typeof t2)
      throw new Error("join.decode input should be string");
    return t2.split(e2);
  } };
}
function Kn(e2, t2 = "=") {
  if (Vn(e2), "string" != typeof t2)
    throw new Error("padding chr should be string");
  return { encode(r2) {
    if (!Array.isArray(r2) || r2.length && "string" != typeof r2[0])
      throw new Error("padding.encode input should be array of strings");
    for (let e3 of r2)
      if ("string" != typeof e3)
        throw new Error(`padding.encode: non-string input=${e3}`);
    for (; r2.length * e2 % 8; )
      r2.push(t2);
    return r2;
  }, decode(r2) {
    if (!Array.isArray(r2) || r2.length && "string" != typeof r2[0])
      throw new Error("padding.encode input should be array of strings");
    for (let e3 of r2)
      if ("string" != typeof e3)
        throw new Error(`padding.decode: non-string input=${e3}`);
    let n2 = r2.length;
    if (n2 * e2 % 8)
      throw new Error("Invalid padding: string should have whole number of bytes");
    for (; n2 > 0 && r2[n2 - 1] === t2; n2--)
      if (!((n2 - 1) * e2 % 8))
        throw new Error("Invalid padding: string has too much padding");
    return r2.slice(0, n2);
  } };
}
function Gn(e2) {
  if ("function" != typeof e2)
    throw new Error("normalize fn should be function");
  return { encode: (e3) => e3, decode: (t2) => e2(t2) };
}
function qn(e2, t2, r2) {
  if (t2 < 2)
    throw new Error(`convertRadix: wrong from=${t2}, base cannot be less than 2`);
  if (r2 < 2)
    throw new Error(`convertRadix: wrong to=${r2}, base cannot be less than 2`);
  if (!Array.isArray(e2))
    throw new Error("convertRadix: data should be array");
  if (!e2.length)
    return [];
  let n2 = 0;
  const i2 = [], o2 = Array.from(e2);
  for (o2.forEach((e3) => {
    if (Vn(e3), e3 < 0 || e3 >= t2)
      throw new Error(`Wrong integer: ${e3}`);
  }); ; ) {
    let e3 = 0, s2 = true;
    for (let i3 = n2; i3 < o2.length; i3++) {
      const a2 = o2[i3], u2 = t2 * e3 + a2;
      if (!Number.isSafeInteger(u2) || t2 * e3 / t2 !== e3 || u2 - a2 != t2 * e3)
        throw new Error("convertRadix: carry overflow");
      if (e3 = u2 % r2, o2[i3] = Math.floor(u2 / r2), !Number.isSafeInteger(o2[i3]) || o2[i3] * r2 + e3 !== u2)
        throw new Error("convertRadix: carry overflow");
      s2 && (o2[i3] ? s2 = false : n2 = i3);
    }
    if (i2.push(e3), s2)
      break;
  }
  for (let t3 = 0; t3 < e2.length - 1 && 0 === e2[t3]; t3++)
    i2.push(0);
  return i2.reverse();
}
Object.defineProperties($n, { sha256Sync: { configurable: false, get: () => Tn, set(e2) {
  Tn || (Tn = e2);
} }, hmacSha256Sync: { configurable: false, get: () => Sn, set(e2) {
  Sn || (Sn = e2);
} } });
var Jn = (e2, t2) => t2 ? Jn(t2, e2 % t2) : e2;
var Wn = (e2, t2) => e2 + (t2 - Jn(e2, t2));
function Zn(e2, t2, r2, n2) {
  if (!Array.isArray(e2))
    throw new Error("convertRadix2: data should be array");
  if (t2 <= 0 || t2 > 32)
    throw new Error(`convertRadix2: wrong from=${t2}`);
  if (r2 <= 0 || r2 > 32)
    throw new Error(`convertRadix2: wrong to=${r2}`);
  if (Wn(t2, r2) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t2} to=${r2} carryBits=${Wn(t2, r2)}`);
  let i2 = 0, o2 = 0;
  const s2 = 2 ** r2 - 1, a2 = [];
  for (const n3 of e2) {
    if (Vn(n3), n3 >= 2 ** t2)
      throw new Error(`convertRadix2: invalid data word=${n3} from=${t2}`);
    if (i2 = i2 << t2 | n3, o2 + t2 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${o2} from=${t2}`);
    for (o2 += t2; o2 >= r2; o2 -= r2)
      a2.push((i2 >> o2 - r2 & s2) >>> 0);
    i2 &= 2 ** o2 - 1;
  }
  if (i2 = i2 << r2 - o2 & s2, !n2 && o2 >= t2)
    throw new Error("Excess padding");
  if (!n2 && i2)
    throw new Error(`Non-zero padding: ${i2}`);
  return n2 && o2 > 0 && a2.push(i2 >>> 0), a2;
}
function Yn(e2, t2 = false) {
  if (Vn(e2), e2 <= 0 || e2 > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (Wn(8, e2) > 32 || Wn(e2, 8) > 32)
    throw new Error("radix2: carry overflow");
  return { encode: (r2) => {
    if (!(r2 instanceof Uint8Array))
      throw new Error("radix2.encode input should be Uint8Array");
    return Zn(Array.from(r2), 8, e2, !t2);
  }, decode: (r2) => {
    if (!Array.isArray(r2) || r2.length && "number" != typeof r2[0])
      throw new Error("radix2.decode input should be array of strings");
    return Uint8Array.from(Zn(r2, e2, 8, t2));
  } };
}
function Xn(e2) {
  if ("function" != typeof e2)
    throw new Error("unsafeWrapper fn should be function");
  return function(...t2) {
    try {
      return e2.apply(null, t2);
    } catch (e3) {
    }
  };
}
var Qn = jn(Yn(4), Fn("0123456789ABCDEF"), Hn(""));
var ei = jn(Yn(5), Fn("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), Kn(5), Hn(""));
jn(Yn(5), Fn("0123456789ABCDEFGHIJKLMNOPQRSTUV"), Kn(5), Hn("")), jn(Yn(5), Fn("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), Hn(""), Gn((e2) => e2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var ti = jn(Yn(6), Fn("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), Kn(6), Hn(""));
var ri = jn(Yn(6), Fn("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), Kn(6), Hn(""));
var ni = (e2) => jn((Vn(58), { encode: (e3) => {
  if (!(e3 instanceof Uint8Array))
    throw new Error("radix.encode input should be Uint8Array");
  return qn(Array.from(e3), 256, 58);
}, decode: (e3) => {
  if (!Array.isArray(e3) || e3.length && "number" != typeof e3[0])
    throw new Error("radix.decode input should be array of strings");
  return Uint8Array.from(qn(e3, 58, 256));
} }), Fn(e2), Hn(""));
var ii = ni("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
ni("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), ni("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var oi = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var si = { encode(e2) {
  let t2 = "";
  for (let r2 = 0; r2 < e2.length; r2 += 8) {
    const n2 = e2.subarray(r2, r2 + 8);
    t2 += ii.encode(n2).padStart(oi[n2.length], "1");
  }
  return t2;
}, decode(e2) {
  let t2 = [];
  for (let r2 = 0; r2 < e2.length; r2 += 11) {
    const n2 = e2.slice(r2, r2 + 11), i2 = oi.indexOf(n2.length), o2 = ii.decode(n2);
    for (let e3 = 0; e3 < o2.length - i2; e3++)
      if (0 !== o2[e3])
        throw new Error("base58xmr: wrong padding");
    t2 = t2.concat(Array.from(o2.slice(o2.length - i2)));
  }
  return Uint8Array.from(t2);
} };
var ai = jn(Fn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), Hn(""));
var ui = [996825010, 642813549, 513874426, 1027748829, 705979059];
function hi(e2) {
  const t2 = e2 >> 25;
  let r2 = (33554431 & e2) << 5;
  for (let e3 = 0; e3 < ui.length; e3++)
    1 == (t2 >> e3 & 1) && (r2 ^= ui[e3]);
  return r2;
}
function fi(e2, t2, r2 = 1) {
  const n2 = e2.length;
  let i2 = 1;
  for (let t3 = 0; t3 < n2; t3++) {
    const r3 = e2.charCodeAt(t3);
    if (r3 < 33 || r3 > 126)
      throw new Error(`Invalid prefix (${e2})`);
    i2 = hi(i2) ^ r3 >> 5;
  }
  i2 = hi(i2);
  for (let t3 = 0; t3 < n2; t3++)
    i2 = hi(i2) ^ 31 & e2.charCodeAt(t3);
  for (let e3 of t2)
    i2 = hi(i2) ^ e3;
  for (let e3 = 0; e3 < 6; e3++)
    i2 = hi(i2);
  return i2 ^= r2, ai.encode(Zn([i2 % 2 ** 30], 30, 5, false));
}
function ci(e2) {
  const t2 = "bech32" === e2 ? 1 : 734539939, r2 = Yn(5), n2 = r2.decode, i2 = r2.encode, o2 = Xn(n2);
  function s2(e3, r3 = 90) {
    if ("string" != typeof e3)
      throw new Error("bech32.decode input should be string, not " + typeof e3);
    if (e3.length < 8 || false !== r3 && e3.length > r3)
      throw new TypeError(`Wrong string length: ${e3.length} (${e3}). Expected (8..${r3})`);
    const n3 = e3.toLowerCase();
    if (e3 !== n3 && e3 !== e3.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    const i3 = (e3 = n3).lastIndexOf("1");
    if (0 === i3 || -1 === i3)
      throw new Error('Letter "1" must be present between prefix and data only');
    const o3 = e3.slice(0, i3), s3 = e3.slice(i3 + 1);
    if (s3.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const a2 = ai.decode(s3).slice(0, -6), u2 = fi(o3, a2, t2);
    if (!s3.endsWith(u2))
      throw new Error(`Invalid checksum in ${e3}: expected "${u2}"`);
    return { prefix: o3, words: a2 };
  }
  return { encode: function(e3, r3, n3 = 90) {
    if ("string" != typeof e3)
      throw new Error("bech32.encode prefix should be string, not " + typeof e3);
    if (!Array.isArray(r3) || r3.length && "number" != typeof r3[0])
      throw new Error("bech32.encode words should be array of numbers, not " + typeof r3);
    const i3 = e3.length + 7 + r3.length;
    if (false !== n3 && i3 > n3)
      throw new TypeError(`Length ${i3} exceeds limit ${n3}`);
    return `${e3 = e3.toLowerCase()}1${ai.encode(r3)}${fi(e3, r3, t2)}`;
  }, decode: s2, decodeToBytes: function(e3) {
    const { prefix: t3, words: r3 } = s2(e3, false);
    return { prefix: t3, words: r3, bytes: n2(r3) };
  }, decodeUnsafe: Xn(s2), fromWords: n2, fromWordsUnsafe: o2, toWords: i2 };
}
ci("bech32"), ci("bech32m");
var li = { encode: (e2) => new TextDecoder().decode(e2), decode: (e2) => new TextEncoder().encode(e2) };
var di = jn(Yn(4), Fn("0123456789abcdef"), Hn(""), Gn((e2) => {
  if ("string" != typeof e2 || e2.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof e2} with length ${e2.length}`);
  return e2.toLowerCase();
}));
Object.keys({ utf8: li, hex: di, base16: Qn, base32: ei, base64: ti, base64url: ri, base58: ii, base58xmr: si }).join(", "), $n.hmacSha256Sync = (e2, ...t2) => ot(Sr, e2, $n.concatBytes(...t2));
var pi = ((e2) => {
  return jn((t2 = (t3) => e2(e2(t3)), Vn(4), { encode(e3) {
    if (!(e3 instanceof Uint8Array))
      throw new Error("checksum.encode: input should be Uint8Array");
    const r2 = t2(e3).slice(0, 4), n2 = new Uint8Array(e3.length + 4);
    return n2.set(e3), n2.set(r2, e3.length), n2;
  }, decode(e3) {
    if (!(e3 instanceof Uint8Array))
      throw new Error("checksum.decode: input should be Uint8Array");
    const r2 = e3.slice(0, -4), n2 = t2(r2).slice(0, 4), i2 = e3.slice(-4);
    for (let e4 = 0; e4 < 4; e4++)
      if (n2[e4] !== i2[e4])
        throw new Error("Invalid checksum");
    return r2;
  } }), ii);
  var t2;
})(Sr);
function yi(e2) {
  return BigInt(`0x${function(e3) {
    if (!(e3 instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let t2 = "";
    for (let r2 = 0; r2 < e3.length; r2++)
      t2 += Te[e3[r2]];
    return t2;
  }(e2)}`);
}
var gi = Se("Bitcoin seed");
var mi = { private: 76066276, public: 76067358 };
var wi = 2147483648;
var bi = (e2) => {
  if (!Number.isSafeInteger(e2) || e2 < 0 || e2 > 2 ** 32 - 1)
    throw new Error(`Invalid number=${e2}. Should be from 0 to 2 ** 32 - 1`);
  const t2 = new Uint8Array(4);
  return Ae(t2).setUint32(0, e2, false), t2;
};
var vi = class {
  constructor(e2) {
    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e2 || "object" != typeof e2)
      throw new Error("HDKey.constructor must not be called directly");
    if (this.versions = e2.versions || mi, this.depth = e2.depth || 0, this.chainCode = e2.chainCode, this.index = e2.index || 0, this.parentFingerprint = e2.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))
      throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
    if (e2.publicKey && e2.privateKey)
      throw new Error("HDKey: publicKey and privateKey at same time.");
    if (e2.privateKey) {
      if (!$n.isValidPrivateKey(e2.privateKey))
        throw new Error("Invalid private key");
      this.privKey = "bigint" == typeof e2.privateKey ? e2.privateKey : yi(e2.privateKey), this.privKeyBytes = function(e3) {
        if ("string" != typeof e3)
          throw new TypeError("hexToBytes: expected string, got " + typeof e3);
        if (e3.length % 2)
          throw new Error("hexToBytes: received invalid unpadded hex");
        const t2 = new Uint8Array(e3.length / 2);
        for (let r2 = 0; r2 < t2.length; r2++) {
          const n2 = 2 * r2, i2 = e3.slice(n2, n2 + 2), o2 = Number.parseInt(i2, 16);
          if (Number.isNaN(o2) || o2 < 0)
            throw new Error("Invalid byte sequence");
          t2[r2] = o2;
        }
        return t2;
      }(this.privKey.toString(16).padStart(64, "0")), this.pubKey = function(e3, t2 = false) {
        return sn.fromPrivateKey(e3).toRawBytes(t2);
      }(e2.privateKey, true);
    } else {
      if (!e2.publicKey)
        throw new Error("HDKey: no public or private key provided");
      this.pubKey = sn.fromHex(e2.publicKey).toRawBytes(true);
    }
    this.pubHash = Fr(Sr(this.pubKey));
  }
  get fingerprint() {
    if (!this.pubHash)
      throw new Error("No publicKey set!");
    return Ae(this.pubHash).getUint32(0, false);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const e2 = this.privateKey;
    if (!e2)
      throw new Error("No private key");
    return pi.encode(this.serialize(this.versions.private, Ie(new Uint8Array([0]), e2)));
  }
  get publicExtendedKey() {
    if (!this.pubKey)
      throw new Error("No public key");
    return pi.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(e2, t2 = mi) {
    if (xe(e2), 8 * e2.length < 128 || 8 * e2.length > 512)
      throw new Error(`HDKey: wrong seed length=${e2.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    const r2 = ot(nt, gi, e2);
    return new vi({ versions: t2, chainCode: r2.slice(32), privateKey: r2.slice(0, 32) });
  }
  static fromExtendedKey(e2, t2 = mi) {
    const r2 = pi.decode(e2), n2 = Ae(r2), i2 = n2.getUint32(0, false), o2 = { versions: t2, depth: r2[4], parentFingerprint: n2.getUint32(5, false), index: n2.getUint32(9, false), chainCode: r2.slice(13, 45) }, s2 = r2.slice(45), a2 = 0 === s2[0];
    if (i2 !== t2[a2 ? "private" : "public"])
      throw new Error("Version mismatch");
    return new vi(a2 ? { ...o2, privateKey: s2.slice(1) } : { ...o2, publicKey: s2 });
  }
  static fromJSON(e2) {
    return vi.fromExtendedKey(e2.xpriv);
  }
  derive(e2) {
    if (!/^[mM]'?/.test(e2))
      throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(e2))
      return this;
    const t2 = e2.replace(/^[mM]'?\//, "").split("/");
    let r2 = this;
    for (const e3 of t2) {
      const t3 = /^(\d+)('?)$/.exec(e3);
      if (!t3 || 3 !== t3.length)
        throw new Error(`Invalid child index: ${e3}`);
      let n2 = +t3[1];
      if (!Number.isSafeInteger(n2) || n2 >= wi)
        throw new Error("Invalid index");
      "'" === t3[2] && (n2 += wi), r2 = r2.deriveChild(n2);
    }
    return r2;
  }
  deriveChild(e2) {
    if (!this.pubKey || !this.chainCode)
      throw new Error("No publicKey or chainCode set");
    let t2 = bi(e2);
    if (e2 >= wi) {
      const e3 = this.privateKey;
      if (!e3)
        throw new Error("Could not derive hardened child key");
      t2 = Ie(new Uint8Array([0]), e3, t2);
    } else
      t2 = Ie(this.pubKey, t2);
    const r2 = ot(nt, this.chainCode, t2), n2 = yi(r2.slice(0, 32)), i2 = r2.slice(32);
    if (!$n.isValidPrivateKey(n2))
      throw new Error("Tweak bigger than curve order");
    const o2 = { versions: this.versions, chainCode: i2, depth: this.depth + 1, parentFingerprint: this.fingerprint, index: e2 };
    try {
      if (this.privateKey) {
        const e3 = $n.mod(this.privKey + n2, Wr.n);
        if (!$n.isValidPrivateKey(e3))
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        o2.privateKey = e3;
      } else {
        const e3 = sn.fromHex(this.pubKey).add(sn.fromPrivateKey(n2));
        if (e3.equals(sn.ZERO))
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        o2.publicKey = e3.toRawBytes(true);
      }
      return new vi(o2);
    } catch (t3) {
      return this.deriveChild(e2 + 1);
    }
  }
  sign(e2) {
    if (!this.privateKey)
      throw new Error("No privateKey set!");
    return xe(e2, 32), function(e3, t2, r2 = {}) {
      const { seed: n2, m: i2, d: o2 } = function(e4, t3, r3) {
        if (null == e4)
          throw new Error(`sign: expected valid message hash, not "${e4}"`);
        const n3 = vn(e4), i3 = Ln(t3), o3 = [Pn(i3), Cn(n3)];
        if (null != r3) {
          true === r3 && (r3 = $n.randomBytes(32));
          const e5 = vn(r3);
          if (32 !== e5.length)
            throw new Error("sign: Expected 32 bytes of extra data");
          o3.push(e5);
        }
        return { seed: fn(...o3), m: Mn(n3), d: i3 };
      }(e3, t2, r2.extraEntropy), s2 = new Nn(32, 32);
      let a2;
      for (s2.reseedSync(n2); !(a2 = Un(s2.generateSync(), i2, o2, r2.canonical)); )
        s2.reseedSync();
      return function(e4, t3) {
        const { sig: r3, recovery: n3 } = e4, { der: i3, recovered: o3 } = Object.assign({ canonical: true, der: true }, t3), s3 = i3 ? r3.toDERRawBytes() : r3.toCompactRawBytes();
        return o3 ? [s3, n3] : s3;
      }(a2, r2);
    }(e2, this.privKey, { canonical: true, der: false });
  }
  verify(e2, t2) {
    if (xe(e2, 32), xe(t2, 64), !this.publicKey)
      throw new Error("No publicKey set!");
    let r2;
    try {
      r2 = hn.fromCompact(t2);
    } catch (e3) {
      return false;
    }
    return function(e3, t3, r3, n2 = Rn) {
      let i2;
      try {
        i2 = kn(e3), t3 = vn(t3);
      } catch (e4) {
        return false;
      }
      const { r: o2, s: s2 } = i2;
      if (n2.strict && i2.hasHighS())
        return false;
      const a2 = _n(t3);
      let u2;
      try {
        u2 = function(e4) {
          return e4 instanceof sn ? (e4.assertValidity(), e4) : sn.fromHex(e4);
        }(r3);
      } catch (e4) {
        return false;
      }
      const { n: h2 } = Wr, f2 = An(s2, h2), c2 = xn(a2 * f2, h2), l2 = xn(o2 * f2, h2), d2 = sn.BASE.multiplyAndAddUnsafe(u2, c2, l2);
      return !!d2 && xn(d2.x, h2) === o2;
    }(r2, e2, this.publicKey);
  }
  wipePrivateData() {
    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;
  }
  toJSON() {
    return { xpriv: this.privateExtendedKey, xpub: this.publicExtendedKey };
  }
  serialize(e2, t2) {
    if (!this.chainCode)
      throw new Error("No chainCode set");
    return xe(t2, 33), Ie(bi(e2), new Uint8Array([this.depth]), bi(this.parentFingerprint), bi(this.index), this.chainCode, t2);
  }
};
vr.hmacSha256Sync = (e2, ...t2) => {
  const r2 = ot.create(Sr, e2);
  return t2.forEach((e3) => r2.update(e3)), r2.digest();
};
var Ei = class {
  constructor(e2) {
    if (this.keypair = void 0, e2)
      this.keypair = e2;
    else {
      const e3 = vr.randomPrivateKey(), t2 = dr(e3, true);
      this.keypair = { publicKey: t2, secretKey: e3 };
    }
  }
  getKeyScheme() {
    return "Secp256k1";
  }
  static generate() {
    const e2 = vr.randomPrivateKey(), t2 = dr(e2, true);
    return new Ei({ publicKey: t2, secretKey: e2 });
  }
  static fromSecretKey(e2) {
    const t2 = dr(e2, true);
    return new Ei({ publicKey: t2, secretKey: e2 });
  }
  static fromSeed(e2) {
    let t2 = dr(e2, true);
    return new Ei({ publicKey: t2, secretKey: e2 });
  }
  getPublicKey() {
    return new Nr(this.keypair.publicKey);
  }
  signData(e2) {
    const t2 = Sr(e2), [r2, n2] = function(e3, t3, r3 = {}) {
      const { seed: n3, m: i3, d: o2 } = function(e4, t4, r4) {
        if (null == e4)
          throw new Error(`sign: expected valid message hash, not "${e4}"`);
        const n4 = Xt(e4), i4 = lr(t4), o3 = [mr(i4), gr(n4)];
        if (null != r4) {
          true === r4 && (r4 = vr.randomBytes(32));
          const e5 = Xt(r4);
          if (32 !== e5.length)
            throw new Error("sign: Expected 32 bytes of extra data");
          o3.push(e5);
        }
        return { seed: jt(...o3), m: yr(n4), d: i4 };
      }(e3, t3, r3.extraEntropy);
      let s2;
      const a2 = new ur();
      for (a2.reseedSync(n3); !(s2 = cr(a2.generateSync(), i3, o2)); )
        a2.reseedSync();
      return function(e4, t4) {
        let { sig: r4, recovery: n4 } = e4;
        const { canonical: i4, der: o3, recovered: s3 } = Object.assign({ canonical: true, der: true }, t4);
        i4 && r4.hasHighS() && (r4 = r4.normalizeS(), n4 ^= 1);
        const a3 = o3 ? r4.toDERRawBytes() : r4.toCompactRawBytes();
        return s3 ? [a3, n4] : a3;
      }(s2, r3);
    }(t2, this.keypair.secretKey, { canonical: true, recovered: true });
    var i2 = new Uint8Array(99);
    return i2[0] = 1, i2.set(Vt.fromDER(r2).toCompactRawBytes(), 1), i2.set([n2], 65), i2.set(this.keypair.publicKey, 66), i2;
  }
  static deriveKeypair(e2, t2) {
    if (null == t2 && (t2 = "m/54'/784'/0'/0/0"), !function(e3) {
      return !!new RegExp("^m\\/54'\\/784'\\/[0-9]+'\\/[0-9]+\\/[0-9]+$").test(e3);
    }(t2))
      throw new Error("Invalid derivation path");
    const r2 = vi.fromMasterSeed(_t(e2)).derive(t2);
    if (null == r2.publicKey || null == r2.privateKey)
      throw new Error("Invalid key");
    return new Ei({ publicKey: r2.publicKey, secretKey: r2.privateKey });
  }
  export() {
    return { schema: "Secp256k1", privateKey: lt(this.keypair.secretKey) };
  }
};
var xi = "_db3_wallet_key_";
var Bi = "_db3_wallet_ADDR_";
var Ai = class {
  constructor(e2, t2) {
    this.keypair = void 0, this.walletType = void 0, this.keypair = e2, this.walletType = t2;
  }
  sign(e2) {
    return this.keypair.signData(e2);
  }
  getAddress() {
    return this.keypair.getPublicKey().toAddress();
  }
  static hasKey() {
    var e2;
    return !!JSON.parse(null != (e2 = localStorage.getItem(xi)) ? e2 : "{}").hasOwnProperty("schema");
  }
  getType() {
    return this.walletType;
  }
  static recover() {
    var e2;
    const t2 = JSON.parse(null != (e2 = localStorage.getItem(xi)) ? e2 : "{}");
    if (!t2.hasOwnProperty("schema"))
      throw new Error("no key in browser");
    if ("Secp256k1" == t2.schema) {
      const e3 = ft(t2.privateKey);
      return new Ai(Ei.fromSecretKey(e3), "DB3_SECP256K1");
    }
    if ("ED25519" == t2.schema) {
      const e3 = ft(t2.privateKey);
      return new Ai(Tt.fromSecretKey(e3), "DB3_ED25519");
    }
    throw new Error("no key in browser");
  }
  static generate(e2) {
    if ("DB3_ED25519" === e2) {
      const t2 = Tt.generate(), r2 = new Ai(t2, e2);
      return localStorage.setItem(xi, JSON.stringify(t2.export())), localStorage.setItem(Bi, r2.getAddress()), r2;
    }
    if ("DB3_SECP256K1" === e2) {
      const t2 = Ei.generate(), r2 = new Ai(t2, e2);
      return localStorage.setItem(xi, JSON.stringify(t2.export())), localStorage.setItem(Bi, r2.getAddress()), r2;
    }
    throw new Error("wallet type is not supported");
  }
  static createNew(e2, t2) {
    if ("DB3_ED25519" === t2) {
      const r2 = Tt.deriveKeypair(e2);
      return localStorage.setItem(xi, JSON.stringify(r2.export())), new Ai(r2, t2);
    }
    if ("DB3_SECP256K1" === t2) {
      const r2 = Ei.deriveKeypair(e2);
      return localStorage.setItem(xi, JSON.stringify(r2.export())), new Ai(r2, t2);
    }
    throw new Error("wallet type is not supported");
  }
};
for (_i = [], Ti = [], Si = "undefined" != typeof Uint8Array ? Uint8Array : Array, Ni = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ii = 0, Oi = Ni.length; Ii < Oi; ++Ii)
  _i[Ii] = Ni[Ii], Ti[Ni.charCodeAt(Ii)] = Ii;
var _i;
var Ti;
var Si;
var Ni;
var Ii;
var Oi;
function Ui(e2, t2, r2) {
  for (var n2, i2 = [], o2 = t2; o2 < r2; o2 += 3)
    i2.push(_i[(n2 = (e2[o2] << 16 & 16711680) + (e2[o2 + 1] << 8 & 65280) + (255 & e2[o2 + 2])) >> 18 & 63] + _i[n2 >> 12 & 63] + _i[n2 >> 6 & 63] + _i[63 & n2]);
  return i2.join("");
}
Ti["-".charCodeAt(0)] = 62, Ti["_".charCodeAt(0)] = 63;
var Li;
var ki = function(e2, t2, r2, n2, i2) {
  var o2, s2, a2 = 8 * i2 - n2 - 1, u2 = (1 << a2) - 1, h2 = u2 >> 1, f2 = -7, c2 = r2 ? i2 - 1 : 0, l2 = r2 ? -1 : 1, d2 = e2[t2 + c2];
  for (c2 += l2, o2 = d2 & (1 << -f2) - 1, d2 >>= -f2, f2 += a2; f2 > 0; o2 = 256 * o2 + e2[t2 + c2], c2 += l2, f2 -= 8)
    ;
  for (s2 = o2 & (1 << -f2) - 1, o2 >>= -f2, f2 += n2; f2 > 0; s2 = 256 * s2 + e2[t2 + c2], c2 += l2, f2 -= 8)
    ;
  if (0 === o2)
    o2 = 1 - h2;
  else {
    if (o2 === u2)
      return s2 ? NaN : Infinity * (d2 ? -1 : 1);
    s2 += Math.pow(2, n2), o2 -= h2;
  }
  return (d2 ? -1 : 1) * s2 * Math.pow(2, o2 - n2);
};
var Mi = function(e2, t2, r2, n2, i2, o2) {
  var s2, a2, u2, h2 = 8 * o2 - i2 - 1, f2 = (1 << h2) - 1, c2 = f2 >> 1, l2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = n2 ? 0 : o2 - 1, p2 = n2 ? 1 : -1, y2 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
  for (t2 = Math.abs(t2), isNaN(t2) || Infinity === t2 ? (a2 = isNaN(t2) ? 1 : 0, s2 = f2) : (s2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (u2 = Math.pow(2, -s2)) < 1 && (s2--, u2 *= 2), (t2 += s2 + c2 >= 1 ? l2 / u2 : l2 * Math.pow(2, 1 - c2)) * u2 >= 2 && (s2++, u2 /= 2), s2 + c2 >= f2 ? (a2 = 0, s2 = f2) : s2 + c2 >= 1 ? (a2 = (t2 * u2 - 1) * Math.pow(2, i2), s2 += c2) : (a2 = t2 * Math.pow(2, c2 - 1) * Math.pow(2, i2), s2 = 0)); i2 >= 8; e2[r2 + d2] = 255 & a2, d2 += p2, a2 /= 256, i2 -= 8)
    ;
  for (s2 = s2 << i2 | a2, h2 += i2; h2 > 0; e2[r2 + d2] = 255 & s2, d2 += p2, s2 /= 256, h2 -= 8)
    ;
  e2[r2 + d2 - p2] |= 128 * y2;
};
var Ci = ye(function(e2, t2) {
  const r2 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
  t2.Buffer = o2, t2.SlowBuffer = function(e3) {
    return +e3 != e3 && (e3 = 0), o2.alloc(+e3);
  }, t2.INSPECT_MAX_BYTES = 50;
  const n2 = 2147483647;
  function i2(e3) {
    if (e3 > n2)
      throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
    const t3 = new Uint8Array(e3);
    return Object.setPrototypeOf(t3, o2.prototype), t3;
  }
  function o2(e3, t3, r3) {
    if ("number" == typeof e3) {
      if ("string" == typeof t3)
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return u2(e3);
    }
    return s2(e3, t3, r3);
  }
  function s2(e3, t3, r3) {
    if ("string" == typeof e3)
      return function(e4, t4) {
        if ("string" == typeof t4 && "" !== t4 || (t4 = "utf8"), !o2.isEncoding(t4))
          throw new TypeError("Unknown encoding: " + t4);
        const r4 = 0 | l2(e4, t4);
        let n4 = i2(r4);
        const s4 = n4.write(e4, t4);
        return s4 !== r4 && (n4 = n4.slice(0, s4)), n4;
      }(e3, t3);
    if (ArrayBuffer.isView(e3))
      return function(e4) {
        if (G2(e4, Uint8Array)) {
          const t4 = new Uint8Array(e4);
          return f2(t4.buffer, t4.byteOffset, t4.byteLength);
        }
        return h2(e4);
      }(e3);
    if (null == e3)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
    if (G2(e3, ArrayBuffer) || e3 && G2(e3.buffer, ArrayBuffer))
      return f2(e3, t3, r3);
    if ("undefined" != typeof SharedArrayBuffer && (G2(e3, SharedArrayBuffer) || e3 && G2(e3.buffer, SharedArrayBuffer)))
      return f2(e3, t3, r3);
    if ("number" == typeof e3)
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const n3 = e3.valueOf && e3.valueOf();
    if (null != n3 && n3 !== e3)
      return o2.from(n3, t3, r3);
    const s3 = function(e4) {
      if (o2.isBuffer(e4)) {
        const t4 = 0 | c2(e4.length), r4 = i2(t4);
        return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
      }
      return void 0 !== e4.length ? "number" != typeof e4.length || q2(e4.length) ? i2(0) : h2(e4) : "Buffer" === e4.type && Array.isArray(e4.data) ? h2(e4.data) : void 0;
    }(e3);
    if (s3)
      return s3;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive])
      return o2.from(e3[Symbol.toPrimitive]("string"), t3, r3);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
  }
  function a2(e3) {
    if ("number" != typeof e3)
      throw new TypeError('"size" argument must be of type number');
    if (e3 < 0)
      throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
  }
  function u2(e3) {
    return a2(e3), i2(e3 < 0 ? 0 : 0 | c2(e3));
  }
  function h2(e3) {
    const t3 = e3.length < 0 ? 0 : 0 | c2(e3.length), r3 = i2(t3);
    for (let n3 = 0; n3 < t3; n3 += 1)
      r3[n3] = 255 & e3[n3];
    return r3;
  }
  function f2(e3, t3, r3) {
    if (t3 < 0 || e3.byteLength < t3)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e3.byteLength < t3 + (r3 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n3;
    return n3 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n3, o2.prototype), n3;
  }
  function c2(e3) {
    if (e3 >= n2)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n2.toString(16) + " bytes");
    return 0 | e3;
  }
  function l2(e3, t3) {
    if (o2.isBuffer(e3))
      return e3.length;
    if (ArrayBuffer.isView(e3) || G2(e3, ArrayBuffer))
      return e3.byteLength;
    if ("string" != typeof e3)
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
    const r3 = e3.length, n3 = arguments.length > 2 && true === arguments[2];
    if (!n3 && 0 === r3)
      return 0;
    let i3 = false;
    for (; ; )
      switch (t3) {
        case "ascii":
        case "latin1":
        case "binary":
          return r3;
        case "utf8":
        case "utf-8":
          return F2(e3).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * r3;
        case "hex":
          return r3 >>> 1;
        case "base64":
          return H2(e3).length;
        default:
          if (i3)
            return n3 ? -1 : F2(e3).length;
          t3 = ("" + t3).toLowerCase(), i3 = true;
      }
  }
  function d2(e3, t3, r3) {
    let n3 = false;
    if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length)
      return "";
    if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0)
      return "";
    if ((r3 >>>= 0) <= (t3 >>>= 0))
      return "";
    for (e3 || (e3 = "utf8"); ; )
      switch (e3) {
        case "hex":
          return S2(this, t3, r3);
        case "utf8":
        case "utf-8":
          return B2(this, t3, r3);
        case "ascii":
          return _2(this, t3, r3);
        case "latin1":
        case "binary":
          return T2(this, t3, r3);
        case "base64":
          return x2(this, t3, r3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N2(this, t3, r3);
        default:
          if (n3)
            throw new TypeError("Unknown encoding: " + e3);
          e3 = (e3 + "").toLowerCase(), n3 = true;
      }
  }
  function p2(e3, t3, r3) {
    const n3 = e3[t3];
    e3[t3] = e3[r3], e3[r3] = n3;
  }
  function y2(e3, t3, r3, n3, i3) {
    if (0 === e3.length)
      return -1;
    if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), q2(r3 = +r3) && (r3 = i3 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
      if (i3)
        return -1;
      r3 = e3.length - 1;
    } else if (r3 < 0) {
      if (!i3)
        return -1;
      r3 = 0;
    }
    if ("string" == typeof t3 && (t3 = o2.from(t3, n3)), o2.isBuffer(t3))
      return 0 === t3.length ? -1 : g2(e3, t3, r3, n3, i3);
    if ("number" == typeof t3)
      return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i3 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : g2(e3, [t3], r3, n3, i3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function g2(e3, t3, r3, n3, i3) {
    let o3, s3 = 1, a3 = e3.length, u3 = t3.length;
    if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
      if (e3.length < 2 || t3.length < 2)
        return -1;
      s3 = 2, a3 /= 2, u3 /= 2, r3 /= 2;
    }
    function h3(e4, t4) {
      return 1 === s3 ? e4[t4] : e4.readUInt16BE(t4 * s3);
    }
    if (i3) {
      let n4 = -1;
      for (o3 = r3; o3 < a3; o3++)
        if (h3(e3, o3) === h3(t3, -1 === n4 ? 0 : o3 - n4)) {
          if (-1 === n4 && (n4 = o3), o3 - n4 + 1 === u3)
            return n4 * s3;
        } else
          -1 !== n4 && (o3 -= o3 - n4), n4 = -1;
    } else
      for (r3 + u3 > a3 && (r3 = a3 - u3), o3 = r3; o3 >= 0; o3--) {
        let r4 = true;
        for (let n4 = 0; n4 < u3; n4++)
          if (h3(e3, o3 + n4) !== h3(t3, n4)) {
            r4 = false;
            break;
          }
        if (r4)
          return o3;
      }
    return -1;
  }
  function m2(e3, t3, r3, n3) {
    r3 = Number(r3) || 0;
    const i3 = e3.length - r3;
    n3 ? (n3 = Number(n3)) > i3 && (n3 = i3) : n3 = i3;
    const o3 = t3.length;
    let s3;
    for (n3 > o3 / 2 && (n3 = o3 / 2), s3 = 0; s3 < n3; ++s3) {
      const n4 = parseInt(t3.substr(2 * s3, 2), 16);
      if (q2(n4))
        return s3;
      e3[r3 + s3] = n4;
    }
    return s3;
  }
  function w2(e3, t3, r3, n3) {
    return K2(F2(t3, e3.length - r3), e3, r3, n3);
  }
  function b2(e3, t3, r3, n3) {
    return K2(function(e4) {
      const t4 = [];
      for (let r4 = 0; r4 < e4.length; ++r4)
        t4.push(255 & e4.charCodeAt(r4));
      return t4;
    }(t3), e3, r3, n3);
  }
  function v2(e3, t3, r3, n3) {
    return K2(H2(t3), e3, r3, n3);
  }
  function E2(e3, t3, r3, n3) {
    return K2(function(e4, t4) {
      let r4, n4, i3;
      const o3 = [];
      for (let s3 = 0; s3 < e4.length && !((t4 -= 2) < 0); ++s3)
        r4 = e4.charCodeAt(s3), n4 = r4 >> 8, i3 = r4 % 256, o3.push(i3), o3.push(n4);
      return o3;
    }(t3, e3.length - r3), e3, r3, n3);
  }
  function x2(e3, t3, r3) {
    return function(e4) {
      for (var t4, r4 = e4.length, n3 = r4 % 3, i3 = [], o3 = 16383, s3 = 0, a3 = r4 - n3; s3 < a3; s3 += o3)
        i3.push(Ui(e4, s3, s3 + o3 > a3 ? a3 : s3 + o3));
      return 1 === n3 ? i3.push(_i[(t4 = e4[r4 - 1]) >> 2] + _i[t4 << 4 & 63] + "==") : 2 === n3 && i3.push(_i[(t4 = (e4[r4 - 2] << 8) + e4[r4 - 1]) >> 10] + _i[t4 >> 4 & 63] + _i[t4 << 2 & 63] + "="), i3.join("");
    }(0 === t3 && r3 === e3.length ? e3 : e3.slice(t3, r3));
  }
  function B2(e3, t3, r3) {
    r3 = Math.min(e3.length, r3);
    const n3 = [];
    let i3 = t3;
    for (; i3 < r3; ) {
      const t4 = e3[i3];
      let o3 = null, s3 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
      if (i3 + s3 <= r3) {
        let r4, n4, a3, u3;
        switch (s3) {
          case 1:
            t4 < 128 && (o3 = t4);
            break;
          case 2:
            r4 = e3[i3 + 1], 128 == (192 & r4) && (u3 = (31 & t4) << 6 | 63 & r4, u3 > 127 && (o3 = u3));
            break;
          case 3:
            r4 = e3[i3 + 1], n4 = e3[i3 + 2], 128 == (192 & r4) && 128 == (192 & n4) && (u3 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n4, u3 > 2047 && (u3 < 55296 || u3 > 57343) && (o3 = u3));
            break;
          case 4:
            r4 = e3[i3 + 1], n4 = e3[i3 + 2], a3 = e3[i3 + 3], 128 == (192 & r4) && 128 == (192 & n4) && 128 == (192 & a3) && (u3 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n4) << 6 | 63 & a3, u3 > 65535 && u3 < 1114112 && (o3 = u3));
        }
      }
      null === o3 ? (o3 = 65533, s3 = 1) : o3 > 65535 && (o3 -= 65536, n3.push(o3 >>> 10 & 1023 | 55296), o3 = 56320 | 1023 & o3), n3.push(o3), i3 += s3;
    }
    return function(e4) {
      const t4 = e4.length;
      if (t4 <= A2)
        return String.fromCharCode.apply(String, e4);
      let r4 = "", n4 = 0;
      for (; n4 < t4; )
        r4 += String.fromCharCode.apply(String, e4.slice(n4, n4 += A2));
      return r4;
    }(n3);
  }
  t2.kMaxLength = n2, (o2.TYPED_ARRAY_SUPPORT = function() {
    try {
      const e3 = new Uint8Array(1), t3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
    } catch (e3) {
      return false;
    }
  }()) || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(o2.prototype, "parent", { enumerable: true, get: function() {
    if (o2.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(o2.prototype, "offset", { enumerable: true, get: function() {
    if (o2.isBuffer(this))
      return this.byteOffset;
  } }), o2.poolSize = 8192, o2.from = function(e3, t3, r3) {
    return s2(e3, t3, r3);
  }, Object.setPrototypeOf(o2.prototype, Uint8Array.prototype), Object.setPrototypeOf(o2, Uint8Array), o2.alloc = function(e3, t3, r3) {
    return function(e4, t4, r4) {
      return a2(e4), e4 <= 0 ? i2(e4) : void 0 !== t4 ? "string" == typeof r4 ? i2(e4).fill(t4, r4) : i2(e4).fill(t4) : i2(e4);
    }(e3, t3, r3);
  }, o2.allocUnsafe = function(e3) {
    return u2(e3);
  }, o2.allocUnsafeSlow = function(e3) {
    return u2(e3);
  }, o2.isBuffer = function(e3) {
    return null != e3 && true === e3._isBuffer && e3 !== o2.prototype;
  }, o2.compare = function(e3, t3) {
    if (G2(e3, Uint8Array) && (e3 = o2.from(e3, e3.offset, e3.byteLength)), G2(t3, Uint8Array) && (t3 = o2.from(t3, t3.offset, t3.byteLength)), !o2.isBuffer(e3) || !o2.isBuffer(t3))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t3)
      return 0;
    let r3 = e3.length, n3 = t3.length;
    for (let i3 = 0, o3 = Math.min(r3, n3); i3 < o3; ++i3)
      if (e3[i3] !== t3[i3]) {
        r3 = e3[i3], n3 = t3[i3];
        break;
      }
    return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
  }, o2.isEncoding = function(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, o2.concat = function(e3, t3) {
    if (!Array.isArray(e3))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e3.length)
      return o2.alloc(0);
    let r3;
    if (void 0 === t3)
      for (t3 = 0, r3 = 0; r3 < e3.length; ++r3)
        t3 += e3[r3].length;
    const n3 = o2.allocUnsafe(t3);
    let i3 = 0;
    for (r3 = 0; r3 < e3.length; ++r3) {
      let t4 = e3[r3];
      if (G2(t4, Uint8Array))
        i3 + t4.length > n3.length ? (o2.isBuffer(t4) || (t4 = o2.from(t4)), t4.copy(n3, i3)) : Uint8Array.prototype.set.call(n3, t4, i3);
      else {
        if (!o2.isBuffer(t4))
          throw new TypeError('"list" argument must be an Array of Buffers');
        t4.copy(n3, i3);
      }
      i3 += t4.length;
    }
    return n3;
  }, o2.byteLength = l2, o2.prototype._isBuffer = true, o2.prototype.swap16 = function() {
    const e3 = this.length;
    if (e3 % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t3 = 0; t3 < e3; t3 += 2)
      p2(this, t3, t3 + 1);
    return this;
  }, o2.prototype.swap32 = function() {
    const e3 = this.length;
    if (e3 % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t3 = 0; t3 < e3; t3 += 4)
      p2(this, t3, t3 + 3), p2(this, t3 + 1, t3 + 2);
    return this;
  }, o2.prototype.swap64 = function() {
    const e3 = this.length;
    if (e3 % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t3 = 0; t3 < e3; t3 += 8)
      p2(this, t3, t3 + 7), p2(this, t3 + 1, t3 + 6), p2(this, t3 + 2, t3 + 5), p2(this, t3 + 3, t3 + 4);
    return this;
  }, o2.prototype.toString = function() {
    const e3 = this.length;
    return 0 === e3 ? "" : 0 === arguments.length ? B2(this, 0, e3) : d2.apply(this, arguments);
  }, o2.prototype.toLocaleString = o2.prototype.toString, o2.prototype.equals = function(e3) {
    if (!o2.isBuffer(e3))
      throw new TypeError("Argument must be a Buffer");
    return this === e3 || 0 === o2.compare(this, e3);
  }, o2.prototype.inspect = function() {
    let e3 = "";
    const r3 = t2.INSPECT_MAX_BYTES;
    return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
  }, r2 && (o2.prototype[r2] = o2.prototype.inspect), o2.prototype.compare = function(e3, t3, r3, n3, i3) {
    if (G2(e3, Uint8Array) && (e3 = o2.from(e3, e3.offset, e3.byteLength)), !o2.isBuffer(e3))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n3 && (n3 = 0), void 0 === i3 && (i3 = this.length), t3 < 0 || r3 > e3.length || n3 < 0 || i3 > this.length)
      throw new RangeError("out of range index");
    if (n3 >= i3 && t3 >= r3)
      return 0;
    if (n3 >= i3)
      return -1;
    if (t3 >= r3)
      return 1;
    if (this === e3)
      return 0;
    let s3 = (i3 >>>= 0) - (n3 >>>= 0), a3 = (r3 >>>= 0) - (t3 >>>= 0);
    const u3 = Math.min(s3, a3), h3 = this.slice(n3, i3), f3 = e3.slice(t3, r3);
    for (let e4 = 0; e4 < u3; ++e4)
      if (h3[e4] !== f3[e4]) {
        s3 = h3[e4], a3 = f3[e4];
        break;
      }
    return s3 < a3 ? -1 : a3 < s3 ? 1 : 0;
  }, o2.prototype.includes = function(e3, t3, r3) {
    return -1 !== this.indexOf(e3, t3, r3);
  }, o2.prototype.indexOf = function(e3, t3, r3) {
    return y2(this, e3, t3, r3, true);
  }, o2.prototype.lastIndexOf = function(e3, t3, r3) {
    return y2(this, e3, t3, r3, false);
  }, o2.prototype.write = function(e3, t3, r3, n3) {
    if (void 0 === t3)
      n3 = "utf8", r3 = this.length, t3 = 0;
    else if (void 0 === r3 && "string" == typeof t3)
      n3 = t3, r3 = this.length, t3 = 0;
    else {
      if (!isFinite(t3))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
    }
    const i3 = this.length - t3;
    if ((void 0 === r3 || r3 > i3) && (r3 = i3), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    n3 || (n3 = "utf8");
    let o3 = false;
    for (; ; )
      switch (n3) {
        case "hex":
          return m2(this, e3, t3, r3);
        case "utf8":
        case "utf-8":
          return w2(this, e3, t3, r3);
        case "ascii":
        case "latin1":
        case "binary":
          return b2(this, e3, t3, r3);
        case "base64":
          return v2(this, e3, t3, r3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return E2(this, e3, t3, r3);
        default:
          if (o3)
            throw new TypeError("Unknown encoding: " + n3);
          n3 = ("" + n3).toLowerCase(), o3 = true;
      }
  }, o2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const A2 = 4096;
  function _2(e3, t3, r3) {
    let n3 = "";
    r3 = Math.min(e3.length, r3);
    for (let i3 = t3; i3 < r3; ++i3)
      n3 += String.fromCharCode(127 & e3[i3]);
    return n3;
  }
  function T2(e3, t3, r3) {
    let n3 = "";
    r3 = Math.min(e3.length, r3);
    for (let i3 = t3; i3 < r3; ++i3)
      n3 += String.fromCharCode(e3[i3]);
    return n3;
  }
  function S2(e3, t3, r3) {
    const n3 = e3.length;
    (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
    let i3 = "";
    for (let n4 = t3; n4 < r3; ++n4)
      i3 += J2[e3[n4]];
    return i3;
  }
  function N2(e3, t3, r3) {
    const n3 = e3.slice(t3, r3);
    let i3 = "";
    for (let e4 = 0; e4 < n3.length - 1; e4 += 2)
      i3 += String.fromCharCode(n3[e4] + 256 * n3[e4 + 1]);
    return i3;
  }
  function I2(e3, t3, r3) {
    if (e3 % 1 != 0 || e3 < 0)
      throw new RangeError("offset is not uint");
    if (e3 + t3 > r3)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function O2(e3, t3, r3, n3, i3, s3) {
    if (!o2.isBuffer(e3))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t3 > i3 || t3 < s3)
      throw new RangeError('"value" argument is out of bounds');
    if (r3 + n3 > e3.length)
      throw new RangeError("Index out of range");
  }
  function U2(e3, t3, r3, n3, i3) {
    z2(t3, n3, i3, e3, r3, 7);
    let o3 = Number(t3 & BigInt(4294967295));
    e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3;
    let s3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3++] = s3, s3 >>= 8, e3[r3++] = s3, s3 >>= 8, e3[r3++] = s3, s3 >>= 8, e3[r3++] = s3, r3;
  }
  function L2(e3, t3, r3, n3, i3) {
    z2(t3, n3, i3, e3, r3, 7);
    let o3 = Number(t3 & BigInt(4294967295));
    e3[r3 + 7] = o3, o3 >>= 8, e3[r3 + 6] = o3, o3 >>= 8, e3[r3 + 5] = o3, o3 >>= 8, e3[r3 + 4] = o3;
    let s3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3 + 3] = s3, s3 >>= 8, e3[r3 + 2] = s3, s3 >>= 8, e3[r3 + 1] = s3, s3 >>= 8, e3[r3] = s3, r3 + 8;
  }
  function k2(e3, t3, r3, n3, i3, o3) {
    if (r3 + n3 > e3.length)
      throw new RangeError("Index out of range");
    if (r3 < 0)
      throw new RangeError("Index out of range");
  }
  function M2(e3, t3, r3, n3, i3) {
    return t3 = +t3, r3 >>>= 0, i3 || k2(e3, 0, r3, 4), Mi(e3, t3, r3, n3, 23, 4), r3 + 4;
  }
  function C2(e3, t3, r3, n3, i3) {
    return t3 = +t3, r3 >>>= 0, i3 || k2(e3, 0, r3, 8), Mi(e3, t3, r3, n3, 52, 8), r3 + 8;
  }
  o2.prototype.slice = function(e3, t3) {
    const r3 = this.length;
    (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
    const n3 = this.subarray(e3, t3);
    return Object.setPrototypeOf(n3, o2.prototype), n3;
  }, o2.prototype.readUintLE = o2.prototype.readUIntLE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || I2(e3, t3, this.length);
    let n3 = this[e3], i3 = 1, o3 = 0;
    for (; ++o3 < t3 && (i3 *= 256); )
      n3 += this[e3 + o3] * i3;
    return n3;
  }, o2.prototype.readUintBE = o2.prototype.readUIntBE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || I2(e3, t3, this.length);
    let n3 = this[e3 + --t3], i3 = 1;
    for (; t3 > 0 && (i3 *= 256); )
      n3 += this[e3 + --t3] * i3;
    return n3;
  }, o2.prototype.readUint8 = o2.prototype.readUInt8 = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 1, this.length), this[e3];
  }, o2.prototype.readUint16LE = o2.prototype.readUInt16LE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  }, o2.prototype.readUint16BE = o2.prototype.readUInt16BE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  }, o2.prototype.readUint32LE = o2.prototype.readUInt32LE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
  }, o2.prototype.readUint32BE = o2.prototype.readUInt32BE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  }, o2.prototype.readBigUInt64LE = W2(function(e3) {
    $2(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || V2(e3, this.length - 8);
    const n3 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, i3 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
    return BigInt(n3) + (BigInt(i3) << BigInt(32));
  }), o2.prototype.readBigUInt64BE = W2(function(e3) {
    $2(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || V2(e3, this.length - 8);
    const n3 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], i3 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
    return (BigInt(n3) << BigInt(32)) + BigInt(i3);
  }), o2.prototype.readIntLE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || I2(e3, t3, this.length);
    let n3 = this[e3], i3 = 1, o3 = 0;
    for (; ++o3 < t3 && (i3 *= 256); )
      n3 += this[e3 + o3] * i3;
    return i3 *= 128, n3 >= i3 && (n3 -= Math.pow(2, 8 * t3)), n3;
  }, o2.prototype.readIntBE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || I2(e3, t3, this.length);
    let n3 = t3, i3 = 1, o3 = this[e3 + --n3];
    for (; n3 > 0 && (i3 *= 256); )
      o3 += this[e3 + --n3] * i3;
    return i3 *= 128, o3 >= i3 && (o3 -= Math.pow(2, 8 * t3)), o3;
  }, o2.prototype.readInt8 = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
  }, o2.prototype.readInt16LE = function(e3, t3) {
    e3 >>>= 0, t3 || I2(e3, 2, this.length);
    const r3 = this[e3] | this[e3 + 1] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, o2.prototype.readInt16BE = function(e3, t3) {
    e3 >>>= 0, t3 || I2(e3, 2, this.length);
    const r3 = this[e3 + 1] | this[e3] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, o2.prototype.readInt32LE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  }, o2.prototype.readInt32BE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  }, o2.prototype.readBigInt64LE = W2(function(e3) {
    $2(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    return void 0 !== t3 && void 0 !== r3 || V2(e3, this.length - 8), (BigInt(this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24)) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
  }), o2.prototype.readBigInt64BE = W2(function(e3) {
    $2(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || V2(e3, this.length - 8);
    const n3 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
    return (BigInt(n3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
  }), o2.prototype.readFloatLE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 4, this.length), ki(this, e3, true, 23, 4);
  }, o2.prototype.readFloatBE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 4, this.length), ki(this, e3, false, 23, 4);
  }, o2.prototype.readDoubleLE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 8, this.length), ki(this, e3, true, 52, 8);
  }, o2.prototype.readDoubleBE = function(e3, t3) {
    return e3 >>>= 0, t3 || I2(e3, 8, this.length), ki(this, e3, false, 52, 8);
  }, o2.prototype.writeUintLE = o2.prototype.writeUIntLE = function(e3, t3, r3, n3) {
    e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || O2(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    let i3 = 1, o3 = 0;
    for (this[t3] = 255 & e3; ++o3 < r3 && (i3 *= 256); )
      this[t3 + o3] = e3 / i3 & 255;
    return t3 + r3;
  }, o2.prototype.writeUintBE = o2.prototype.writeUIntBE = function(e3, t3, r3, n3) {
    e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || O2(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    let i3 = r3 - 1, o3 = 1;
    for (this[t3 + i3] = 255 & e3; --i3 >= 0 && (o3 *= 256); )
      this[t3 + i3] = e3 / o3 & 255;
    return t3 + r3;
  }, o2.prototype.writeUint8 = o2.prototype.writeUInt8 = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
  }, o2.prototype.writeUint16LE = o2.prototype.writeUInt16LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, o2.prototype.writeUint16BE = o2.prototype.writeUInt16BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, o2.prototype.writeUint32LE = o2.prototype.writeUInt32LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
  }, o2.prototype.writeUint32BE = o2.prototype.writeUInt32BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, o2.prototype.writeBigUInt64LE = W2(function(e3, t3 = 0) {
    return U2(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o2.prototype.writeBigUInt64BE = W2(function(e3, t3 = 0) {
    return L2(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o2.prototype.writeIntLE = function(e3, t3, r3, n3) {
    if (e3 = +e3, t3 >>>= 0, !n3) {
      const n4 = Math.pow(2, 8 * r3 - 1);
      O2(this, e3, t3, r3, n4 - 1, -n4);
    }
    let i3 = 0, o3 = 1, s3 = 0;
    for (this[t3] = 255 & e3; ++i3 < r3 && (o3 *= 256); )
      e3 < 0 && 0 === s3 && 0 !== this[t3 + i3 - 1] && (s3 = 1), this[t3 + i3] = (e3 / o3 >> 0) - s3 & 255;
    return t3 + r3;
  }, o2.prototype.writeIntBE = function(e3, t3, r3, n3) {
    if (e3 = +e3, t3 >>>= 0, !n3) {
      const n4 = Math.pow(2, 8 * r3 - 1);
      O2(this, e3, t3, r3, n4 - 1, -n4);
    }
    let i3 = r3 - 1, o3 = 1, s3 = 0;
    for (this[t3 + i3] = 255 & e3; --i3 >= 0 && (o3 *= 256); )
      e3 < 0 && 0 === s3 && 0 !== this[t3 + i3 + 1] && (s3 = 1), this[t3 + i3] = (e3 / o3 >> 0) - s3 & 255;
    return t3 + r3;
  }, o2.prototype.writeInt8 = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
  }, o2.prototype.writeInt16LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, o2.prototype.writeInt16BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, o2.prototype.writeInt32LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
  }, o2.prototype.writeInt32BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || O2(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, o2.prototype.writeBigInt64LE = W2(function(e3, t3 = 0) {
    return U2(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o2.prototype.writeBigInt64BE = W2(function(e3, t3 = 0) {
    return L2(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o2.prototype.writeFloatLE = function(e3, t3, r3) {
    return M2(this, e3, t3, true, r3);
  }, o2.prototype.writeFloatBE = function(e3, t3, r3) {
    return M2(this, e3, t3, false, r3);
  }, o2.prototype.writeDoubleLE = function(e3, t3, r3) {
    return C2(this, e3, t3, true, r3);
  }, o2.prototype.writeDoubleBE = function(e3, t3, r3) {
    return C2(this, e3, t3, false, r3);
  }, o2.prototype.copy = function(e3, t3, r3, n3) {
    if (!o2.isBuffer(e3))
      throw new TypeError("argument should be a Buffer");
    if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3)
      return 0;
    if (0 === e3.length || 0 === this.length)
      return 0;
    if (t3 < 0)
      throw new RangeError("targetStart out of bounds");
    if (r3 < 0 || r3 >= this.length)
      throw new RangeError("Index out of range");
    if (n3 < 0)
      throw new RangeError("sourceEnd out of bounds");
    n3 > this.length && (n3 = this.length), e3.length - t3 < n3 - r3 && (n3 = e3.length - t3 + r3);
    const i3 = n3 - r3;
    return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, r3, n3) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n3), t3), i3;
  }, o2.prototype.fill = function(e3, t3, r3, n3) {
    if ("string" == typeof e3) {
      if ("string" == typeof t3 ? (n3 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), void 0 !== n3 && "string" != typeof n3)
        throw new TypeError("encoding must be a string");
      if ("string" == typeof n3 && !o2.isEncoding(n3))
        throw new TypeError("Unknown encoding: " + n3);
      if (1 === e3.length) {
        const t4 = e3.charCodeAt(0);
        ("utf8" === n3 && t4 < 128 || "latin1" === n3) && (e3 = t4);
      }
    } else
      "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
    if (t3 < 0 || this.length < t3 || this.length < r3)
      throw new RangeError("Out of range index");
    if (r3 <= t3)
      return this;
    let i3;
    if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3)
      for (i3 = t3; i3 < r3; ++i3)
        this[i3] = e3;
    else {
      const s3 = o2.isBuffer(e3) ? e3 : o2.from(e3, n3), a3 = s3.length;
      if (0 === a3)
        throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
      for (i3 = 0; i3 < r3 - t3; ++i3)
        this[i3 + t3] = s3[i3 % a3];
    }
    return this;
  };
  const P2 = {};
  function R2(e3, t3, r3) {
    P2[e3] = class extends r3 {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, delete this.name;
      }
      get code() {
        return e3;
      }
      set code(e4) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
      }
      toString() {
        return `${this.name} [${e3}]: ${this.message}`;
      }
    };
  }
  function D2(e3) {
    let t3 = "", r3 = e3.length;
    const n3 = "-" === e3[0] ? 1 : 0;
    for (; r3 >= n3 + 4; r3 -= 3)
      t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
    return `${e3.slice(0, r3)}${t3}`;
  }
  function z2(e3, t3, r3, n3, i3, o3) {
    if (e3 > r3 || e3 < t3) {
      const n4 = "bigint" == typeof t3 ? "n" : "";
      let i4;
      throw i4 = o3 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${n4} and < 2${n4} ** ${8 * (o3 + 1)}${n4}` : `>= -(2${n4} ** ${8 * (o3 + 1) - 1}${n4}) and < 2 ** ${8 * (o3 + 1) - 1}${n4}` : `>= ${t3}${n4} and <= ${r3}${n4}`, new P2.ERR_OUT_OF_RANGE("value", i4, e3);
    }
    !function(e4, t4, r4) {
      $2(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + r4] || V2(t4, e4.length - (r4 + 1));
    }(n3, i3, o3);
  }
  function $2(e3, t3) {
    if ("number" != typeof e3)
      throw new P2.ERR_INVALID_ARG_TYPE(t3, "number", e3);
  }
  function V2(e3, t3, r3) {
    if (Math.floor(e3) !== e3)
      throw $2(e3, r3), new P2.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
    if (t3 < 0)
      throw new P2.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new P2.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
  }
  R2("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
    return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), R2("ERR_INVALID_ARG_TYPE", function(e3, t3) {
    return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
  }, TypeError), R2("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
    let n3 = `The value of "${e3}" is out of range.`, i3 = r3;
    return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i3 = D2(String(r3)) : "bigint" == typeof r3 && (i3 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i3 = D2(i3)), i3 += "n"), n3 += ` It must be ${t3}. Received ${i3}`, n3;
  }, RangeError);
  const j2 = /[^+/0-9A-Za-z-_]/g;
  function F2(e3, t3) {
    let r3;
    t3 = t3 || Infinity;
    const n3 = e3.length;
    let i3 = null;
    const o3 = [];
    for (let s3 = 0; s3 < n3; ++s3) {
      if (r3 = e3.charCodeAt(s3), r3 > 55295 && r3 < 57344) {
        if (!i3) {
          if (r3 > 56319) {
            (t3 -= 3) > -1 && o3.push(239, 191, 189);
            continue;
          }
          if (s3 + 1 === n3) {
            (t3 -= 3) > -1 && o3.push(239, 191, 189);
            continue;
          }
          i3 = r3;
          continue;
        }
        if (r3 < 56320) {
          (t3 -= 3) > -1 && o3.push(239, 191, 189), i3 = r3;
          continue;
        }
        r3 = 65536 + (i3 - 55296 << 10 | r3 - 56320);
      } else
        i3 && (t3 -= 3) > -1 && o3.push(239, 191, 189);
      if (i3 = null, r3 < 128) {
        if ((t3 -= 1) < 0)
          break;
        o3.push(r3);
      } else if (r3 < 2048) {
        if ((t3 -= 2) < 0)
          break;
        o3.push(r3 >> 6 | 192, 63 & r3 | 128);
      } else if (r3 < 65536) {
        if ((t3 -= 3) < 0)
          break;
        o3.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      } else {
        if (!(r3 < 1114112))
          throw new Error("Invalid code point");
        if ((t3 -= 4) < 0)
          break;
        o3.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      }
    }
    return o3;
  }
  function H2(e3) {
    return function(e4) {
      var t3, r3, n3 = function(e5) {
        var t4 = e5.length;
        if (t4 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var r4 = e5.indexOf("=");
        return -1 === r4 && (r4 = t4), [r4, r4 === t4 ? 0 : 4 - r4 % 4];
      }(e4), i3 = n3[0], o3 = n3[1], s3 = new Si(function(e5, t4, r4) {
        return 3 * (t4 + r4) / 4 - r4;
      }(0, i3, o3)), a3 = 0, u3 = o3 > 0 ? i3 - 4 : i3;
      for (r3 = 0; r3 < u3; r3 += 4)
        t3 = Ti[e4.charCodeAt(r3)] << 18 | Ti[e4.charCodeAt(r3 + 1)] << 12 | Ti[e4.charCodeAt(r3 + 2)] << 6 | Ti[e4.charCodeAt(r3 + 3)], s3[a3++] = t3 >> 16 & 255, s3[a3++] = t3 >> 8 & 255, s3[a3++] = 255 & t3;
      return 2 === o3 && (t3 = Ti[e4.charCodeAt(r3)] << 2 | Ti[e4.charCodeAt(r3 + 1)] >> 4, s3[a3++] = 255 & t3), 1 === o3 && (t3 = Ti[e4.charCodeAt(r3)] << 10 | Ti[e4.charCodeAt(r3 + 1)] << 4 | Ti[e4.charCodeAt(r3 + 2)] >> 2, s3[a3++] = t3 >> 8 & 255, s3[a3++] = 255 & t3), s3;
    }(function(e4) {
      if ((e4 = (e4 = e4.split("=")[0]).trim().replace(j2, "")).length < 2)
        return "";
      for (; e4.length % 4 != 0; )
        e4 += "=";
      return e4;
    }(e3));
  }
  function K2(e3, t3, r3, n3) {
    let i3;
    for (i3 = 0; i3 < n3 && !(i3 + r3 >= t3.length || i3 >= e3.length); ++i3)
      t3[i3 + r3] = e3[i3];
    return i3;
  }
  function G2(e3, t3) {
    return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
  }
  function q2(e3) {
    return e3 != e3;
  }
  const J2 = function() {
    const e3 = "0123456789abcdef", t3 = new Array(256);
    for (let r3 = 0; r3 < 16; ++r3) {
      const n3 = 16 * r3;
      for (let i3 = 0; i3 < 16; ++i3)
        t3[n3 + i3] = e3[r3] + e3[i3];
    }
    return t3;
  }();
  function W2(e3) {
    return "undefined" == typeof BigInt ? Z2 : e3;
  }
  function Z2() {
    throw new Error("BigInt not supported");
  }
});
var Pi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.utils = t2.schnorr = t2.verify = t2.signSync = t2.sign = t2.getSharedSecret = t2.recoverPublicKey = t2.getPublicKey = t2.Signature = t2.Point = t2.CURVE = void 0;
  const r2 = BigInt(0), n2 = BigInt(1), i2 = BigInt(2), o2 = BigInt(3), s2 = BigInt(8), a2 = Object.freeze({ a: r2, b: BigInt(7), P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), h: n2, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee") });
  t2.CURVE = a2;
  const u2 = (e3, t3) => (e3 + t3 / i2) / t3, h2 = { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar(e3) {
    const { n: t3 } = a2, r3 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), i3 = -n2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o3 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s3 = r3, h3 = BigInt("0x100000000000000000000000000000000"), f3 = u2(s3 * e3, t3), c3 = u2(-i3 * e3, t3);
    let l3 = k2(e3 - f3 * r3 - c3 * o3, t3), d3 = k2(-f3 * i3 - c3 * s3, t3);
    const p3 = l3 > h3, y3 = d3 > h3;
    if (p3 && (l3 = t3 - l3), y3 && (d3 = t3 - d3), l3 > h3 || d3 > h3)
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + e3);
    return { k1neg: p3, k1: l3, k2neg: y3, k2: d3 };
  } };
  function f2(e3) {
    const { a: t3, b: r3 } = a2, n3 = k2(e3 * e3), i3 = k2(n3 * e3);
    return k2(i3 + t3 * e3 + r3);
  }
  const c2 = a2.a === r2;
  class l2 extends Error {
    constructor(e3) {
      super(e3);
    }
  }
  function d2(e3) {
    if (!(e3 instanceof p2))
      throw new TypeError("JacobianPoint expected");
  }
  class p2 {
    constructor(e3, t3, r3) {
      this.x = e3, this.y = t3, this.z = r3;
    }
    static fromAffine(e3) {
      if (!(e3 instanceof m2))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return e3.equals(m2.ZERO) ? p2.ZERO : new p2(e3.x, e3.y, n2);
    }
    static toAffineBatch(e3) {
      const t3 = function(e4, t4 = a2.P) {
        const i3 = new Array(e4.length), o3 = e4.reduce((e5, n3, o4) => n3 === r2 ? e5 : (i3[o4] = e5, k2(e5 * n3, t4)), n2), s3 = C2(o3, t4);
        return e4.reduceRight((e5, n3, o4) => n3 === r2 ? e5 : (i3[o4] = k2(e5 * i3[o4], t4), k2(e5 * n3, t4)), s3), i3;
      }(e3.map((e4) => e4.z));
      return e3.map((e4, r3) => e4.toAffine(t3[r3]));
    }
    static normalizeZ(e3) {
      return p2.toAffineBatch(e3).map(p2.fromAffine);
    }
    equals(e3) {
      d2(e3);
      const { x: t3, y: r3, z: n3 } = this, { x: i3, y: o3, z: s3 } = e3, a3 = k2(n3 * n3), u3 = k2(s3 * s3), h3 = k2(t3 * u3), f3 = k2(i3 * a3), c3 = k2(k2(r3 * s3) * u3), l3 = k2(k2(o3 * n3) * a3);
      return h3 === f3 && c3 === l3;
    }
    negate() {
      return new p2(this.x, k2(-this.y), this.z);
    }
    double() {
      const { x: e3, y: t3, z: r3 } = this, n3 = k2(e3 * e3), a3 = k2(t3 * t3), u3 = k2(a3 * a3), h3 = e3 + a3, f3 = k2(i2 * (k2(h3 * h3) - n3 - u3)), c3 = k2(o2 * n3), l3 = k2(c3 * c3), d3 = k2(l3 - i2 * f3), y3 = k2(c3 * (f3 - d3) - s2 * u3), g3 = k2(i2 * t3 * r3);
      return new p2(d3, y3, g3);
    }
    add(e3) {
      d2(e3);
      const { x: t3, y: n3, z: o3 } = this, { x: s3, y: a3, z: u3 } = e3;
      if (s3 === r2 || a3 === r2)
        return this;
      if (t3 === r2 || n3 === r2)
        return e3;
      const h3 = k2(o3 * o3), f3 = k2(u3 * u3), c3 = k2(t3 * f3), l3 = k2(s3 * h3), y3 = k2(k2(n3 * u3) * f3), g3 = k2(k2(a3 * o3) * h3), m3 = k2(l3 - c3), w3 = k2(g3 - y3);
      if (m3 === r2)
        return w3 === r2 ? this.double() : p2.ZERO;
      const b3 = k2(m3 * m3), v3 = k2(m3 * b3), E3 = k2(c3 * b3), x3 = k2(w3 * w3 - v3 - i2 * E3), B3 = k2(w3 * (E3 - x3) - y3 * v3), A3 = k2(o3 * u3 * m3);
      return new p2(x3, B3, A3);
    }
    subtract(e3) {
      return this.add(e3.negate());
    }
    multiplyUnsafe(e3) {
      const t3 = p2.ZERO;
      if ("bigint" == typeof e3 && e3 === r2)
        return t3;
      let i3 = L2(e3);
      if (i3 === n2)
        return this;
      if (!c2) {
        let e4 = t3, o4 = this;
        for (; i3 > r2; )
          i3 & n2 && (e4 = e4.add(o4)), o4 = o4.double(), i3 >>= n2;
        return e4;
      }
      let { k1neg: o3, k1: s3, k2neg: a3, k2: u3 } = h2.splitScalar(i3), f3 = t3, l3 = t3, d3 = this;
      for (; s3 > r2 || u3 > r2; )
        s3 & n2 && (f3 = f3.add(d3)), u3 & n2 && (l3 = l3.add(d3)), d3 = d3.double(), s3 >>= n2, u3 >>= n2;
      return o3 && (f3 = f3.negate()), a3 && (l3 = l3.negate()), l3 = new p2(k2(l3.x * h2.beta), l3.y, l3.z), f3.add(l3);
    }
    precomputeWindow(e3) {
      const t3 = c2 ? 128 / e3 + 1 : 256 / e3 + 1, r3 = [];
      let n3 = this, i3 = n3;
      for (let o3 = 0; o3 < t3; o3++) {
        i3 = n3, r3.push(i3);
        for (let t4 = 1; t4 < 2 ** (e3 - 1); t4++)
          i3 = i3.add(n3), r3.push(i3);
        n3 = i3.double();
      }
      return r3;
    }
    wNAF(e3, t3) {
      !t3 && this.equals(p2.BASE) && (t3 = m2.BASE);
      const r3 = t3 && t3._WINDOW_SIZE || 1;
      if (256 % r3)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let i3 = t3 && g2.get(t3);
      i3 || (i3 = this.precomputeWindow(r3), t3 && 1 !== r3 && (i3 = p2.normalizeZ(i3), g2.set(t3, i3)));
      let o3 = p2.ZERO, s3 = p2.BASE;
      const a3 = 1 + (c2 ? 128 / r3 : 256 / r3), u3 = 2 ** (r3 - 1), h3 = BigInt(2 ** r3 - 1), f3 = 2 ** r3, l3 = BigInt(r3);
      for (let t4 = 0; t4 < a3; t4++) {
        const r4 = t4 * u3;
        let a4 = Number(e3 & h3);
        e3 >>= l3, a4 > u3 && (a4 -= f3, e3 += n2);
        const c3 = r4, d3 = r4 + Math.abs(a4) - 1, p3 = a4 < 0;
        0 === a4 ? s3 = s3.add(y2(t4 % 2 != 0, i3[c3])) : o3 = o3.add(y2(p3, i3[d3]));
      }
      return { p: o3, f: s3 };
    }
    multiply(e3, t3) {
      let r3, n3, i3 = L2(e3);
      if (c2) {
        const { k1neg: e4, k1: o3, k2neg: s3, k2: a3 } = h2.splitScalar(i3);
        let { p: u3, f: f3 } = this.wNAF(o3, t3), { p: c3, f: l3 } = this.wNAF(a3, t3);
        u3 = y2(e4, u3), c3 = y2(s3, c3), c3 = new p2(k2(c3.x * h2.beta), c3.y, c3.z), r3 = u3.add(c3), n3 = f3.add(l3);
      } else {
        const { p: e4, f: o3 } = this.wNAF(i3, t3);
        r3 = e4, n3 = o3;
      }
      return p2.normalizeZ([r3, n3])[0];
    }
    toAffine(e3) {
      const { x: t3, y: r3, z: i3 } = this, o3 = this.equals(p2.ZERO);
      null == e3 && (e3 = o3 ? s2 : C2(i3));
      const a3 = e3, u3 = k2(a3 * a3), h3 = k2(u3 * a3), f3 = k2(t3 * u3), c3 = k2(r3 * h3), l3 = k2(i3 * a3);
      if (o3)
        return m2.ZERO;
      if (l3 !== n2)
        throw new Error("invZ was invalid");
      return new m2(f3, c3);
    }
  }
  function y2(e3, t3) {
    const r3 = t3.negate();
    return e3 ? r3 : t3;
  }
  p2.BASE = new p2(a2.Gx, a2.Gy, n2), p2.ZERO = new p2(r2, n2, r2);
  const g2 = /* @__PURE__ */ new WeakMap();
  class m2 {
    constructor(e3, t3) {
      this.x = e3, this.y = t3;
    }
    _setWindowSize(e3) {
      this._WINDOW_SIZE = e3, g2.delete(this);
    }
    hasEvenY() {
      return this.y % i2 === r2;
    }
    static fromCompressedHex(e3) {
      const t3 = 32 === e3.length, r3 = O2(t3 ? e3 : e3.subarray(1));
      if (!V2(r3))
        throw new Error("Point is not on curve");
      let s3 = function(e4) {
        const { P: t4 } = a2, r4 = BigInt(6), n3 = BigInt(11), s4 = BigInt(22), u4 = BigInt(23), h4 = BigInt(44), f3 = BigInt(88), c3 = e4 * e4 * e4 % t4, l3 = c3 * c3 * e4 % t4, d3 = M2(l3, o2) * l3 % t4, p3 = M2(d3, o2) * l3 % t4, y3 = M2(p3, i2) * c3 % t4, g3 = M2(y3, n3) * y3 % t4, m3 = M2(g3, s4) * g3 % t4, w3 = M2(m3, h4) * m3 % t4, b3 = M2(w3, f3) * w3 % t4, v3 = M2(b3, h4) * m3 % t4, E3 = M2(v3, o2) * l3 % t4, x3 = M2(E3, u4) * g3 % t4, B3 = M2(x3, r4) * c3 % t4, A3 = M2(B3, i2);
        if (A3 * A3 % t4 !== e4)
          throw new Error("Cannot find square root");
        return A3;
      }(f2(r3));
      const u3 = (s3 & n2) === n2;
      t3 ? u3 && (s3 = k2(-s3)) : 1 == (1 & e3[0]) !== u3 && (s3 = k2(-s3));
      const h3 = new m2(r3, s3);
      return h3.assertValidity(), h3;
    }
    static fromUncompressedHex(e3) {
      const t3 = O2(e3.subarray(1, 33)), r3 = O2(e3.subarray(33, 65)), n3 = new m2(t3, r3);
      return n3.assertValidity(), n3;
    }
    static fromHex(e3) {
      const t3 = U2(e3), r3 = t3.length, n3 = t3[0];
      if (32 === r3)
        return this.fromCompressedHex(t3);
      if (33 === r3 && (2 === n3 || 3 === n3))
        return this.fromCompressedHex(t3);
      if (65 === r3 && 4 === n3)
        return this.fromUncompressedHex(t3);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r3}`);
    }
    static fromPrivateKey(e3) {
      return m2.BASE.multiply(F2(e3));
    }
    static fromSignature(e3, t3, r3) {
      const { r: n3, s: i3 } = K2(t3);
      if (![0, 1, 2, 3].includes(r3))
        throw new Error("Cannot recover: invalid recovery bit");
      const o3 = P2(U2(e3)), { n: s3 } = a2, u3 = 2 === r3 || 3 === r3 ? n3 + s3 : n3, h3 = C2(u3, s3), f3 = k2(-o3 * h3, s3), c3 = k2(i3 * h3, s3), l3 = m2.fromHex((1 & r3 ? "03" : "02") + _2(u3)), d3 = m2.BASE.multiplyAndAddUnsafe(l3, f3, c3);
      if (!d3)
        throw new Error("Cannot recover signature: point at infinify");
      return d3.assertValidity(), d3;
    }
    toRawBytes(e3 = false) {
      return I2(this.toHex(e3));
    }
    toHex(e3 = false) {
      const t3 = _2(this.x);
      return e3 ? `${this.hasEvenY() ? "02" : "03"}${t3}` : `04${t3}${_2(this.y)}`;
    }
    toHexX() {
      return this.toHex(true).slice(2);
    }
    toRawX() {
      return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
      const e3 = "Point is not on elliptic curve", { x: t3, y: n3 } = this;
      if (!V2(t3) || !V2(n3))
        throw new Error(e3);
      const i3 = k2(n3 * n3);
      if (k2(i3 - f2(t3)) !== r2)
        throw new Error(e3);
    }
    equals(e3) {
      return this.x === e3.x && this.y === e3.y;
    }
    negate() {
      return new m2(this.x, k2(-this.y));
    }
    double() {
      return p2.fromAffine(this).double().toAffine();
    }
    add(e3) {
      return p2.fromAffine(this).add(p2.fromAffine(e3)).toAffine();
    }
    subtract(e3) {
      return this.add(e3.negate());
    }
    multiply(e3) {
      return p2.fromAffine(this).multiply(e3, this).toAffine();
    }
    multiplyAndAddUnsafe(e3, t3, i3) {
      const o3 = p2.fromAffine(this), s3 = t3 === r2 || t3 === n2 || this !== m2.BASE ? o3.multiplyUnsafe(t3) : o3.multiply(t3), a3 = p2.fromAffine(e3).multiplyUnsafe(i3), u3 = s3.add(a3);
      return u3.equals(p2.ZERO) ? void 0 : u3.toAffine();
    }
  }
  function w2(e3) {
    return Number.parseInt(e3[0], 16) >= 8 ? "00" + e3 : e3;
  }
  function b2(e3) {
    if (e3.length < 2 || 2 !== e3[0])
      throw new Error(`Invalid signature integer tag: ${B2(e3)}`);
    const t3 = e3[1], r3 = e3.subarray(2, t3 + 2);
    if (!t3 || r3.length !== t3)
      throw new Error("Invalid signature integer: wrong length");
    if (0 === r3[0] && r3[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: O2(r3), left: e3.subarray(t3 + 2) };
  }
  t2.Point = m2, m2.BASE = new m2(a2.Gx, a2.Gy), m2.ZERO = new m2(r2, r2);
  class v2 {
    constructor(e3, t3) {
      this.r = e3, this.s = t3, this.assertValidity();
    }
    static fromCompact(e3) {
      const t3 = e3 instanceof Uint8Array, r3 = "Signature.fromCompact";
      if ("string" != typeof e3 && !t3)
        throw new TypeError(`${r3}: Expected string or Uint8Array`);
      const n3 = t3 ? B2(e3) : e3;
      if (128 !== n3.length)
        throw new Error(`${r3}: Expected 64-byte hex`);
      return new v2(N2(n3.slice(0, 64)), N2(n3.slice(64, 128)));
    }
    static fromDER(e3) {
      const t3 = e3 instanceof Uint8Array;
      if ("string" != typeof e3 && !t3)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: r3, s: n3 } = function(e4) {
        if (e4.length < 2 || 48 != e4[0])
          throw new Error(`Invalid signature tag: ${B2(e4)}`);
        if (e4[1] !== e4.length - 2)
          throw new Error("Invalid signature: incorrect length");
        const { data: t4, left: r4 } = b2(e4.subarray(2)), { data: n4, left: i3 } = b2(r4);
        if (i3.length)
          throw new Error(`Invalid signature: left bytes after parsing: ${B2(i3)}`);
        return { r: t4, s: n4 };
      }(t3 ? e3 : I2(e3));
      return new v2(r3, n3);
    }
    static fromHex(e3) {
      return this.fromDER(e3);
    }
    assertValidity() {
      const { r: e3, s: t3 } = this;
      if (!$2(e3))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!$2(t3))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      return this.s > a2.n >> n2;
    }
    normalizeS() {
      return this.hasHighS() ? new v2(this.r, k2(-this.s, a2.n)) : this;
    }
    toDERRawBytes() {
      return I2(this.toDERHex());
    }
    toDERHex() {
      const e3 = w2(S2(this.s)), t3 = w2(S2(this.r)), r3 = e3.length / 2, n3 = t3.length / 2, i3 = S2(r3), o3 = S2(n3);
      return `30${S2(n3 + r3 + 4)}02${o3}${t3}02${i3}${e3}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return I2(this.toCompactHex());
    }
    toCompactHex() {
      return _2(this.r) + _2(this.s);
    }
  }
  function E2(...e3) {
    if (!e3.every((e4) => e4 instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (1 === e3.length)
      return e3[0];
    const t3 = e3.reduce((e4, t4) => e4 + t4.length, 0), r3 = new Uint8Array(t3);
    for (let t4 = 0, n3 = 0; t4 < e3.length; t4++) {
      const i3 = e3[t4];
      r3.set(i3, n3), n3 += i3.length;
    }
    return r3;
  }
  t2.Signature = v2;
  const x2 = Array.from({ length: 256 }, (e3, t3) => t3.toString(16).padStart(2, "0"));
  function B2(e3) {
    if (!(e3 instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let t3 = "";
    for (let r3 = 0; r3 < e3.length; r3++)
      t3 += x2[e3[r3]];
    return t3;
  }
  const A2 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function _2(e3) {
    if ("bigint" != typeof e3)
      throw new Error("Expected bigint");
    if (!(r2 <= e3 && e3 < A2))
      throw new Error("Expected number 0 <= n < 2^256");
    return e3.toString(16).padStart(64, "0");
  }
  function T2(e3) {
    const t3 = I2(_2(e3));
    if (32 !== t3.length)
      throw new Error("Error: expected 32 bytes");
    return t3;
  }
  function S2(e3) {
    const t3 = e3.toString(16);
    return 1 & t3.length ? `0${t3}` : t3;
  }
  function N2(e3) {
    if ("string" != typeof e3)
      throw new TypeError("hexToNumber: expected string, got " + typeof e3);
    return BigInt(`0x${e3}`);
  }
  function I2(e3) {
    if ("string" != typeof e3)
      throw new TypeError("hexToBytes: expected string, got " + typeof e3);
    if (e3.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + e3.length);
    const t3 = new Uint8Array(e3.length / 2);
    for (let r3 = 0; r3 < t3.length; r3++) {
      const n3 = 2 * r3, i3 = e3.slice(n3, n3 + 2), o3 = Number.parseInt(i3, 16);
      if (Number.isNaN(o3) || o3 < 0)
        throw new Error("Invalid byte sequence");
      t3[r3] = o3;
    }
    return t3;
  }
  function O2(e3) {
    return N2(B2(e3));
  }
  function U2(e3) {
    return e3 instanceof Uint8Array ? Uint8Array.from(e3) : I2(e3);
  }
  function L2(e3) {
    if ("number" == typeof e3 && Number.isSafeInteger(e3) && e3 > 0)
      return BigInt(e3);
    if ("bigint" == typeof e3 && $2(e3))
      return e3;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function k2(e3, t3 = a2.P) {
    const n3 = e3 % t3;
    return n3 >= r2 ? n3 : t3 + n3;
  }
  function M2(e3, t3) {
    const { P: n3 } = a2;
    let i3 = e3;
    for (; t3-- > r2; )
      i3 *= i3, i3 %= n3;
    return i3;
  }
  function C2(e3, t3 = a2.P) {
    if (e3 === r2 || t3 <= r2)
      throw new Error(`invert: expected positive integers, got n=${e3} mod=${t3}`);
    let i3 = k2(e3, t3), o3 = t3, s3 = r2, u3 = n2;
    for (; i3 !== r2; ) {
      const e4 = o3 % i3, t4 = s3 - u3 * (o3 / i3);
      o3 = i3, i3 = e4, s3 = u3, u3 = t4;
    }
    if (o3 !== n2)
      throw new Error("invert: does not exist");
    return k2(s3, t3);
  }
  function P2(e3, t3 = false) {
    const r3 = function(e4) {
      const t4 = 8 * e4.length - 256, r4 = O2(e4);
      return t4 > 0 ? r4 >> BigInt(t4) : r4;
    }(e3);
    if (t3)
      return r3;
    const { n: n3 } = a2;
    return r3 >= n3 ? r3 - n3 : r3;
  }
  let R2, D2;
  class z2 {
    constructor(e3, t3) {
      if (this.hashLen = e3, this.qByteLen = t3, "number" != typeof e3 || e3 < 2)
        throw new Error("hashLen must be a number");
      if ("number" != typeof t3 || t3 < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(e3).fill(1), this.k = new Uint8Array(e3).fill(0), this.counter = 0;
    }
    hmac(...e3) {
      return t2.utils.hmacSha256(this.k, ...e3);
    }
    hmacSync(...e3) {
      return D2(this.k, ...e3);
    }
    checkSync() {
      if ("function" != typeof D2)
        throw new l2("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(e3 = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), e3), this.v = await this.hmac(this.v), 0 !== e3.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e3), this.v = await this.hmac(this.v));
    }
    reseedSync(e3 = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), e3), this.v = this.hmacSync(this.v), 0 !== e3.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e3), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let e3 = 0;
      const t3 = [];
      for (; e3 < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const r3 = this.v.slice();
        t3.push(r3), e3 += this.v.length;
      }
      return E2(...t3);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let e3 = 0;
      const t3 = [];
      for (; e3 < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const r3 = this.v.slice();
        t3.push(r3), e3 += this.v.length;
      }
      return E2(...t3);
    }
  }
  function $2(e3) {
    return r2 < e3 && e3 < a2.n;
  }
  function V2(e3) {
    return r2 < e3 && e3 < a2.P;
  }
  function j2(e3, t3, i3, o3 = true) {
    const { n: s3 } = a2, u3 = P2(e3, true);
    if (!$2(u3))
      return;
    const h3 = C2(u3, s3), f3 = m2.BASE.multiply(u3), c3 = k2(f3.x, s3);
    if (c3 === r2)
      return;
    const l3 = k2(h3 * k2(t3 + i3 * c3, s3), s3);
    if (l3 === r2)
      return;
    let d3 = new v2(c3, l3), p3 = (f3.x === d3.r ? 0 : 2) | Number(f3.y & n2);
    return o3 && d3.hasHighS() && (d3 = d3.normalizeS(), p3 ^= 1), { sig: d3, recovery: p3 };
  }
  function F2(e3) {
    let t3;
    if ("bigint" == typeof e3)
      t3 = e3;
    else if ("number" == typeof e3 && Number.isSafeInteger(e3) && e3 > 0)
      t3 = BigInt(e3);
    else if ("string" == typeof e3) {
      if (64 !== e3.length)
        throw new Error("Expected 32 bytes of private key");
      t3 = N2(e3);
    } else {
      if (!(e3 instanceof Uint8Array))
        throw new TypeError("Expected valid private key");
      if (32 !== e3.length)
        throw new Error("Expected 32 bytes of private key");
      t3 = O2(e3);
    }
    if (!$2(t3))
      throw new Error("Expected private key: 0 < key < n");
    return t3;
  }
  function H2(e3) {
    return e3 instanceof m2 ? (e3.assertValidity(), e3) : m2.fromHex(e3);
  }
  function K2(e3) {
    if (e3 instanceof v2)
      return e3.assertValidity(), e3;
    try {
      return v2.fromDER(e3);
    } catch (t3) {
      return v2.fromCompact(e3);
    }
  }
  function G2(e3) {
    const t3 = e3 instanceof Uint8Array, r3 = "string" == typeof e3, n3 = (t3 || r3) && e3.length;
    return t3 ? 33 === n3 || 65 === n3 : r3 ? 66 === n3 || 130 === n3 : e3 instanceof m2;
  }
  function q2(e3) {
    return O2(e3.length > 32 ? e3.slice(0, 32) : e3);
  }
  function J2(e3) {
    const t3 = q2(e3), n3 = k2(t3, a2.n);
    return W2(n3 < r2 ? t3 : n3);
  }
  function W2(e3) {
    return T2(e3);
  }
  function Z2(e3, r3, n3) {
    if (null == e3)
      throw new Error(`sign: expected valid message hash, not "${e3}"`);
    const i3 = U2(e3), o3 = F2(r3), s3 = [W2(o3), J2(i3)];
    if (null != n3) {
      true === n3 && (n3 = t2.utils.randomBytes(32));
      const e4 = U2(n3);
      if (32 !== e4.length)
        throw new Error("sign: Expected 32 bytes of extra data");
      s3.push(e4);
    }
    return { seed: E2(...s3), m: q2(i3), d: o3 };
  }
  function Y2(e3, t3) {
    const { sig: r3, recovery: n3 } = e3, { der: i3, recovered: o3 } = Object.assign({ canonical: true, der: true }, t3), s3 = i3 ? r3.toDERRawBytes() : r3.toCompactRawBytes();
    return o3 ? [s3, n3] : s3;
  }
  t2.getPublicKey = function(e3, t3 = false) {
    return m2.fromPrivateKey(e3).toRawBytes(t3);
  }, t2.recoverPublicKey = function(e3, t3, r3, n3 = false) {
    return m2.fromSignature(e3, t3, r3).toRawBytes(n3);
  }, t2.getSharedSecret = function(e3, t3, r3 = false) {
    if (G2(e3))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!G2(t3))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const n3 = H2(t3);
    return n3.assertValidity(), n3.multiply(F2(e3)).toRawBytes(r3);
  }, t2.sign = async function(e3, t3, r3 = {}) {
    const { seed: n3, m: i3, d: o3 } = Z2(e3, t3, r3.extraEntropy), s3 = new z2(32, 32);
    let a3;
    for (await s3.reseed(n3); !(a3 = j2(await s3.generate(), i3, o3, r3.canonical)); )
      await s3.reseed();
    return Y2(a3, r3);
  }, t2.signSync = function(e3, t3, r3 = {}) {
    const { seed: n3, m: i3, d: o3 } = Z2(e3, t3, r3.extraEntropy), s3 = new z2(32, 32);
    let a3;
    for (s3.reseedSync(n3); !(a3 = j2(s3.generateSync(), i3, o3, r3.canonical)); )
      s3.reseedSync();
    return Y2(a3, r3);
  };
  const X2 = { strict: true };
  function Q2(e3) {
    return k2(O2(e3), a2.n);
  }
  t2.verify = function(e3, t3, r3, n3 = X2) {
    let i3;
    try {
      i3 = K2(e3), t3 = U2(t3);
    } catch (e4) {
      return false;
    }
    const { r: o3, s: s3 } = i3;
    if (n3.strict && i3.hasHighS())
      return false;
    const u3 = P2(t3);
    let h3;
    try {
      h3 = H2(r3);
    } catch (e4) {
      return false;
    }
    const { n: f3 } = a2, c3 = C2(s3, f3), l3 = k2(u3 * c3, f3), d3 = k2(o3 * c3, f3), p3 = m2.BASE.multiplyAndAddUnsafe(h3, l3, d3);
    return !!p3 && k2(p3.x, f3) === o3;
  };
  class ee2 {
    constructor(e3, t3) {
      this.r = e3, this.s = t3, this.assertValidity();
    }
    static fromHex(e3) {
      const t3 = U2(e3);
      if (64 !== t3.length)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${t3.length}`);
      const r3 = O2(t3.subarray(0, 32)), n3 = O2(t3.subarray(32, 64));
      return new ee2(r3, n3);
    }
    assertValidity() {
      const { r: e3, s: t3 } = this;
      if (!V2(e3) || !$2(t3))
        throw new Error("Invalid signature");
    }
    toHex() {
      return _2(this.r) + _2(this.s);
    }
    toRawBytes() {
      return I2(this.toHex());
    }
  }
  class te2 {
    constructor(e3, r3, n3 = t2.utils.randomBytes()) {
      if (null == e3)
        throw new TypeError(`sign: Expected valid message, not "${e3}"`);
      this.m = U2(e3);
      const { x: i3, scalar: o3 } = this.getScalar(F2(r3));
      if (this.px = i3, this.d = o3, this.rand = U2(n3), 32 !== this.rand.length)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(e3) {
      const t3 = m2.fromPrivateKey(e3), r3 = t3.hasEvenY() ? e3 : a2.n - e3;
      return { point: t3, scalar: r3, x: t3.toRawX() };
    }
    initNonce(e3, t3) {
      return T2(e3 ^ O2(t3));
    }
    finalizeNonce(e3) {
      const t3 = k2(O2(e3), a2.n);
      if (t3 === r2)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: n3, x: i3, scalar: o3 } = this.getScalar(t3);
      return { R: n3, rx: i3, k: o3 };
    }
    finalizeSig(e3, t3, r3, n3) {
      return new ee2(e3.x, k2(t3 + r3 * n3, a2.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: e3, d: r3, px: n3, rand: i3 } = this, o3 = t2.utils.taggedHash, s3 = this.initNonce(r3, await o3(ae2.aux, i3)), { R: a3, rx: u3, k: h3 } = this.finalizeNonce(await o3(ae2.nonce, s3, n3, e3)), f3 = Q2(await o3(ae2.challenge, u3, n3, e3)), c3 = this.finalizeSig(a3, h3, f3, r3);
      return await ie2(c3, e3, n3) || this.error(), c3;
    }
    calcSync() {
      const { m: e3, d: r3, px: n3, rand: i3 } = this, o3 = t2.utils.taggedHashSync, s3 = this.initNonce(r3, o3(ae2.aux, i3)), { R: a3, rx: u3, k: h3 } = this.finalizeNonce(o3(ae2.nonce, s3, n3, e3)), f3 = Q2(o3(ae2.challenge, u3, n3, e3)), c3 = this.finalizeSig(a3, h3, f3, r3);
      return oe2(c3, e3, n3) || this.error(), c3;
    }
  }
  function re2(e3, t3, r3) {
    const n3 = e3 instanceof ee2, i3 = n3 ? e3 : ee2.fromHex(e3);
    return n3 && i3.assertValidity(), { ...i3, m: U2(t3), P: H2(r3) };
  }
  function ne2(e3, t3, r3, n3) {
    const i3 = m2.BASE.multiplyAndAddUnsafe(t3, F2(r3), k2(-n3, a2.n));
    return !(!i3 || !i3.hasEvenY() || i3.x !== e3);
  }
  async function ie2(e3, r3, n3) {
    try {
      const { r: i3, s: o3, m: s3, P: a3 } = re2(e3, r3, n3), u3 = Q2(await t2.utils.taggedHash(ae2.challenge, T2(i3), a3.toRawX(), s3));
      return ne2(i3, a3, o3, u3);
    } catch (e4) {
      return false;
    }
  }
  function oe2(e3, r3, n3) {
    try {
      const { r: i3, s: o3, m: s3, P: a3 } = re2(e3, r3, n3), u3 = Q2(t2.utils.taggedHashSync(ae2.challenge, T2(i3), a3.toRawX(), s3));
      return ne2(i3, a3, o3, u3);
    } catch (e4) {
      if (e4 instanceof l2)
        throw e4;
      return false;
    }
  }
  t2.schnorr = { Signature: ee2, getPublicKey: function(e3) {
    return m2.fromPrivateKey(e3).toRawX();
  }, sign: async function(e3, t3, r3) {
    return new te2(e3, t3, r3).calc();
  }, verify: ie2, signSync: function(e3, t3, r3) {
    return new te2(e3, t3, r3).calcSync();
  }, verifySync: oe2 }, m2.BASE._setWindowSize(8);
  const se2 = { node: me, web: "object" == typeof self && "crypto" in self ? self.crypto : void 0 }, ae2 = { challenge: "BIP0340/challenge", aux: "BIP0340/aux", nonce: "BIP0340/nonce" }, ue2 = {};
  t2.utils = { bytesToHex: B2, hexToBytes: I2, concatBytes: E2, mod: k2, invert: C2, isValidPrivateKey(e3) {
    try {
      return F2(e3), true;
    } catch (e4) {
      return false;
    }
  }, _bigintTo32Bytes: T2, _normalizePrivateKey: F2, hashToPrivateKey: (e3) => {
    if ((e3 = U2(e3)).length < 40 || e3.length > 1024)
      throw new Error("Expected valid bytes of private key as per FIPS 186");
    return T2(k2(O2(e3), a2.n - n2) + n2);
  }, randomBytes: (e3 = 32) => {
    if (se2.web)
      return se2.web.getRandomValues(new Uint8Array(e3));
    if (se2.node) {
      const { randomBytes: t3 } = se2.node;
      return Uint8Array.from(t3(e3));
    }
    throw new Error("The environment doesn't have randomBytes function");
  }, randomPrivateKey: () => t2.utils.hashToPrivateKey(t2.utils.randomBytes(40)), precompute(e3 = 8, t3 = m2.BASE) {
    const r3 = t3 === m2.BASE ? t3 : new m2(t3.x, t3.y);
    return r3._setWindowSize(e3), r3.multiply(o2), r3;
  }, sha256: async (...e3) => {
    if (se2.web) {
      const t3 = await se2.web.subtle.digest("SHA-256", E2(...e3));
      return new Uint8Array(t3);
    }
    if (se2.node) {
      const { createHash: t3 } = se2.node, r3 = t3("sha256");
      return e3.forEach((e4) => r3.update(e4)), Uint8Array.from(r3.digest());
    }
    throw new Error("The environment doesn't have sha256 function");
  }, hmacSha256: async (e3, ...t3) => {
    if (se2.web) {
      const r3 = await se2.web.subtle.importKey("raw", e3, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), n3 = E2(...t3), i3 = await se2.web.subtle.sign("HMAC", r3, n3);
      return new Uint8Array(i3);
    }
    if (se2.node) {
      const { createHmac: r3 } = se2.node, n3 = r3("sha256", e3);
      return t3.forEach((e4) => n3.update(e4)), Uint8Array.from(n3.digest());
    }
    throw new Error("The environment doesn't have hmac-sha256 function");
  }, sha256Sync: void 0, hmacSha256Sync: void 0, taggedHash: async (e3, ...r3) => {
    let n3 = ue2[e3];
    if (void 0 === n3) {
      const r4 = await t2.utils.sha256(Uint8Array.from(e3, (e4) => e4.charCodeAt(0)));
      n3 = E2(r4, r4), ue2[e3] = n3;
    }
    return t2.utils.sha256(n3, ...r3);
  }, taggedHashSync: (e3, ...t3) => {
    if ("function" != typeof R2)
      throw new l2("sha256Sync is undefined, you need to set it");
    let r3 = ue2[e3];
    if (void 0 === r3) {
      const t4 = R2(Uint8Array.from(e3, (e4) => e4.charCodeAt(0)));
      r3 = E2(t4, t4), ue2[e3] = r3;
    }
    return R2(r3, ...t3);
  }, _JacobianPoint: p2 }, Object.defineProperties(t2.utils, { sha256Sync: { configurable: false, get: () => R2, set(e3) {
    R2 || (R2 = e3);
  } }, hmacSha256Sync: { configurable: false, get: () => D2, set(e3) {
    D2 || (D2 = e3);
  } } });
});
var Ri = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.schnorr = t2.Signature = t2.Point = t2.CURVE = t2.utils = t2.getSharedSecret = t2.recoverPublicKey = t2.verify = t2.signSync = t2.sign = t2.getPublicKey = void 0;
  var r2 = Pi;
  Object.defineProperty(t2, "getPublicKey", { enumerable: true, get: function() {
    return r2.getPublicKey;
  } }), Object.defineProperty(t2, "sign", { enumerable: true, get: function() {
    return r2.sign;
  } }), Object.defineProperty(t2, "signSync", { enumerable: true, get: function() {
    return r2.signSync;
  } }), Object.defineProperty(t2, "verify", { enumerable: true, get: function() {
    return r2.verify;
  } }), Object.defineProperty(t2, "recoverPublicKey", { enumerable: true, get: function() {
    return r2.recoverPublicKey;
  } }), Object.defineProperty(t2, "getSharedSecret", { enumerable: true, get: function() {
    return r2.getSharedSecret;
  } }), Object.defineProperty(t2, "utils", { enumerable: true, get: function() {
    return r2.utils;
  } }), Object.defineProperty(t2, "CURVE", { enumerable: true, get: function() {
    return r2.CURVE;
  } }), Object.defineProperty(t2, "Point", { enumerable: true, get: function() {
    return r2.Point;
  } }), Object.defineProperty(t2, "Signature", { enumerable: true, get: function() {
    return r2.Signature;
  } }), Object.defineProperty(t2, "schnorr", { enumerable: true, get: function() {
    return r2.schnorr;
  } }), Pi.utils.hmacSha256Sync = (e3, ...t3) => {
    const r3 = mt.hmac.create(vt.sha256, e3);
    return t3.forEach((e4) => r3.update(e4)), r3.digest();
  };
});
var Di = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.MAX_WITHDRAWALS_PER_PAYLOAD = t2.RLP_EMPTY_STRING = t2.KECCAK256_RLP = t2.KECCAK256_RLP_S = t2.KECCAK256_RLP_ARRAY = t2.KECCAK256_RLP_ARRAY_S = t2.KECCAK256_NULL = t2.KECCAK256_NULL_S = t2.TWO_POW256 = t2.SECP256K1_ORDER_DIV_2 = t2.SECP256K1_ORDER = t2.MAX_INTEGER_BIGINT = t2.MAX_INTEGER = t2.MAX_UINT64 = void 0, t2.MAX_UINT64 = BigInt("0xffffffffffffffff"), t2.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), t2.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), t2.SECP256K1_ORDER = Ri.CURVE.n, t2.SECP256K1_ORDER_DIV_2 = Ri.CURVE.n / BigInt(2), t2.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), t2.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", t2.KECCAK256_NULL = Ci.Buffer.from(t2.KECCAK256_NULL_S, "hex"), t2.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", t2.KECCAK256_RLP_ARRAY = Ci.Buffer.from(t2.KECCAK256_RLP_ARRAY_S, "hex"), t2.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", t2.KECCAK256_RLP = Ci.Buffer.from(t2.KECCAK256_RLP_S, "hex"), t2.RLP_EMPTY_STRING = Ci.Buffer.from([128]), t2.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
});
var zi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.GWEI_TO_WEI = void 0, t2.GWEI_TO_WEI = BigInt(1e9);
});
var $i = ye(function(e2, t2) {
  function r2(e3) {
    if (Array.isArray(e3)) {
      const t4 = [];
      let n3 = 0;
      for (let i3 = 0; i3 < e3.length; i3++) {
        const o3 = r2(e3[i3]);
        t4.push(o3), n3 += o3.length;
      }
      return l2(o2(n3, 192), ...t4);
    }
    const t3 = g2(e3);
    return 1 === t3.length && t3[0] < 128 ? t3 : l2(o2(t3.length, 128), t3);
  }
  function n2(e3, t3, r3) {
    if (r3 > e3.length)
      throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
    return e3.slice(t3, r3);
  }
  function i2(e3) {
    if (0 === e3[0])
      throw new Error("invalid RLP: extra zeros");
    return f2(h2(e3));
  }
  function o2(e3, t3) {
    if (e3 < 56)
      return Uint8Array.from([e3 + t3]);
    const r3 = p2(e3), n3 = p2(t3 + 55 + r3.length / 2);
    return Uint8Array.from(c2(n3 + r3));
  }
  function s2(e3, t3 = false) {
    if (null == e3 || 0 === e3.length)
      return Uint8Array.from([]);
    const r3 = a2(g2(e3));
    if (t3)
      return r3;
    if (0 !== r3.remainder.length)
      throw new Error("invalid RLP: remainder must be zero");
    return r3.data;
  }
  function a2(e3) {
    let t3, r3, o3, s3, u3;
    const h3 = [], f3 = e3[0];
    if (f3 <= 127)
      return { data: e3.slice(0, 1), remainder: e3.slice(1) };
    if (f3 <= 183) {
      if (t3 = f3 - 127, o3 = 128 === f3 ? Uint8Array.from([]) : n2(e3, 1, t3), 2 === t3 && o3[0] < 128)
        throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
      return { data: o3, remainder: e3.slice(t3) };
    }
    if (f3 <= 191) {
      if (r3 = f3 - 182, e3.length - 1 < r3)
        throw new Error("invalid RLP: not enough bytes for string length");
      if (t3 = i2(n2(e3, 1, r3)), t3 <= 55)
        throw new Error("invalid RLP: expected string length to be greater than 55");
      return o3 = n2(e3, r3, t3 + r3), { data: o3, remainder: e3.slice(t3 + r3) };
    }
    if (f3 <= 247) {
      for (t3 = f3 - 191, s3 = n2(e3, 1, t3); s3.length; )
        u3 = a2(s3), h3.push(u3.data), s3 = u3.remainder;
      return { data: h3, remainder: e3.slice(t3) };
    }
    {
      if (r3 = f3 - 246, t3 = i2(n2(e3, 1, r3)), t3 < 56)
        throw new Error("invalid RLP: encoded list too short");
      const o4 = r3 + t3;
      if (o4 > e3.length)
        throw new Error("invalid RLP: total length is larger than the data");
      for (s3 = n2(e3, r3, o4); s3.length; )
        u3 = a2(s3), h3.push(u3.data), s3 = u3.remainder;
      return { data: h3, remainder: e3.slice(o4) };
    }
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.RLP = t2.utils = t2.decode = t2.encode = void 0, t2.encode = r2, t2.decode = s2;
  const u2 = Array.from({ length: 256 }, (e3, t3) => t3.toString(16).padStart(2, "0"));
  function h2(e3) {
    let t3 = "";
    for (let r3 = 0; r3 < e3.length; r3++)
      t3 += u2[e3[r3]];
    return t3;
  }
  function f2(e3) {
    const t3 = Number.parseInt(e3, 16);
    if (Number.isNaN(t3))
      throw new Error("Invalid byte sequence");
    return t3;
  }
  function c2(e3) {
    if ("string" != typeof e3)
      throw new TypeError("hexToBytes: expected string, got " + typeof e3);
    if (e3.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const t3 = new Uint8Array(e3.length / 2);
    for (let r3 = 0; r3 < t3.length; r3++) {
      const n3 = 2 * r3;
      t3[r3] = f2(e3.slice(n3, n3 + 2));
    }
    return t3;
  }
  function l2(...e3) {
    if (1 === e3.length)
      return e3[0];
    const t3 = e3.reduce((e4, t4) => e4 + t4.length, 0), r3 = new Uint8Array(t3);
    for (let t4 = 0, n3 = 0; t4 < e3.length; t4++) {
      const i3 = e3[t4];
      r3.set(i3, n3), n3 += i3.length;
    }
    return r3;
  }
  function d2(e3) {
    return new TextEncoder().encode(e3);
  }
  function p2(e3) {
    if (e3 < 0)
      throw new Error("Invalid integer as argument, must be unsigned!");
    const t3 = e3.toString(16);
    return t3.length % 2 ? `0${t3}` : t3;
  }
  function y2(e3) {
    return e3.length >= 2 && "0" === e3[0] && "x" === e3[1];
  }
  function g2(e3) {
    if (e3 instanceof Uint8Array)
      return e3;
    if ("string" == typeof e3)
      return y2(e3) ? c2((t3 = "string" != typeof (r3 = e3) ? r3 : y2(r3) ? r3.slice(2) : r3).length % 2 ? `0${t3}` : t3) : d2(e3);
    var t3, r3;
    if ("number" == typeof e3 || "bigint" == typeof e3)
      return e3 ? c2(p2(e3)) : Uint8Array.from([]);
    if (null == e3)
      return Uint8Array.from([]);
    throw new Error("toBytes: received unsupported type " + typeof e3);
  }
  t2.utils = { bytesToHex: h2, concatBytes: l2, hexToBytes: c2, utf8ToBytes: d2 }, t2.RLP = { encode: r2, decode: s2 };
});
var Vi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.shake256 = t2.shake128 = t2.keccak_512 = t2.keccak_384 = t2.keccak_256 = t2.keccak_224 = t2.sha3_512 = t2.sha3_384 = t2.sha3_256 = t2.sha3_224 = t2.Keccak = t2.keccakP = void 0;
  const [r2, n2, i2] = [[], [], []], o2 = BigInt(0), s2 = BigInt(1), a2 = BigInt(2), u2 = BigInt(7), h2 = BigInt(256), f2 = BigInt(113);
  for (let e3 = 0, t3 = s2, c3 = 1, l3 = 0; e3 < 24; e3++) {
    [c3, l3] = [l3, (2 * c3 + 3 * l3) % 5], r2.push(2 * (5 * l3 + c3)), n2.push((e3 + 1) * (e3 + 2) / 2 % 64);
    let d3 = o2;
    for (let e4 = 0; e4 < 7; e4++)
      t3 = (t3 << s2 ^ (t3 >> u2) * f2) % h2, t3 & a2 && (d3 ^= s2 << (s2 << BigInt(e4)) - s2);
    i2.push(d3);
  }
  const [c2, l2] = Et.default.split(i2, true), d2 = (e3, t3, r3) => r3 > 32 ? Et.default.rotlBH(e3, t3, r3) : Et.default.rotlSH(e3, t3, r3), p2 = (e3, t3, r3) => r3 > 32 ? Et.default.rotlBL(e3, t3, r3) : Et.default.rotlSL(e3, t3, r3);
  function y2(e3, t3 = 24) {
    const i3 = new Uint32Array(10);
    for (let o3 = 24 - t3; o3 < 24; o3++) {
      for (let t5 = 0; t5 < 10; t5++)
        i3[t5] = e3[t5] ^ e3[t5 + 10] ^ e3[t5 + 20] ^ e3[t5 + 30] ^ e3[t5 + 40];
      for (let t5 = 0; t5 < 10; t5 += 2) {
        const r3 = (t5 + 8) % 10, n3 = (t5 + 2) % 10, o4 = i3[n3], s4 = i3[n3 + 1], a3 = d2(o4, s4, 1) ^ i3[r3], u3 = p2(o4, s4, 1) ^ i3[r3 + 1];
        for (let r4 = 0; r4 < 50; r4 += 10)
          e3[t5 + r4] ^= a3, e3[t5 + r4 + 1] ^= u3;
      }
      let t4 = e3[2], s3 = e3[3];
      for (let i4 = 0; i4 < 24; i4++) {
        const o4 = n2[i4], a3 = d2(t4, s3, o4), u3 = p2(t4, s3, o4), h3 = r2[i4];
        t4 = e3[h3], s3 = e3[h3 + 1], e3[h3] = a3, e3[h3 + 1] = u3;
      }
      for (let t5 = 0; t5 < 50; t5 += 10) {
        for (let r3 = 0; r3 < 10; r3++)
          i3[r3] = e3[t5 + r3];
        for (let r3 = 0; r3 < 10; r3++)
          e3[t5 + r3] ^= ~i3[(r3 + 2) % 10] & i3[(r3 + 4) % 10];
      }
      e3[0] ^= c2[o3], e3[1] ^= l2[o3];
    }
    i3.fill(0);
  }
  t2.keccakP = y2;
  class g2 extends gt.Hash {
    constructor(e3, t3, r3, n3 = false, i3 = 24) {
      if (super(), this.blockLen = e3, this.suffix = t3, this.outputLen = r3, this.enableXOF = n3, this.rounds = i3, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, pt.default.number(r3), 0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200), this.state32 = (0, gt.u32)(this.state);
    }
    keccak() {
      y2(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
    }
    update(e3) {
      pt.default.exists(this);
      const { blockLen: t3, state: r3 } = this, n3 = (e3 = (0, gt.toBytes)(e3)).length;
      for (let i3 = 0; i3 < n3; ) {
        const o3 = Math.min(t3 - this.pos, n3 - i3);
        for (let t4 = 0; t4 < o3; t4++)
          r3[this.pos++] ^= e3[i3++];
        this.pos === t3 && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state: e3, suffix: t3, pos: r3, blockLen: n3 } = this;
      e3[r3] ^= t3, 0 != (128 & t3) && r3 === n3 - 1 && this.keccak(), e3[n3 - 1] ^= 128, this.keccak();
    }
    writeInto(e3) {
      pt.default.exists(this, false), pt.default.bytes(e3), this.finish();
      const t3 = this.state, { blockLen: r3 } = this;
      for (let n3 = 0, i3 = e3.length; n3 < i3; ) {
        this.posOut >= r3 && this.keccak();
        const o3 = Math.min(r3 - this.posOut, i3 - n3);
        e3.set(t3.subarray(this.posOut, this.posOut + o3), n3), this.posOut += o3, n3 += o3;
      }
      return e3;
    }
    xofInto(e3) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(e3);
    }
    xof(e3) {
      return pt.default.number(e3), this.xofInto(new Uint8Array(e3));
    }
    digestInto(e3) {
      if (pt.default.output(e3, this), this.finished)
        throw new Error("digest() was already called");
      return this.writeInto(e3), this.destroy(), e3;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true, this.state.fill(0);
    }
    _cloneInto(e3) {
      const { blockLen: t3, suffix: r3, outputLen: n3, rounds: i3, enableXOF: o3 } = this;
      return e3 || (e3 = new g2(t3, r3, n3, o3, i3)), e3.state32.set(this.state32), e3.pos = this.pos, e3.posOut = this.posOut, e3.finished = this.finished, e3.rounds = i3, e3.suffix = r3, e3.outputLen = n3, e3.enableXOF = o3, e3.destroyed = this.destroyed, e3;
    }
  }
  t2.Keccak = g2;
  const m2 = (e3, t3, r3) => (0, gt.wrapConstructor)(() => new g2(t3, e3, r3));
  t2.sha3_224 = m2(6, 144, 28), t2.sha3_256 = m2(6, 136, 32), t2.sha3_384 = m2(6, 104, 48), t2.sha3_512 = m2(6, 72, 64), t2.keccak_224 = m2(1, 144, 28), t2.keccak_256 = m2(1, 136, 32), t2.keccak_384 = m2(1, 104, 48), t2.keccak_512 = m2(1, 72, 64);
  const w2 = (e3, t3, r3) => (0, gt.wrapConstructorWithOpts)((n3 = {}) => new g2(t3, e3, void 0 === n3.dkLen ? r3 : n3.dkLen, true));
  t2.shake128 = w2(31, 168, 16), t2.shake256 = w2(31, 136, 32);
});
var ji = ye(function(e2, t2) {
  var r2 = pe && pe.__importDefault || function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.crypto = t2.wrapHash = t2.equalsBytes = t2.hexToBytes = t2.bytesToUtf8 = t2.utf8ToBytes = t2.createView = t2.concatBytes = t2.toHex = t2.bytesToHex = t2.assertBytes = t2.assertBool = void 0;
  const n2 = r2(pt);
  t2.assertBool = n2.default.bool, t2.assertBytes = n2.default.bytes;
  var i2 = gt;
  Object.defineProperty(t2, "bytesToHex", { enumerable: true, get: function() {
    return i2.bytesToHex;
  } }), Object.defineProperty(t2, "toHex", { enumerable: true, get: function() {
    return i2.bytesToHex;
  } }), Object.defineProperty(t2, "concatBytes", { enumerable: true, get: function() {
    return i2.concatBytes;
  } }), Object.defineProperty(t2, "createView", { enumerable: true, get: function() {
    return i2.createView;
  } }), Object.defineProperty(t2, "utf8ToBytes", { enumerable: true, get: function() {
    return i2.utf8ToBytes;
  } }), t2.bytesToUtf8 = function(e3) {
    if (!(e3 instanceof Uint8Array))
      throw new TypeError("bytesToUtf8 expected Uint8Array, got " + typeof e3);
    return new TextDecoder().decode(e3);
  }, t2.hexToBytes = function(e3) {
    const t3 = e3.startsWith("0x") ? e3.substring(2) : e3;
    return (0, gt.hexToBytes)(t3);
  }, t2.equalsBytes = function(e3, t3) {
    if (e3.length !== t3.length)
      return false;
    for (let r3 = 0; r3 < e3.length; r3++)
      if (e3[r3] !== t3[r3])
        return false;
    return true;
  }, t2.wrapHash = function(e3) {
    return (t3) => (n2.default.bytes(t3), e3(t3));
  }, t2.crypto = (() => {
    const t3 = "object" == typeof self && "crypto" in self ? self.crypto : void 0, r3 = ge.bind(e2);
    return { node: r3 && !t3 ? r3("crypto") : void 0, web: t3 };
  })();
});
var Fi = ji;
var Hi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.keccak512 = t2.keccak384 = t2.keccak256 = t2.keccak224 = void 0, t2.keccak224 = (0, Fi.wrapHash)(Vi.keccak_224), t2.keccak256 = (() => {
    const e3 = (0, Fi.wrapHash)(Vi.keccak_256);
    return e3.create = Vi.keccak_256.create, e3;
  })(), t2.keccak384 = (0, Fi.wrapHash)(Vi.keccak_384), t2.keccak512 = (0, Fi.wrapHash)(Vi.keccak_512);
});
var Ki = ye(function(e2, t2) {
  function r2(e3) {
    if ("string" != typeof e3)
      throw new Error("[isHexPrefixed] input must be type 'string', received type " + typeof e3);
    return "0" === e3[0] && "x" === e3[1];
  }
  function n2(e3) {
    let t3 = e3;
    if ("string" != typeof t3)
      throw new Error("[padToEven] value must be type 'string', received " + typeof t3);
    return t3.length % 2 && (t3 = `0${t3}`), t3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isHexString = t2.getKeys = t2.fromAscii = t2.fromUtf8 = t2.toAscii = t2.arrayContainsArray = t2.getBinarySize = t2.padToEven = t2.stripHexPrefix = t2.isHexPrefixed = void 0, t2.isHexPrefixed = r2, t2.stripHexPrefix = (e3) => {
    if ("string" != typeof e3)
      throw new Error("[stripHexPrefix] input must be type 'string', received " + typeof e3);
    return r2(e3) ? e3.slice(2) : e3;
  }, t2.padToEven = n2, t2.getBinarySize = function(e3) {
    if ("string" != typeof e3)
      throw new Error("[getBinarySize] method requires input type 'string', received " + typeof e3);
    return Buffer.byteLength(e3, "utf8");
  }, t2.arrayContainsArray = function(e3, t3, r3) {
    if (true !== Array.isArray(e3))
      throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e3}'`);
    if (true !== Array.isArray(t3))
      throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof t3}'`);
    return t3[true === r3 ? "some" : "every"]((t4) => e3.indexOf(t4) >= 0);
  }, t2.toAscii = function(e3) {
    let t3 = "", r3 = 0;
    const n3 = e3.length;
    for ("0x" === e3.substring(0, 2) && (r3 = 2); r3 < n3; r3 += 2) {
      const n4 = parseInt(e3.substr(r3, 2), 16);
      t3 += String.fromCharCode(n4);
    }
    return t3;
  }, t2.fromUtf8 = function(e3) {
    return `0x${n2(Buffer.from(e3, "utf8").toString("hex")).replace(/^0+|0+$/g, "")}`;
  }, t2.fromAscii = function(e3) {
    let t3 = "";
    for (let r3 = 0; r3 < e3.length; r3++) {
      const n3 = e3.charCodeAt(r3).toString(16);
      t3 += n3.length < 2 ? `0${n3}` : n3;
    }
    return `0x${t3}`;
  }, t2.getKeys = function(e3, t3, r3) {
    if (!Array.isArray(e3))
      throw new Error("[getKeys] method expects input 'params' to be an array, got " + typeof e3);
    if ("string" != typeof t3)
      throw new Error("[getKeys] method expects input 'key' to be type 'string', got " + typeof e3);
    const n3 = [];
    for (let i2 = 0; i2 < e3.length; i2++) {
      let o2 = e3[i2][t3];
      if (true !== r3 || o2) {
        if ("string" != typeof o2)
          throw new Error("invalid abi - expected type 'string', received " + typeof o2);
      } else
        o2 = "";
      n3.push(o2);
    }
    return n3;
  }, t2.isHexString = function(e3, t3) {
    return !("string" != typeof e3 || !e3.match(/^0x[0-9A-Fa-f]*$/) || void 0 !== t3 && t3 > 0 && e3.length !== 2 + 2 * t3);
  };
});
var Gi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertIsString = t2.assertIsArray = t2.assertIsBuffer = t2.assertIsHexString = void 0, t2.assertIsHexString = function(e3) {
    if (!(0, Ki.isHexString)(e3))
      throw new Error(`This method only supports 0x-prefixed hex strings but input was: ${e3}`);
  }, t2.assertIsBuffer = function(e3) {
    if (!Buffer.isBuffer(e3))
      throw new Error(`This method only supports Buffer but input was: ${e3}`);
  }, t2.assertIsArray = function(e3) {
    if (!Array.isArray(e3))
      throw new Error(`This method only supports number arrays but input was: ${e3}`);
  }, t2.assertIsString = function(e3) {
    if ("string" != typeof e3)
      throw new Error(`This method only supports strings but input was: ${e3}`);
  };
});
var qi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.intToUnpaddedBuffer = t2.bigIntToUnpaddedBuffer = t2.bigIntToHex = t2.bufArrToArr = t2.arrToBufArr = t2.validateNoLeadingZeroes = t2.baToJSON = t2.toUtf8 = t2.short = t2.addHexPrefix = t2.toUnsigned = t2.fromSigned = t2.bufferToInt = t2.bigIntToBuffer = t2.bufferToBigInt = t2.bufferToHex = t2.toBuffer = t2.unpadHexString = t2.unpadArray = t2.unpadBuffer = t2.setLengthRight = t2.setLengthLeft = t2.zeros = t2.intToBuffer = t2.intToHex = void 0, t2.intToHex = function(e3) {
    if (!Number.isSafeInteger(e3) || e3 < 0)
      throw new Error(`Received an invalid integer type: ${e3}`);
    return `0x${e3.toString(16)}`;
  }, t2.intToBuffer = function(e3) {
    const r3 = (0, t2.intToHex)(e3);
    return Buffer.from((0, Ki.padToEven)(r3.slice(2)), "hex");
  }, t2.zeros = function(e3) {
    return Buffer.allocUnsafe(e3).fill(0);
  };
  const r2 = function(e3, r3, n3) {
    const i3 = (0, t2.zeros)(r3);
    return n3 ? e3.length < r3 ? (e3.copy(i3), i3) : e3.slice(0, r3) : e3.length < r3 ? (e3.copy(i3, r3 - e3.length), i3) : e3.slice(-r3);
  };
  t2.setLengthLeft = function(e3, t3) {
    return (0, Gi.assertIsBuffer)(e3), r2(e3, t3, false);
  }, t2.setLengthRight = function(e3, t3) {
    return (0, Gi.assertIsBuffer)(e3), r2(e3, t3, true);
  };
  const n2 = function(e3) {
    let t3 = e3[0];
    for (; e3.length > 0 && "0" === t3.toString(); )
      t3 = (e3 = e3.slice(1))[0];
    return e3;
  };
  function i2(e3) {
    const r3 = (0, t2.bufferToHex)(e3);
    return "0x" === r3 ? BigInt(0) : BigInt(r3);
  }
  function o2(e3) {
    return (0, t2.toBuffer)("0x" + e3.toString(16));
  }
  t2.unpadBuffer = function(e3) {
    return (0, Gi.assertIsBuffer)(e3), n2(e3);
  }, t2.unpadArray = function(e3) {
    return (0, Gi.assertIsArray)(e3), n2(e3);
  }, t2.unpadHexString = function(e3) {
    return (0, Gi.assertIsHexString)(e3), e3 = (0, Ki.stripHexPrefix)(e3), "0x" + n2(e3);
  }, t2.toBuffer = function(e3) {
    if (null == e3)
      return Buffer.allocUnsafe(0);
    if (Buffer.isBuffer(e3))
      return Buffer.from(e3);
    if (Array.isArray(e3) || e3 instanceof Uint8Array)
      return Buffer.from(e3);
    if ("string" == typeof e3) {
      if (!(0, Ki.isHexString)(e3))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${e3}`);
      return Buffer.from((0, Ki.padToEven)((0, Ki.stripHexPrefix)(e3)), "hex");
    }
    if ("number" == typeof e3)
      return (0, t2.intToBuffer)(e3);
    if ("bigint" == typeof e3) {
      if (e3 < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${e3}`);
      let t3 = e3.toString(16);
      return t3.length % 2 && (t3 = "0" + t3), Buffer.from(t3, "hex");
    }
    if (e3.toArray)
      return Buffer.from(e3.toArray());
    if (e3.toBuffer)
      return Buffer.from(e3.toBuffer());
    throw new Error("invalid type");
  }, t2.bufferToHex = function(e3) {
    return "0x" + (e3 = (0, t2.toBuffer)(e3)).toString("hex");
  }, t2.bufferToBigInt = i2, t2.bigIntToBuffer = o2, t2.bufferToInt = function(e3) {
    const t3 = Number(i2(e3));
    if (!Number.isSafeInteger(t3))
      throw new Error("Number exceeds 53 bits");
    return t3;
  }, t2.fromSigned = function(e3) {
    return BigInt.asIntN(256, i2(e3));
  }, t2.toUnsigned = function(e3) {
    return o2(BigInt.asUintN(256, e3));
  }, t2.addHexPrefix = function(e3) {
    return "string" != typeof e3 || (0, Ki.isHexPrefixed)(e3) ? e3 : "0x" + e3;
  }, t2.short = function(e3, t3 = 50) {
    const r3 = Buffer.isBuffer(e3) ? e3.toString("hex") : e3;
    return r3.length <= t3 ? r3 : r3.slice(0, t3) + "\u2026";
  }, t2.toUtf8 = function(e3) {
    if ((e3 = (0, Ki.stripHexPrefix)(e3)).length % 2 != 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return Buffer.from(e3.replace(/^(00)+|(00)+$/g, ""), "hex").toString("utf8");
  }, t2.baToJSON = function(e3) {
    if (Buffer.isBuffer(e3))
      return `0x${e3.toString("hex")}`;
    if (e3 instanceof Array) {
      const r3 = [];
      for (let n3 = 0; n3 < e3.length; n3++)
        r3.push((0, t2.baToJSON)(e3[n3]));
      return r3;
    }
  }, t2.validateNoLeadingZeroes = function(e3) {
    for (const [t3, r3] of Object.entries(e3))
      if (void 0 !== r3 && r3.length > 0 && 0 === r3[0])
        throw new Error(`${t3} cannot have leading zeroes, received: ${r3.toString("hex")}`);
  }, t2.arrToBufArr = function e3(t3) {
    return Array.isArray(t3) ? t3.map((t4) => e3(t4)) : Buffer.from(t3);
  }, t2.bufArrToArr = function e3(t3) {
    return Array.isArray(t3) ? t3.map((t4) => e3(t4)) : Uint8Array.from(t3 != null ? t3 : []);
  }, t2.bigIntToHex = (e3) => "0x" + e3.toString(16), t2.bigIntToUnpaddedBuffer = function(e3) {
    return (0, t2.unpadBuffer)(o2(e3));
  }, t2.intToUnpaddedBuffer = function(e3) {
    return (0, t2.unpadBuffer)((0, t2.intToBuffer)(e3));
  };
});
var Ji = Hi;
var Wi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.accountBodyToRLP = t2.accountBodyToSlim = t2.accountBodyFromSlim = t2.isZeroAddress = t2.zeroAddress = t2.importPublic = t2.privateToAddress = t2.privateToPublic = t2.publicToAddress = t2.pubToAddress = t2.isValidPublic = t2.isValidPrivate = t2.generateAddress2 = t2.generateAddress = t2.isValidChecksumAddress = t2.toChecksumAddress = t2.isValidAddress = t2.Account = void 0;
  const r2 = BigInt(0);
  class n2 {
    constructor(e3 = r2, t3 = r2, n3 = Di.KECCAK256_RLP, i3 = Di.KECCAK256_NULL) {
      this.nonce = e3, this.balance = t3, this.storageRoot = n3, this.codeHash = i3, this._validate();
    }
    static fromAccountData(e3) {
      const { nonce: t3, balance: r3, storageRoot: i3, codeHash: o3 } = e3;
      return new n2(void 0 !== t3 ? (0, qi.bufferToBigInt)((0, qi.toBuffer)(t3)) : void 0, void 0 !== r3 ? (0, qi.bufferToBigInt)((0, qi.toBuffer)(r3)) : void 0, void 0 !== i3 ? (0, qi.toBuffer)(i3) : void 0, void 0 !== o3 ? (0, qi.toBuffer)(o3) : void 0);
    }
    static fromRlpSerializedAccount(e3) {
      const t3 = (0, qi.arrToBufArr)($i.RLP.decode(Uint8Array.from(e3)));
      if (!Array.isArray(t3))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray(t3);
    }
    static fromValuesArray(e3) {
      const [t3, r3, i3, o3] = e3;
      return new n2((0, qi.bufferToBigInt)(t3), (0, qi.bufferToBigInt)(r3), i3, o3);
    }
    _validate() {
      if (this.nonce < r2)
        throw new Error("nonce must be greater than zero");
      if (this.balance < r2)
        throw new Error("balance must be greater than zero");
      if (32 !== this.storageRoot.length)
        throw new Error("storageRoot must have a length of 32");
      if (32 !== this.codeHash.length)
        throw new Error("codeHash must have a length of 32");
    }
    raw() {
      return [(0, qi.bigIntToUnpaddedBuffer)(this.nonce), (0, qi.bigIntToUnpaddedBuffer)(this.balance), this.storageRoot, this.codeHash];
    }
    serialize() {
      return Buffer.from($i.RLP.encode((0, qi.bufArrToArr)(this.raw())));
    }
    isContract() {
      return !this.codeHash.equals(Di.KECCAK256_NULL);
    }
    isEmpty() {
      return this.balance === r2 && this.nonce === r2 && this.codeHash.equals(Di.KECCAK256_NULL);
    }
  }
  function i2(e3) {
    const [t3, r3, n3, i3] = e3;
    return [t3, r3, 0 === (0, qi.arrToBufArr)(n3).length ? Di.KECCAK256_RLP : n3, 0 === (0, qi.arrToBufArr)(i3).length ? Di.KECCAK256_NULL : i3];
  }
  t2.Account = n2, t2.isValidAddress = function(e3) {
    try {
      (0, Gi.assertIsString)(e3);
    } catch (e4) {
      return false;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(e3);
  }, t2.toChecksumAddress = function(e3, t3) {
    (0, Gi.assertIsHexString)(e3);
    const r3 = (0, Ki.stripHexPrefix)(e3).toLowerCase();
    let n3 = "";
    void 0 !== t3 && (n3 = (0, qi.bufferToBigInt)((0, qi.toBuffer)(t3)).toString() + "0x");
    const i3 = Buffer.from(n3 + r3, "utf8"), o3 = (0, Fi.bytesToHex)((0, Ji.keccak256)(i3));
    let s2 = "0x";
    for (let e4 = 0; e4 < r3.length; e4++)
      parseInt(o3[e4], 16) >= 8 ? s2 += r3[e4].toUpperCase() : s2 += r3[e4];
    return s2;
  }, t2.isValidChecksumAddress = function(e3, r3) {
    return (0, t2.isValidAddress)(e3) && (0, t2.toChecksumAddress)(e3, r3) === e3;
  }, t2.generateAddress = function(e3, t3) {
    return (0, Gi.assertIsBuffer)(e3), (0, Gi.assertIsBuffer)(t3), (0, qi.bufferToBigInt)(t3) === BigInt(0) ? Buffer.from((0, Ji.keccak256)($i.RLP.encode((0, qi.bufArrToArr)([e3, null])))).slice(-20) : Buffer.from((0, Ji.keccak256)($i.RLP.encode((0, qi.bufArrToArr)([e3, t3])))).slice(-20);
  }, t2.generateAddress2 = function(e3, t3, r3) {
    if ((0, Gi.assertIsBuffer)(e3), (0, Gi.assertIsBuffer)(t3), (0, Gi.assertIsBuffer)(r3), 20 !== e3.length)
      throw new Error("Expected from to be of length 20");
    if (32 !== t3.length)
      throw new Error("Expected salt to be of length 32");
    const n3 = (0, Ji.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), e3, t3, (0, Ji.keccak256)(r3)]));
    return (0, qi.toBuffer)(n3).slice(-20);
  }, t2.isValidPrivate = function(e3) {
    return Ri.utils.isValidPrivateKey(e3);
  }, t2.isValidPublic = function(e3, t3 = false) {
    if ((0, Gi.assertIsBuffer)(e3), 64 === e3.length)
      try {
        return Ri.Point.fromHex(Buffer.concat([Buffer.from([4]), e3])), true;
      } catch (e4) {
        return false;
      }
    if (!t3)
      return false;
    try {
      return Ri.Point.fromHex(e3), true;
    } catch (e4) {
      return false;
    }
  }, t2.pubToAddress = function(e3, t3 = false) {
    if ((0, Gi.assertIsBuffer)(e3), t3 && 64 !== e3.length && (e3 = Buffer.from(Ri.Point.fromHex(e3).toRawBytes(false).slice(1))), 64 !== e3.length)
      throw new Error("Expected pubKey to be of length 64");
    return Buffer.from((0, Ji.keccak256)(e3)).slice(-20);
  }, t2.publicToAddress = t2.pubToAddress, t2.privateToPublic = function(e3) {
    return (0, Gi.assertIsBuffer)(e3), Buffer.from(Ri.Point.fromPrivateKey(e3).toRawBytes(false).slice(1));
  }, t2.privateToAddress = function(e3) {
    return (0, t2.publicToAddress)((0, t2.privateToPublic)(e3));
  }, t2.importPublic = function(e3) {
    return (0, Gi.assertIsBuffer)(e3), 64 !== e3.length && (e3 = Buffer.from(Ri.Point.fromHex(e3).toRawBytes(false).slice(1))), e3;
  }, t2.zeroAddress = function() {
    const e3 = (0, qi.zeros)(20);
    return (0, qi.bufferToHex)(e3);
  }, t2.isZeroAddress = function(e3) {
    try {
      (0, Gi.assertIsString)(e3);
    } catch (e4) {
      return false;
    }
    return (0, t2.zeroAddress)() === e3;
  }, t2.accountBodyFromSlim = i2;
  const o2 = new Uint8Array(0);
  t2.accountBodyToSlim = function(e3) {
    const [t3, r3, n3, i3] = e3;
    return [t3, r3, (0, qi.arrToBufArr)(n3).equals(Di.KECCAK256_RLP) ? o2 : n3, (0, qi.arrToBufArr)(i3).equals(Di.KECCAK256_NULL) ? o2 : i3];
  }, t2.accountBodyToRLP = function(e3, t3 = true) {
    const r3 = t3 ? i2(e3) : e3;
    return (0, qi.arrToBufArr)($i.RLP.encode(r3));
  };
});
var Zi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Address = void 0;
  class r2 {
    constructor(e3) {
      if (20 !== e3.length)
        throw new Error("Invalid address length");
      this.buf = e3;
    }
    static zero() {
      return new r2((0, qi.zeros)(20));
    }
    static fromString(e3) {
      if (!(0, Wi.isValidAddress)(e3))
        throw new Error("Invalid address");
      return new r2((0, qi.toBuffer)(e3));
    }
    static fromPublicKey(e3) {
      if (!Buffer.isBuffer(e3))
        throw new Error("Public key should be Buffer");
      const t3 = (0, Wi.pubToAddress)(e3);
      return new r2(t3);
    }
    static fromPrivateKey(e3) {
      if (!Buffer.isBuffer(e3))
        throw new Error("Private key should be Buffer");
      const t3 = (0, Wi.privateToAddress)(e3);
      return new r2(t3);
    }
    static generate(e3, t3) {
      if ("bigint" != typeof t3)
        throw new Error("Expected nonce to be a bigint");
      return new r2((0, Wi.generateAddress)(e3.buf, (0, qi.bigIntToBuffer)(t3)));
    }
    static generate2(e3, t3, n2) {
      if (!Buffer.isBuffer(t3))
        throw new Error("Expected salt to be a Buffer");
      if (!Buffer.isBuffer(n2))
        throw new Error("Expected initCode to be a Buffer");
      return new r2((0, Wi.generateAddress2)(e3.buf, t3, n2));
    }
    equals(e3) {
      return this.buf.equals(e3.buf);
    }
    isZero() {
      return this.equals(r2.zero());
    }
    isPrecompileOrSystemAddress() {
      const e3 = (0, qi.bufferToBigInt)(this.buf), t3 = BigInt(0), r3 = BigInt("0xffff");
      return e3 >= t3 && e3 <= r3;
    }
    toString() {
      return "0x" + this.buf.toString("hex");
    }
    toBuffer() {
      return Buffer.from(this.buf);
    }
  }
  t2.Address = r2;
});
var Yi = ye(function(e2, t2) {
  var r2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.toType = t2.TypeOutput = void 0, function(e3) {
    e3[e3.Number = 0] = "Number", e3[e3.BigInt = 1] = "BigInt", e3[e3.Buffer = 2] = "Buffer", e3[e3.PrefixedHexString = 3] = "PrefixedHexString";
  }(r2 = t2.TypeOutput || (t2.TypeOutput = {})), t2.toType = function(e3, t3) {
    if (null === e3)
      return null;
    if (void 0 === e3)
      return;
    if ("string" == typeof e3 && !(0, Ki.isHexString)(e3))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${e3}`);
    if ("number" == typeof e3 && !Number.isSafeInteger(e3))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const n2 = (0, qi.toBuffer)(e3);
    switch (t3) {
      case r2.Buffer:
        return n2;
      case r2.BigInt:
        return (0, qi.bufferToBigInt)(n2);
      case r2.Number: {
        const e4 = (0, qi.bufferToBigInt)(n2);
        if (e4 > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(e4);
      }
      case r2.PrefixedHexString:
        return (0, qi.bufferToHex)(n2);
      default:
        throw new Error("unknown outputType");
    }
  };
});
var Xi = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Withdrawal = void 0;
  class r2 {
    constructor(e3, t3, r3, n2) {
      this.index = e3, this.validatorIndex = t3, this.address = r3, this.amount = n2;
    }
    static fromWithdrawalData(e3) {
      const { index: t3, validatorIndex: n2, address: i2, amount: o2 } = e3, s2 = (0, Yi.toType)(t3, Yi.TypeOutput.BigInt), a2 = (0, Yi.toType)(n2, Yi.TypeOutput.BigInt), u2 = new Zi.Address((0, Yi.toType)(i2, Yi.TypeOutput.Buffer)), h2 = (0, Yi.toType)(o2, Yi.TypeOutput.BigInt);
      return new r2(s2, a2, u2, h2);
    }
    static fromValuesArray(e3) {
      if (4 !== e3.length)
        throw Error(`Invalid withdrawalArray length expected=4 actual=${e3.length}`);
      const [t3, n2, i2, o2] = e3;
      return r2.fromWithdrawalData({ index: t3, validatorIndex: n2, address: i2, amount: o2 });
    }
    static toBufferArray(e3) {
      const { index: t3, validatorIndex: r3, address: n2, amount: i2 } = e3, o2 = (0, Yi.toType)(t3, Yi.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Yi.toType)(t3, Yi.TypeOutput.Buffer), s2 = (0, Yi.toType)(r3, Yi.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Yi.toType)(r3, Yi.TypeOutput.Buffer);
      let a2;
      return a2 = n2 instanceof Zi.Address ? n2.buf : (0, Yi.toType)(n2, Yi.TypeOutput.Buffer), [o2, s2, a2, (0, Yi.toType)(i2, Yi.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Yi.toType)(i2, Yi.TypeOutput.Buffer)];
    }
    raw() {
      return r2.toBufferArray(this);
    }
    toValue() {
      return { index: this.index, validatorIndex: this.validatorIndex, address: this.address.buf, amount: this.amount };
    }
    toJSON() {
      return { index: (0, qi.bigIntToHex)(this.index), validatorIndex: (0, qi.bigIntToHex)(this.validatorIndex), address: "0x" + this.address.buf.toString("hex"), amount: (0, qi.bigIntToHex)(this.amount) };
    }
  }
  t2.Withdrawal = r2;
});
var Qi = ye(function(e2, t2) {
  function r2(e3, t3) {
    return e3 === BigInt(0) || e3 === BigInt(1) ? e3 : void 0 === t3 ? e3 - BigInt(27) : e3 - (t3 * BigInt(2) + BigInt(35));
  }
  function n2(e3) {
    return e3 === BigInt(0) || e3 === BigInt(1);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.hashPersonalMessage = t2.isValidSignature = t2.fromRpcSig = t2.toCompactSig = t2.toRpcSig = t2.ecrecover = t2.ecsign = void 0, t2.ecsign = function(e3, t3, r3) {
    const [n3, i2] = (0, Ri.signSync)(e3, t3, { recovered: true, der: false });
    return { r: Buffer.from(n3.slice(0, 32)), s: Buffer.from(n3.slice(32, 64)), v: void 0 === r3 ? BigInt(i2 + 27) : BigInt(i2 + 35) + BigInt(r3) * BigInt(2) };
  }, t2.ecrecover = function(e3, t3, i2, o2, s2) {
    const a2 = Buffer.concat([(0, qi.setLengthLeft)(i2, 32), (0, qi.setLengthLeft)(o2, 32)], 64), u2 = r2(t3, s2);
    if (!n2(u2))
      throw new Error("Invalid signature v value");
    const h2 = (0, Ri.recoverPublicKey)(e3, a2, Number(u2));
    return Buffer.from(h2.slice(1));
  }, t2.toRpcSig = function(e3, t3, i2, o2) {
    if (!n2(r2(e3, o2)))
      throw new Error("Invalid signature v value");
    return (0, qi.bufferToHex)(Buffer.concat([(0, qi.setLengthLeft)(t3, 32), (0, qi.setLengthLeft)(i2, 32), (0, qi.toBuffer)(e3)]));
  }, t2.toCompactSig = function(e3, t3, i2, o2) {
    if (!n2(r2(e3, o2)))
      throw new Error("Invalid signature v value");
    let s2 = i2;
    return (e3 > BigInt(28) && e3 % BigInt(2) === BigInt(1) || e3 === BigInt(1) || e3 === BigInt(28)) && (s2 = Buffer.from(i2), s2[0] |= 128), (0, qi.bufferToHex)(Buffer.concat([(0, qi.setLengthLeft)(t3, 32), (0, qi.setLengthLeft)(s2, 32)]));
  }, t2.fromRpcSig = function(e3) {
    const t3 = (0, qi.toBuffer)(e3);
    let r3, n3, i2;
    if (t3.length >= 65)
      r3 = t3.slice(0, 32), n3 = t3.slice(32, 64), i2 = (0, qi.bufferToBigInt)(t3.slice(64));
    else {
      if (64 !== t3.length)
        throw new Error("Invalid signature length");
      r3 = t3.slice(0, 32), n3 = t3.slice(32, 64), i2 = BigInt((0, qi.bufferToInt)(t3.slice(32, 33)) >> 7), n3[0] &= 127;
    }
    return i2 < 27 && (i2 += BigInt(27)), { v: i2, r: r3, s: n3 };
  }, t2.isValidSignature = function(e3, t3, i2, o2 = true, s2) {
    if (32 !== t3.length || 32 !== i2.length)
      return false;
    if (!n2(r2(e3, s2)))
      return false;
    const a2 = (0, qi.bufferToBigInt)(t3), u2 = (0, qi.bufferToBigInt)(i2);
    return !(a2 === BigInt(0) || a2 >= Di.SECP256K1_ORDER || u2 === BigInt(0) || u2 >= Di.SECP256K1_ORDER || o2 && u2 >= Di.SECP256K1_ORDER_DIV_2);
  }, t2.hashPersonalMessage = function(e3) {
    (0, Gi.assertIsBuffer)(e3);
    const t3 = Buffer.from(`Ethereum Signed Message:
${e3.length}`, "utf-8");
    return Buffer.from((0, Ji.keccak256)(Buffer.concat([t3, e3])));
  };
});
var eo = ye(function(e2, t2) {
  function r2(e3, t3) {
    const r3 = BigInt(1) << BigInt(e3);
    if (t3 >= r3)
      throw new Error(`index ${t3} too large for depth ${e3}`);
    return r3 | t3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.gindexChild = t2.gindexParent = t2.gindexSibling = t2.concatGindices = t2.getGindexBits = t2.gindexIterator = t2.getGindicesAtDepth = t2.iterateAtDepth = t2.countToDepth = t2.convertGindexToBitstring = t2.toGindexBitstring = t2.toGindex = t2.bitIndexBigInt = void 0, t2.bitIndexBigInt = function(e3) {
    return e3.toString(2).length - 1;
  }, t2.toGindex = r2, t2.toGindexBitstring = function(e3, t3) {
    const r3 = t3 ? Number(t3).toString(2) : "";
    if (r3.length > e3)
      throw new Error("index too large for depth");
    return "1" + r3.padStart(e3, "0");
  }, t2.convertGindexToBitstring = function(e3) {
    if ("string" == typeof e3) {
      if (0 === e3.length)
        throw new Error(n2);
      return e3;
    }
    if (e3 < 1)
      throw new Error(n2);
    return e3.toString(2);
  }, t2.countToDepth = function(e3) {
    return e3 <= 1 ? 0 : (e3 - BigInt(1)).toString(2).length;
  }, t2.iterateAtDepth = function(e3, t3, n3) {
    if (t3 + n3 > BigInt(1) << BigInt(e3))
      throw new Error("Too large for depth");
    let i2 = r2(e3, t3);
    const o2 = i2 + n3;
    return { [Symbol.iterator]: () => ({ next() {
      if (i2 < o2) {
        const e4 = i2;
        return i2++, { done: false, value: e4 };
      }
      return { done: true, value: void 0 };
    } }) };
  }, t2.getGindicesAtDepth = function(e3, t3, n3) {
    if (t3 + n3 > BigInt(1) << BigInt(e3))
      throw new Error("Too large for depth");
    let i2 = r2(e3, BigInt(t3));
    const o2 = [];
    for (let e4 = 0; e4 < n3; e4++)
      o2.push(i2++);
    return o2;
  };
  const n2 = "Invalid gindex";
  t2.gindexIterator = function(e3) {
    let t3;
    if ("string" == typeof e3) {
      if (!e3.length)
        throw new Error(n2);
      t3 = e3;
    } else {
      if (e3 < 1)
        throw new Error(n2);
      t3 = e3.toString(2);
    }
    let r3 = 1;
    const i2 = () => {
      if (r3 === t3.length)
        return { done: true, value: void 0 };
      const e4 = Number(t3[r3]);
      return r3++, { done: false, value: e4 };
    };
    return { [Symbol.iterator]: () => ({ next: i2 }), remainingBitLength: () => t3.length - r3 };
  }, t2.getGindexBits = function(e3) {
    let t3;
    if ("string" == typeof e3) {
      if (!e3.length)
        throw new Error(n2);
      t3 = e3;
    } else {
      if (e3 < 1)
        throw new Error(n2);
      t3 = e3.toString(2);
    }
    const r3 = [];
    for (let e4 = 1; e4 < t3.length; e4++)
      r3.push(Number(t3[e4]));
    return r3;
  }, t2.concatGindices = function(e3) {
    return BigInt(e3.reduce((e4, t3) => e4 + t3.toString(2).slice(1), "0b1"));
  }, t2.gindexSibling = function(e3) {
    return e3 ^ BigInt(1);
  }, t2.gindexParent = function(e3) {
    return e3 / BigInt(2);
  }, t2.gindexChild = function(e3, t3) {
    return e3 * BigInt(2) + BigInt(t3);
  };
});
var to = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.wasmCode = void 0, t2.wasmCode = Uint8Array.from([0, 97, 115, 109, 1, 0, 0, 0, 1, 31, 6, 96, 1, 127, 0, 96, 2, 127, 127, 0, 96, 0, 0, 96, 1, 127, 1, 127, 96, 3, 127, 127, 127, 0, 96, 4, 127, 127, 127, 127, 0, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 5, 3, 16, 15, 0, 3, 1, 3, 2, 2, 4, 1, 1, 3, 0, 0, 0, 1, 2, 5, 3, 1, 0, 1, 6, 172, 1, 34, 127, 0, 65, 128, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 7, 86, 9, 6, 109, 101, 109, 111, 114, 121, 2, 0, 12, 73, 78, 80, 85, 84, 95, 76, 69, 78, 71, 84, 72, 3, 0, 5, 105, 110, 112, 117, 116, 3, 28, 6, 111, 117, 116, 112, 117, 116, 3, 30, 4, 105, 110, 105, 116, 0, 6, 6, 117, 112, 100, 97, 116, 101, 0, 9, 5, 102, 105, 110, 97, 108, 0, 11, 6, 100, 105, 103, 101, 115, 116, 0, 12, 8, 100, 105, 103, 101, 115, 116, 54, 52, 0, 14, 8, 1, 15, 10, 202, 14, 15, 70, 1, 2, 127, 32, 0, 63, 0, 34, 2, 65, 16, 116, 34, 1, 75, 4, 64, 32, 2, 32, 0, 32, 1, 107, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 11, 32, 0, 36, 23, 11, 82, 1, 3, 127, 32, 0, 65, 240, 255, 255, 255, 3, 75, 4, 64, 0, 11, 35, 23, 65, 16, 106, 34, 2, 32, 0, 65, 15, 106, 65, 112, 113, 34, 1, 65, 16, 32, 1, 65, 16, 75, 27, 34, 3, 106, 16, 1, 32, 2, 65, 16, 107, 34, 1, 32, 3, 54, 2, 0, 32, 1, 65, 1, 54, 2, 4, 32, 1, 65, 0, 54, 2, 8, 32, 1, 32, 0, 54, 2, 12, 32, 2, 11, 37, 1, 1, 127, 3, 64, 32, 1, 4, 64, 32, 0, 34, 2, 65, 1, 106, 33, 0, 32, 2, 65, 0, 58, 0, 0, 32, 1, 65, 1, 107, 33, 1, 12, 1, 11, 11, 11, 41, 1, 1, 127, 32, 0, 65, 240, 255, 255, 255, 3, 75, 4, 64, 65, 128, 5, 65, 176, 5, 65, 54, 65, 42, 16, 0, 0, 11, 32, 0, 16, 2, 34, 1, 32, 0, 16, 3, 32, 1, 11, 71, 0, 65, 180, 2, 40, 2, 0, 36, 1, 65, 228, 4, 40, 2, 0, 36, 2, 65, 224, 5, 36, 22, 65, 224, 5, 36, 23, 65, 192, 0, 16, 4, 36, 24, 35, 24, 36, 25, 65, 128, 2, 16, 4, 36, 26, 35, 26, 36, 27, 65, 128, 4, 16, 4, 36, 28, 35, 28, 36, 29, 65, 32, 16, 4, 36, 30, 35, 30, 36, 31, 11, 74, 0, 65, 231, 204, 167, 208, 6, 36, 3, 65, 133, 221, 158, 219, 123, 36, 4, 65, 242, 230, 187, 227, 3, 36, 5, 65, 186, 234, 191, 170, 122, 36, 6, 65, 255, 164, 185, 136, 5, 36, 7, 65, 140, 209, 149, 216, 121, 36, 8, 65, 171, 179, 143, 252, 1, 36, 9, 65, 153, 154, 131, 223, 5, 36, 10, 65, 0, 36, 32, 65, 0, 36, 33, 11, 103, 1, 2, 127, 2, 64, 32, 2, 33, 3, 32, 0, 32, 1, 70, 13, 0, 32, 0, 32, 1, 73, 4, 64, 3, 64, 32, 3, 4, 64, 32, 0, 34, 2, 65, 1, 106, 33, 0, 32, 1, 34, 4, 65, 1, 106, 33, 1, 32, 2, 32, 4, 45, 0, 0, 58, 0, 0, 32, 3, 65, 1, 107, 33, 3, 12, 1, 11, 11, 5, 3, 64, 32, 3, 4, 64, 32, 3, 65, 1, 107, 34, 3, 32, 0, 106, 32, 1, 32, 3, 106, 45, 0, 0, 58, 0, 0, 12, 1, 11, 11, 11, 11, 11, 231, 3, 1, 1, 127, 35, 3, 36, 11, 35, 4, 36, 12, 35, 5, 36, 13, 35, 6, 36, 14, 35, 7, 36, 15, 35, 8, 36, 16, 35, 9, 36, 17, 35, 10, 36, 18, 65, 0, 36, 19, 3, 64, 35, 19, 65, 16, 73, 4, 64, 32, 0, 35, 19, 65, 2, 116, 106, 32, 1, 35, 19, 65, 2, 116, 34, 2, 106, 45, 0, 0, 65, 24, 116, 32, 1, 32, 2, 65, 1, 106, 106, 45, 0, 0, 65, 16, 116, 114, 32, 1, 32, 2, 65, 2, 106, 106, 45, 0, 0, 65, 8, 116, 114, 32, 1, 32, 2, 65, 3, 106, 106, 45, 0, 0, 114, 54, 2, 0, 35, 19, 65, 1, 106, 36, 19, 12, 1, 11, 11, 65, 16, 36, 19, 3, 64, 35, 19, 65, 192, 0, 73, 4, 64, 32, 0, 35, 19, 65, 2, 116, 106, 32, 0, 35, 19, 65, 16, 107, 65, 2, 116, 106, 40, 2, 0, 32, 0, 35, 19, 65, 7, 107, 65, 2, 116, 106, 40, 2, 0, 32, 0, 35, 19, 65, 2, 107, 65, 2, 116, 106, 40, 2, 0, 34, 1, 65, 17, 120, 32, 1, 65, 19, 120, 115, 32, 1, 65, 10, 118, 115, 106, 32, 0, 35, 19, 65, 15, 107, 65, 2, 116, 106, 40, 2, 0, 34, 1, 65, 7, 120, 32, 1, 65, 18, 120, 115, 32, 1, 65, 3, 118, 115, 106, 106, 54, 2, 0, 35, 19, 65, 1, 106, 36, 19, 12, 1, 11, 11, 65, 0, 36, 19, 3, 64, 35, 19, 65, 192, 0, 73, 4, 64, 32, 0, 35, 19, 65, 2, 116, 106, 40, 2, 0, 35, 1, 35, 19, 65, 2, 116, 106, 40, 2, 0, 35, 18, 35, 15, 34, 1, 65, 6, 120, 32, 1, 65, 11, 120, 115, 32, 1, 65, 25, 120, 115, 106, 35, 15, 34, 1, 35, 16, 113, 35, 17, 32, 1, 65, 127, 115, 113, 115, 106, 106, 106, 36, 20, 35, 11, 34, 1, 65, 2, 120, 32, 1, 65, 13, 120, 115, 32, 1, 65, 22, 120, 115, 35, 11, 34, 1, 35, 12, 34, 2, 113, 32, 1, 35, 13, 34, 1, 113, 115, 32, 1, 32, 2, 113, 115, 106, 36, 21, 35, 17, 36, 18, 35, 16, 36, 17, 35, 15, 36, 16, 35, 14, 35, 20, 106, 36, 15, 35, 13, 36, 14, 35, 12, 36, 13, 35, 11, 36, 12, 35, 20, 35, 21, 106, 36, 11, 35, 19, 65, 1, 106, 36, 19, 12, 1, 11, 11, 35, 3, 35, 11, 106, 36, 3, 35, 4, 35, 12, 106, 36, 4, 35, 5, 35, 13, 106, 36, 5, 35, 6, 35, 14, 106, 36, 6, 35, 7, 35, 15, 106, 36, 7, 35, 8, 35, 16, 106, 36, 8, 35, 9, 35, 17, 106, 36, 9, 35, 10, 35, 18, 106, 36, 10, 11, 177, 1, 1, 2, 127, 32, 1, 35, 33, 106, 36, 33, 35, 32, 4, 64, 65, 192, 0, 35, 32, 107, 32, 1, 76, 4, 64, 35, 25, 35, 32, 106, 32, 0, 65, 192, 0, 35, 32, 107, 16, 7, 35, 32, 65, 192, 0, 35, 32, 107, 106, 36, 32, 65, 192, 0, 35, 32, 107, 33, 2, 32, 1, 65, 192, 0, 35, 32, 107, 107, 33, 1, 35, 27, 35, 25, 16, 8, 65, 0, 36, 32, 5, 35, 25, 35, 32, 106, 32, 0, 32, 1, 16, 7, 32, 1, 35, 32, 106, 36, 32, 15, 11, 11, 3, 64, 32, 3, 32, 1, 65, 192, 0, 109, 72, 4, 64, 35, 27, 32, 0, 32, 2, 106, 16, 8, 32, 3, 65, 1, 106, 33, 3, 32, 2, 65, 64, 107, 33, 2, 12, 1, 11, 11, 32, 1, 65, 63, 113, 4, 64, 35, 25, 35, 32, 106, 32, 0, 32, 2, 106, 32, 1, 65, 63, 113, 34, 0, 16, 7, 32, 0, 35, 32, 106, 36, 32, 11, 11, 25, 0, 32, 0, 65, 128, 254, 131, 120, 113, 65, 8, 119, 32, 0, 65, 255, 129, 252, 7, 113, 65, 8, 120, 114, 11, 173, 2, 1, 2, 127, 35, 33, 65, 63, 113, 65, 63, 72, 4, 64, 35, 25, 35, 32, 106, 65, 128, 1, 58, 0, 0, 35, 32, 65, 1, 106, 36, 32, 11, 35, 33, 65, 63, 113, 65, 56, 78, 4, 64, 35, 25, 35, 32, 106, 34, 1, 65, 192, 0, 35, 32, 107, 106, 33, 2, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 1, 65, 0, 58, 0, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 35, 27, 35, 25, 16, 8, 65, 0, 36, 32, 11, 35, 33, 65, 63, 113, 65, 63, 78, 4, 64, 35, 25, 35, 32, 106, 65, 128, 1, 58, 0, 0, 35, 32, 65, 1, 106, 36, 32, 11, 35, 25, 35, 32, 106, 34, 1, 65, 56, 35, 32, 107, 106, 33, 2, 3, 64, 32, 1, 32, 2, 73, 4, 64, 32, 1, 65, 0, 58, 0, 0, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 35, 25, 65, 56, 106, 35, 33, 65, 128, 128, 128, 128, 2, 109, 16, 10, 54, 2, 0, 35, 25, 65, 60, 106, 35, 33, 65, 3, 116, 16, 10, 54, 2, 0, 35, 27, 35, 25, 16, 8, 32, 0, 35, 3, 16, 10, 54, 2, 0, 32, 0, 65, 4, 106, 35, 4, 16, 10, 54, 2, 0, 32, 0, 65, 8, 106, 35, 5, 16, 10, 54, 2, 0, 32, 0, 65, 12, 106, 35, 6, 16, 10, 54, 2, 0, 32, 0, 65, 16, 106, 35, 7, 16, 10, 54, 2, 0, 32, 0, 65, 20, 106, 35, 8, 16, 10, 54, 2, 0, 32, 0, 65, 24, 106, 35, 9, 16, 10, 54, 2, 0, 32, 0, 65, 28, 106, 35, 10, 16, 10, 54, 2, 0, 11, 14, 0, 16, 6, 35, 29, 32, 0, 16, 9, 35, 31, 16, 11, 11, 253, 1, 1, 2, 127, 35, 3, 36, 11, 35, 4, 36, 12, 35, 5, 36, 13, 35, 6, 36, 14, 35, 7, 36, 15, 35, 8, 36, 16, 35, 9, 36, 17, 35, 10, 36, 18, 65, 0, 36, 19, 3, 64, 35, 19, 65, 192, 0, 73, 4, 64, 32, 0, 35, 19, 65, 2, 116, 106, 40, 2, 0, 35, 18, 35, 15, 34, 1, 65, 6, 120, 32, 1, 65, 11, 120, 115, 32, 1, 65, 25, 120, 115, 106, 35, 15, 34, 1, 35, 16, 113, 35, 17, 32, 1, 65, 127, 115, 113, 115, 106, 106, 36, 20, 35, 11, 34, 1, 65, 2, 120, 32, 1, 65, 13, 120, 115, 32, 1, 65, 22, 120, 115, 35, 11, 34, 1, 35, 12, 34, 2, 113, 32, 1, 35, 13, 34, 1, 113, 115, 32, 1, 32, 2, 113, 115, 106, 36, 21, 35, 17, 36, 18, 35, 16, 36, 17, 35, 15, 36, 16, 35, 14, 35, 20, 106, 36, 15, 35, 13, 36, 14, 35, 12, 36, 13, 35, 11, 36, 12, 35, 20, 35, 21, 106, 36, 11, 35, 19, 65, 1, 106, 36, 19, 12, 1, 11, 11, 35, 3, 35, 11, 106, 36, 3, 35, 4, 35, 12, 106, 36, 4, 35, 5, 35, 13, 106, 36, 5, 35, 6, 35, 14, 106, 36, 6, 35, 7, 35, 15, 106, 36, 7, 35, 8, 35, 16, 106, 36, 8, 35, 9, 35, 17, 106, 36, 9, 35, 10, 35, 18, 106, 36, 10, 11, 107, 0, 16, 6, 35, 27, 32, 0, 16, 8, 35, 2, 16, 13, 32, 1, 35, 3, 16, 10, 54, 2, 0, 32, 1, 65, 4, 106, 35, 4, 16, 10, 54, 2, 0, 32, 1, 65, 8, 106, 35, 5, 16, 10, 54, 2, 0, 32, 1, 65, 12, 106, 35, 6, 16, 10, 54, 2, 0, 32, 1, 65, 16, 106, 35, 7, 16, 10, 54, 2, 0, 32, 1, 65, 20, 106, 35, 8, 16, 10, 54, 2, 0, 32, 1, 65, 24, 106, 35, 9, 16, 10, 54, 2, 0, 32, 1, 65, 28, 106, 35, 10, 16, 10, 54, 2, 0, 11, 4, 0, 16, 5, 11, 11, 222, 5, 6, 0, 65, 17, 11, 143, 2, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 152, 47, 138, 66, 145, 68, 55, 113, 207, 251, 192, 181, 165, 219, 181, 233, 91, 194, 86, 57, 241, 17, 241, 89, 164, 130, 63, 146, 213, 94, 28, 171, 152, 170, 7, 216, 1, 91, 131, 18, 190, 133, 49, 36, 195, 125, 12, 85, 116, 93, 190, 114, 254, 177, 222, 128, 167, 6, 220, 155, 116, 241, 155, 193, 193, 105, 155, 228, 134, 71, 190, 239, 198, 157, 193, 15, 204, 161, 12, 36, 111, 44, 233, 45, 170, 132, 116, 74, 220, 169, 176, 92, 218, 136, 249, 118, 82, 81, 62, 152, 109, 198, 49, 168, 200, 39, 3, 176, 199, 127, 89, 191, 243, 11, 224, 198, 71, 145, 167, 213, 81, 99, 202, 6, 103, 41, 41, 20, 133, 10, 183, 39, 56, 33, 27, 46, 252, 109, 44, 77, 19, 13, 56, 83, 84, 115, 10, 101, 187, 10, 106, 118, 46, 201, 194, 129, 133, 44, 114, 146, 161, 232, 191, 162, 75, 102, 26, 168, 112, 139, 75, 194, 163, 81, 108, 199, 25, 232, 146, 209, 36, 6, 153, 214, 133, 53, 14, 244, 112, 160, 106, 16, 22, 193, 164, 25, 8, 108, 55, 30, 76, 119, 72, 39, 181, 188, 176, 52, 179, 12, 28, 57, 74, 170, 216, 78, 79, 202, 156, 91, 243, 111, 46, 104, 238, 130, 143, 116, 111, 99, 165, 120, 20, 120, 200, 132, 8, 2, 199, 140, 250, 255, 190, 144, 235, 108, 80, 164, 247, 163, 249, 190, 242, 120, 113, 198, 0, 65, 160, 2, 11, 29, 16, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 16, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 0, 1, 0, 0, 64, 0, 65, 193, 2, 11, 143, 2, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 152, 47, 138, 194, 145, 68, 55, 113, 207, 251, 192, 181, 165, 219, 181, 233, 91, 194, 86, 57, 241, 17, 241, 89, 164, 130, 63, 146, 213, 94, 28, 171, 152, 170, 7, 216, 1, 91, 131, 18, 190, 133, 49, 36, 195, 125, 12, 85, 116, 93, 190, 114, 254, 177, 222, 128, 167, 6, 220, 155, 116, 243, 155, 193, 193, 105, 155, 100, 134, 71, 254, 240, 198, 237, 225, 15, 84, 242, 12, 36, 111, 52, 233, 79, 190, 132, 201, 108, 30, 65, 185, 97, 250, 136, 249, 22, 82, 81, 198, 242, 109, 90, 142, 168, 101, 252, 25, 176, 199, 158, 217, 185, 195, 49, 18, 154, 160, 234, 14, 231, 43, 35, 177, 253, 176, 62, 53, 199, 213, 186, 105, 48, 95, 109, 151, 203, 143, 17, 15, 90, 253, 238, 30, 220, 137, 182, 53, 10, 4, 122, 11, 222, 157, 202, 244, 88, 22, 91, 93, 225, 134, 62, 127, 0, 128, 137, 8, 55, 50, 234, 7, 165, 55, 149, 171, 111, 16, 97, 64, 23, 241, 214, 140, 13, 109, 59, 170, 205, 55, 190, 187, 192, 218, 59, 97, 131, 99, 163, 72, 219, 49, 233, 2, 11, 167, 92, 209, 111, 202, 250, 26, 82, 49, 132, 51, 49, 149, 26, 212, 110, 144, 120, 67, 109, 242, 145, 156, 195, 189, 171, 204, 158, 230, 160, 201, 181, 60, 182, 47, 83, 198, 65, 199, 210, 163, 126, 35, 7, 104, 75, 149, 164, 118, 29, 25, 76, 0, 65, 208, 4, 11, 29, 16, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 16, 0, 0, 0, 80, 1, 0, 0, 80, 1, 0, 0, 0, 1, 0, 0, 64, 0, 65, 240, 4, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 160, 5, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115]);
});
var ro = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.newInstance = void 0;
  const r2 = new WebAssembly.Module(to.wasmCode), n2 = { env: { abort: function(e3, t3, r3, n3) {
    throw Error(`abort: ${e3}:${t3}:${r3}:${n3}`);
  } } };
  t2.newInstance = function() {
    return new WebAssembly.Instance(r2, n2).exports;
  };
});
var no = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.byteArrayToHashObject = t2.hashObjectToByteArray = void 0, t2.hashObjectToByteArray = function(e3, t3, r2) {
    let n2 = e3.h0;
    t3[0 + r2] = 255 & n2, n2 >>= 8, t3[1 + r2] = 255 & n2, n2 >>= 8, t3[2 + r2] = 255 & n2, n2 >>= 8, t3[3 + r2] = 255 & n2, n2 = e3.h1, t3[4 + r2] = 255 & n2, n2 >>= 8, t3[5 + r2] = 255 & n2, n2 >>= 8, t3[6 + r2] = 255 & n2, n2 >>= 8, t3[7 + r2] = 255 & n2, n2 = e3.h2, t3[8 + r2] = 255 & n2, n2 >>= 8, t3[9 + r2] = 255 & n2, n2 >>= 8, t3[10 + r2] = 255 & n2, n2 >>= 8, t3[11 + r2] = 255 & n2, n2 = e3.h3, t3[12 + r2] = 255 & n2, n2 >>= 8, t3[13 + r2] = 255 & n2, n2 >>= 8, t3[14 + r2] = 255 & n2, n2 >>= 8, t3[15 + r2] = 255 & n2, n2 = e3.h4, t3[16 + r2] = 255 & n2, n2 >>= 8, t3[17 + r2] = 255 & n2, n2 >>= 8, t3[18 + r2] = 255 & n2, n2 >>= 8, t3[19 + r2] = 255 & n2, n2 = e3.h5, t3[20 + r2] = 255 & n2, n2 >>= 8, t3[21 + r2] = 255 & n2, n2 >>= 8, t3[22 + r2] = 255 & n2, n2 >>= 8, t3[23 + r2] = 255 & n2, n2 = e3.h6, t3[24 + r2] = 255 & n2, n2 >>= 8, t3[25 + r2] = 255 & n2, n2 >>= 8, t3[26 + r2] = 255 & n2, n2 >>= 8, t3[27 + r2] = 255 & n2, n2 = e3.h7, t3[28 + r2] = 255 & n2, n2 >>= 8, t3[29 + r2] = 255 & n2, n2 >>= 8, t3[30 + r2] = 255 & n2, n2 >>= 8, t3[31 + r2] = 255 & n2;
  }, t2.byteArrayToHashObject = function(e3) {
    let t3 = 0;
    t3 |= 255 & e3[3], t3 <<= 8, t3 |= 255 & e3[2], t3 <<= 8, t3 |= 255 & e3[1], t3 <<= 8, t3 |= 255 & e3[0];
    const r2 = t3;
    t3 = 0, t3 |= 255 & e3[7], t3 <<= 8, t3 |= 255 & e3[6], t3 <<= 8, t3 |= 255 & e3[5], t3 <<= 8, t3 |= 255 & e3[4];
    const n2 = t3;
    t3 = 0, t3 |= 255 & e3[11], t3 <<= 8, t3 |= 255 & e3[10], t3 <<= 8, t3 |= 255 & e3[9], t3 <<= 8, t3 |= 255 & e3[8];
    const i2 = t3;
    t3 = 0, t3 |= 255 & e3[15], t3 <<= 8, t3 |= 255 & e3[14], t3 <<= 8, t3 |= 255 & e3[13], t3 <<= 8, t3 |= 255 & e3[12];
    const o2 = t3;
    t3 = 0, t3 |= 255 & e3[19], t3 <<= 8, t3 |= 255 & e3[18], t3 <<= 8, t3 |= 255 & e3[17], t3 <<= 8, t3 |= 255 & e3[16];
    const s2 = t3;
    t3 = 0, t3 |= 255 & e3[23], t3 <<= 8, t3 |= 255 & e3[22], t3 <<= 8, t3 |= 255 & e3[21], t3 <<= 8, t3 |= 255 & e3[20];
    const a2 = t3;
    t3 = 0, t3 |= 255 & e3[27], t3 <<= 8, t3 |= 255 & e3[26], t3 <<= 8, t3 |= 255 & e3[25], t3 <<= 8, t3 |= 255 & e3[24];
    const u2 = t3;
    return t3 = 0, t3 |= 255 & e3[31], t3 <<= 8, t3 |= 255 & e3[30], t3 <<= 8, t3 |= 255 & e3[29], t3 <<= 8, t3 |= 255 & e3[28], { h0: r2, h1: n2, h2: i2, h3: o2, h4: s2, h5: a2, h6: u2, h7: t3 };
  };
});
var io = Object.defineProperty({ default: class {
  constructor() {
    this.ctx = ro.newInstance(), this.wasmInputValue = this.ctx.input.value, this.wasmOutputValue = this.ctx.output.value, this.uint8InputArray = new Uint8Array(this.ctx.memory.buffer, this.wasmInputValue, this.ctx.INPUT_LENGTH), this.uint8OutputArray = new Uint8Array(this.ctx.memory.buffer, this.wasmOutputValue, 32);
  }
  init() {
    return this.ctx.init(), this;
  }
  update(e2) {
    const t2 = this.ctx.INPUT_LENGTH;
    if (e2.length > t2)
      for (let r2 = 0; r2 < e2.length; r2 += t2) {
        const n2 = e2.slice(r2, r2 + t2);
        this.uint8InputArray.set(n2), this.ctx.update(this.wasmInputValue, n2.length);
      }
    else
      this.uint8InputArray.set(e2), this.ctx.update(this.wasmInputValue, e2.length);
    return this;
  }
  final() {
    this.ctx.final(this.wasmOutputValue);
    const e2 = new Uint8Array(32);
    return e2.set(this.uint8OutputArray), e2;
  }
} }, "__esModule", { value: true });
var oo = ye(function(e2, t2) {
  var r2 = pe && pe.__importDefault || function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.digest64HashObjects = t2.digest2Bytes32 = t2.digest64 = t2.digest = t2.SHA256 = t2.hashObjectToByteArray = t2.byteArrayToHashObject = void 0, Object.defineProperty(t2, "byteArrayToHashObject", { enumerable: true, get: function() {
    return no.byteArrayToHashObject;
  } }), Object.defineProperty(t2, "hashObjectToByteArray", { enumerable: true, get: function() {
    return no.hashObjectToByteArray;
  } });
  const n2 = r2(io);
  t2.SHA256 = n2.default;
  const i2 = ro.newInstance(), o2 = i2.input.value, s2 = i2.output.value, a2 = new Uint8Array(i2.memory.buffer, o2, i2.INPUT_LENGTH), u2 = new Uint8Array(i2.memory.buffer, s2, 32), h2 = new Uint32Array(i2.memory.buffer, o2, i2.INPUT_LENGTH);
  function f2(e3) {
    if (64 === e3.length) {
      a2.set(e3), i2.digest64(o2, s2);
      const t3 = new Uint8Array(32);
      return t3.set(u2), t3;
    }
    throw new Error("InvalidLengthForDigest64");
  }
  t2.digest = function(e3) {
    if (64 === e3.length)
      return f2(e3);
    if (e3.length <= i2.INPUT_LENGTH) {
      a2.set(e3), i2.digest(e3.length);
      const t3 = new Uint8Array(32);
      return t3.set(u2), t3;
    }
    return i2.init(), function(e4) {
      const t3 = i2.INPUT_LENGTH;
      if (e4.length > t3)
        for (let r3 = 0; r3 < e4.length; r3 += t3) {
          const n3 = e4.slice(r3, r3 + t3);
          a2.set(n3), i2.update(o2, n3.length);
        }
      else
        a2.set(e4), i2.update(o2, e4.length);
    }(e3), function() {
      i2.final(s2);
      const e4 = new Uint8Array(32);
      return e4.set(u2), e4;
    }();
  }, t2.digest64 = f2, t2.digest2Bytes32 = function(e3, t3) {
    if (32 === e3.length && 32 === t3.length) {
      a2.set(e3), a2.set(t3, 32), i2.digest64(o2, s2);
      const r3 = new Uint8Array(32);
      return r3.set(u2), r3;
    }
    throw new Error("InvalidLengthForDigest64");
  }, t2.digest64HashObjects = function(e3, t3) {
    return h2[0] = e3.h0, h2[1] = e3.h1, h2[2] = e3.h2, h2[3] = e3.h3, h2[4] = e3.h4, h2[5] = e3.h5, h2[6] = e3.h6, h2[7] = e3.h7, h2[8] = t3.h0, h2[9] = t3.h1, h2[10] = t3.h2, h2[11] = t3.h3, h2[12] = t3.h4, h2[13] = t3.h5, h2[14] = t3.h6, h2[15] = t3.h7, i2.digest64(o2, s2), no.byteArrayToHashObject(u2);
  };
});
var so = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isHashObject = t2.uint8ArrayToHashObject = t2.hashObjectToUint8Array = t2.hashTwoObjects = t2.hash = void 0;
  const r2 = new Uint8Array(64);
  t2.hash = function(e3, t3) {
    return r2.set(e3, 0), r2.set(t3, 32), oo.digest64(r2);
  }, t2.hashTwoObjects = function(e3, t3) {
    return oo.digest64HashObjects(e3, t3);
  }, t2.hashObjectToUint8Array = function(e3) {
    const t3 = new Uint8Array(32);
    return oo.hashObjectToByteArray(e3, t3, 0), t3;
  }, t2.uint8ArrayToHashObject = function(e3) {
    return oo.byteArrayToHashObject(e3);
  }, t2.isHashObject = function(e3) {
    return void 0 === e3.length;
  };
});
var ao = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.bitwiseOrNodeH = t2.setNodeH = t2.getNodeH = t2.compose = t2.identity = t2.LeafNode = t2.BranchNode = t2.Node = void 0;
  const r2 = 2 ** 32;
  class n2 {
    constructor(e3, t3, r3, n3, i3, o3, s3, a3) {
      this.h0 = e3, this.h1 = t3, this.h2 = r3, this.h3 = n3, this.h4 = i3, this.h5 = o3, this.h6 = s3, this.h7 = a3;
    }
    applyHash(e3) {
      this.h0 = e3.h0, this.h1 = e3.h1, this.h2 = e3.h2, this.h3 = e3.h3, this.h4 = e3.h4, this.h5 = e3.h5, this.h6 = e3.h6, this.h7 = e3.h7;
    }
  }
  t2.Node = n2, t2.BranchNode = class extends n2 {
    constructor(e3, t3) {
      if (super(null, 0, 0, 0, 0, 0, 0, 0), this._left = e3, this._right = t3, !e3)
        throw new Error("Left node is undefined");
      if (!t3)
        throw new Error("Right node is undefined");
    }
    get rootHashObject() {
      return null === this.h0 && super.applyHash(so.hashTwoObjects(this.left.rootHashObject, this.right.rootHashObject)), this;
    }
    get root() {
      return so.hashObjectToUint8Array(this.rootHashObject);
    }
    isLeaf() {
      return false;
    }
    get left() {
      return this._left;
    }
    get right() {
      return this._right;
    }
  };
  class i2 extends n2 {
    static fromRoot(e3) {
      return this.fromHashObject(so.uint8ArrayToHashObject(e3));
    }
    static fromHashObject(e3) {
      return new i2(e3.h0, e3.h1, e3.h2, e3.h3, e3.h4, e3.h5, e3.h6, e3.h7);
    }
    static fromZero() {
      return new i2(0, 0, 0, 0, 0, 0, 0, 0);
    }
    static fromUint32(e3) {
      return new i2(e3, 0, 0, 0, 0, 0, 0, 0);
    }
    clone() {
      return i2.fromHashObject(this);
    }
    get rootHashObject() {
      return this;
    }
    get root() {
      return so.hashObjectToUint8Array(this);
    }
    isLeaf() {
      return true;
    }
    get left() {
      throw Error("LeafNode has no left node");
    }
    get right() {
      throw Error("LeafNode has no right node");
    }
    writeToBytes(e3, t3, r3) {
      e3.set(this.root.slice(0, r3), t3);
    }
    getUint(e3, t3, n3) {
      const i3 = Math.floor(t3 / 4);
      if (e3 < 4) {
        const r3 = t3 % 4 * 8, n4 = o2(this, i3);
        return 1 === e3 ? 255 & n4 >> r3 : 65535 & n4 >> r3;
      }
      if (4 === e3)
        return o2(this, i3) >>> 0;
      if (8 === e3) {
        const e4 = o2(this, i3), t4 = o2(this, i3 + 1);
        return 0 === t4 ? e4 >>> 0 : -1 === t4 && -1 === e4 && n3 ? Infinity : (e4 >>> 0) + (t4 >>> 0) * r2;
      }
      throw Error("uintBytes > 8");
    }
    getUintBigint(e3, t3) {
      const r3 = Math.floor(t3 / 4);
      if (e3 < 4) {
        const n3 = t3 % 4 * 8, i3 = o2(this, r3);
        return 1 === e3 ? BigInt(255 & i3 >> n3) : BigInt(65535 & i3 >> n3);
      }
      if (4 === e3)
        return BigInt(o2(this, r3) >>> 0);
      {
        const t4 = Math.ceil(e3 / 4);
        let n3 = BigInt(0);
        for (let e4 = 0; e4 < t4; e4++)
          n3 += BigInt(o2(this, r3 + e4) >>> 0) << BigInt(32 * e4);
        return n3;
      }
    }
    setUint(e3, t3, n3, i3) {
      const a3 = Math.floor(t3 / 4);
      if (e3 < 4) {
        const r3 = t3 % 4 * 8;
        let i4 = o2(this, a3);
        1 === e3 ? (i4 &= ~(255 << r3), i4 |= n3 << r3) : (i4 &= ~(65535 << r3), i4 |= n3 << r3), s2(this, a3, i4);
      } else if (4 === e3)
        s2(this, a3, n3);
      else {
        if (8 !== e3)
          throw Error("uintBytes > 8");
        Infinity === n3 && i3 ? (s2(this, a3, -1), s2(this, a3 + 1, -1)) : (s2(this, a3, 4294967295 & n3), s2(this, a3 + 1, n3 / r2 & 4294967295));
      }
    }
    setUintBigint(e3, t3, r3) {
      const n3 = Math.floor(t3 / 4);
      if (e3 < 4) {
        const i3 = Number(r3), a3 = t3 % 4 * 8;
        let u2 = o2(this, n3);
        1 === e3 ? (u2 &= ~(255 << a3), u2 |= i3 << a3) : (u2 &= ~(65535 << a3), u2 |= i3 << a3), s2(this, n3, u2);
      } else if (4 === e3)
        s2(this, n3, Number(r3));
      else {
        const t4 = n3 + Math.ceil(e3 / 4);
        for (let e4 = n3; e4 < t4; e4++)
          s2(this, e4, Number(r3 & BigInt(4294967295))), r3 >>= BigInt(32);
      }
    }
    bitwiseOrUint(e3, t3, r3) {
      const n3 = Math.floor(t3 / 4);
      if (e3 < 4)
        a2(this, n3, r3 << t3 % 4 * 8);
      else if (4 === e3)
        a2(this, n3, r3);
      else {
        const t4 = n3 + Math.ceil(e3 / 4);
        for (let e4 = n3; e4 < t4; e4++)
          a2(this, e4, 4294967295 & r3), r3 >>= 32;
      }
    }
  }
  function o2(e3, t3) {
    if (0 === t3)
      return e3.h0;
    if (1 === t3)
      return e3.h1;
    if (2 === t3)
      return e3.h2;
    if (3 === t3)
      return e3.h3;
    if (4 === t3)
      return e3.h4;
    if (5 === t3)
      return e3.h5;
    if (6 === t3)
      return e3.h6;
    if (7 === t3)
      return e3.h7;
    throw Error("hIndex > 7");
  }
  function s2(e3, t3, r3) {
    if (0 === t3)
      e3.h0 = r3;
    else if (1 === t3)
      e3.h1 = r3;
    else if (2 === t3)
      e3.h2 = r3;
    else if (3 === t3)
      e3.h3 = r3;
    else if (4 === t3)
      e3.h4 = r3;
    else if (5 === t3)
      e3.h5 = r3;
    else if (6 === t3)
      e3.h6 = r3;
    else {
      if (7 !== t3)
        throw Error("hIndex > 7");
      e3.h7 = r3;
    }
  }
  function a2(e3, t3, r3) {
    if (0 === t3)
      e3.h0 |= r3;
    else if (1 === t3)
      e3.h1 |= r3;
    else if (2 === t3)
      e3.h2 |= r3;
    else if (3 === t3)
      e3.h3 |= r3;
    else if (4 === t3)
      e3.h4 |= r3;
    else if (5 === t3)
      e3.h5 |= r3;
    else if (6 === t3)
      e3.h6 |= r3;
    else {
      if (7 !== t3)
        throw Error("hIndex > 7");
      e3.h7 |= r3;
    }
  }
  t2.LeafNode = i2, t2.identity = function(e3) {
    return e3;
  }, t2.compose = function(e3, t3) {
    return function(r3) {
      return t3(e3(r3));
    };
  }, t2.getNodeH = o2, t2.setNodeH = s2, t2.bitwiseOrNodeH = a2;
});
var uo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.zeroNode = void 0;
  const r2 = [ao.LeafNode.fromZero()];
  t2.zeroNode = function(e3) {
    if (e3 >= r2.length)
      for (let t3 = r2.length; t3 <= e3; t3++)
        r2[t3] = new ao.BranchNode(r2[t3 - 1], r2[t3 - 1]);
    return r2[e3];
  };
});
var ho = ye(function(e2, t2) {
  function r2(e3, t3) {
    let r3 = e3;
    for (; t3 > 0; )
      r3 = new ao.BranchNode(r3, r3), t3--;
    return r3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.subtreeFillToContents = t2.subtreeFillToLength = t2.subtreeFillToDepth = void 0, t2.subtreeFillToDepth = r2, t2.subtreeFillToLength = function e3(t3, n2, i2) {
    const o2 = 1 << n2;
    if (i2 > o2)
      throw new Error("ERR_TOO_MANY_NODES");
    if (i2 === o2)
      return r2(t3, n2);
    if (0 === n2) {
      if (1 === i2)
        return t3;
      throw new Error("ERR_NAVIGATION");
    }
    if (1 === n2)
      return new ao.BranchNode(t3, i2 > 1 ? t3 : uo.zeroNode(0));
    const s2 = o2 >> 1;
    return i2 <= s2 ? new ao.BranchNode(e3(t3, n2 - 1, i2), uo.zeroNode(n2 - 1)) : new ao.BranchNode(r2(t3, n2 - 1), e3(t3, n2 - 1, i2 - s2));
  }, t2.subtreeFillToContents = function(e3, t3) {
    if (e3.length > 2 ** t3)
      throw new Error(`nodes.length ${e3.length} over maxIndex at depth ${t3}`);
    if (0 === e3.length)
      return uo.zeroNode(t3);
    if (0 === t3)
      return e3[0];
    if (1 === t3)
      return new ao.BranchNode(e3[0], e3.length > 1 ? e3[1] : uo.zeroNode(0));
    let r3 = e3.length;
    for (let n2 = t3; n2 > 0; n2--) {
      const i2 = r3 % 2, o2 = r3 - i2;
      for (let t4 = 0; t4 < o2; t4 += 2)
        e3[t4 / 2] = new ao.BranchNode(e3[t4], e3[t4 + 1]);
      i2 > 0 && (e3[o2 / 2] = new ao.BranchNode(e3[o2], uo.zeroNode(t3 - n2))), r3 = o2 / 2 + i2;
    }
    return e3[0];
  };
});
var fo = ye(function(e2, t2) {
  function r2(e3, t3, r3) {
    const n2 = r3 - t3, i2 = Math.floor(n2 / 32), o2 = new Array(Math.ceil(n2 / 32));
    for (let r4 = 0; r4 < i2; r4++) {
      const n3 = t3 + 32 * r4;
      o2[r4] = new ao.LeafNode(e3.getInt32(n3 + 0, true), e3.getInt32(n3 + 4, true), e3.getInt32(n3 + 8, true), e3.getInt32(n3 + 12, true), e3.getInt32(n3 + 16, true), e3.getInt32(n3 + 20, true), e3.getInt32(n3 + 24, true), e3.getInt32(n3 + 28, true));
    }
    const s2 = n2 % 32;
    if (s2 > 0) {
      const r4 = new ao.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
      o2[i2] = r4;
      const a2 = Math.floor(s2 / 4);
      for (let n3 = 0; n3 < a2; n3++)
        ao.setNodeH(r4, n3, e3.getInt32(t3 + 32 * i2 + 4 * n3, true));
      const u2 = n2 % 4;
      if (u2 > 0) {
        let i3 = 0;
        for (let r5 = 0; r5 < u2; r5++)
          i3 |= e3.getUint8(t3 + n2 - u2 + r5) << 8 * r5;
        ao.setNodeH(r4, a2, i3);
      }
    }
    return o2;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.packedNodeRootsToBytes = t2.packedRootsBytesToLeafNodes = t2.packedRootsBytesToNode = void 0, t2.packedRootsBytesToNode = function(e3, t3, n2, i2) {
    const o2 = r2(t3, n2, i2);
    return ho.subtreeFillToContents(o2, e3);
  }, t2.packedRootsBytesToLeafNodes = r2, t2.packedNodeRootsToBytes = function(e3, t3, r3, n2) {
    const i2 = r3 % 32, o2 = Math.floor(r3 / 32);
    for (let r4 = 0; r4 < o2; r4++) {
      const i3 = n2[r4], o3 = t3 + 32 * r4;
      e3.setInt32(o3 + 0, i3.h0, true), e3.setInt32(o3 + 4, i3.h1, true), e3.setInt32(o3 + 8, i3.h2, true), e3.setInt32(o3 + 12, i3.h3, true), e3.setInt32(o3 + 16, i3.h4, true), e3.setInt32(o3 + 20, i3.h5, true), e3.setInt32(o3 + 24, i3.h6, true), e3.setInt32(o3 + 28, i3.h7, true);
    }
    if (i2 > 0) {
      const s2 = n2[o2], a2 = Math.floor(i2 / 4);
      for (let r4 = 0; r4 < a2; r4++)
        e3.setInt32(t3 + 32 * o2 + 4 * r4, ao.getNodeH(s2, r4), true);
      const u2 = r3 % 4;
      if (u2 > 0) {
        const n3 = ao.getNodeH(s2, a2);
        for (let i3 = 0; i3 < u2; i3++)
          e3.setUint8(t3 + r3 - u2 + i3, n3 >> 8 * i3 & 255);
      }
    }
  };
});
var co = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createNodeFromSingleProof = t2.createSingleProof = t2.ERR_INVALID_NAV = void 0, t2.ERR_INVALID_NAV = "Invalid tree navigation", t2.createSingleProof = function(e3, r2) {
    const n2 = [];
    let i2 = e3;
    for (const e4 of eo.gindexIterator(r2))
      if (e4) {
        if (i2.isLeaf())
          throw new Error(t2.ERR_INVALID_NAV);
        n2.push(i2.left.root), i2 = i2.right;
      } else {
        if (i2.isLeaf())
          throw new Error(t2.ERR_INVALID_NAV);
        n2.push(i2.right.root), i2 = i2.left;
      }
    return [i2.root, n2.reverse()];
  }, t2.createNodeFromSingleProof = function(e3, t3, r2) {
    let n2 = ao.LeafNode.fromRoot(t3);
    const i2 = r2.slice().reverse();
    for (; e3 > 1; ) {
      const t4 = ao.LeafNode.fromRoot(i2.pop());
      n2 = e3 % BigInt(2) === BigInt(0) ? new ao.BranchNode(n2, t4) : new ao.BranchNode(t4, n2), e3 /= BigInt(2);
    }
    return n2;
  };
});
var lo = wo;
var po = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.treeZeroAfterIndex = t2.iterateNodesAtDepth = t2.getNodesAtDepth = t2.setNodesAtDepth = t2.setNodeAtDepth = t2.getNodeAtDepth = t2.setNodeWithFn = t2.setNode = t2.getNode = t2.Tree = void 0;
  class r2 {
    constructor(e3, t3) {
      this._rootNode = e3, t3 && (this.hook = "undefined" == typeof WeakRef ? t3 : new WeakRef(t3));
    }
    static createFromProof(e3) {
      return new r2(lo.createNodeFromProof(e3));
    }
    get rootNode() {
      return this._rootNode;
    }
    set rootNode(e3) {
      if (this._rootNode = e3, this.hook)
        if ("undefined" == typeof WeakRef)
          this.hook(e3);
        else {
          const t3 = this.hook.deref();
          t3 ? t3(e3) : this.hook = void 0;
        }
    }
    get root() {
      return this.rootNode.root;
    }
    clone() {
      return new r2(this.rootNode);
    }
    getSubtree(e3) {
      return new r2(this.getNode(e3), (t3) => this.setNode(e3, t3));
    }
    getNode(e3) {
      return n2(this.rootNode, e3);
    }
    getNodeAtDepth(e3, t3) {
      return u2(this.rootNode, e3, t3);
    }
    getRoot(e3) {
      return this.getNode(e3).root;
    }
    setNode(e3, t3) {
      this.rootNode = i2(this.rootNode, e3, t3);
    }
    setNodeWithFn(e3, t3) {
      this.rootNode = o2(this.rootNode, e3, t3);
    }
    setNodeAtDepth(e3, t3, r3) {
      this.rootNode = h2(this.rootNode, e3, t3, r3);
    }
    setRoot(e3, t3) {
      this.setNode(e3, ao.LeafNode.fromRoot(t3));
    }
    getNodesAtDepth(e3, t3, r3) {
      return c2(this.rootNode, e3, t3, r3);
    }
    iterateNodesAtDepth(e3, t3, r3) {
      return l2(this.rootNode, e3, t3, r3);
    }
    getSingleProof(e3) {
      return co.createSingleProof(this.rootNode, e3)[1];
    }
    getProof(e3) {
      return lo.createProof(this.rootNode, e3);
    }
  }
  function n2(e3, t3) {
    const r3 = eo.convertGindexToBitstring(t3);
    let n3 = e3;
    for (let e4 = 1; e4 < r3.length; e4++) {
      if (n3.isLeaf())
        throw new Error(`Invalid tree - found leaf at depth ${e4}`);
      n3 = "1" === r3[e4] ? n3.right : n3.left;
    }
    return n3;
  }
  function i2(e3, t3, r3) {
    const n3 = eo.convertGindexToBitstring(t3);
    return a2(n3, s2(e3, n3), r3);
  }
  function o2(e3, t3, r3) {
    const n3 = eo.convertGindexToBitstring(t3), i3 = s2(e3, n3), o3 = i3[i3.length - 1];
    return a2(n3, i3, r3("1" === n3[n3.length - 1] ? o3.right : o3.left));
  }
  function s2(e3, t3) {
    let r3 = e3;
    const n3 = [e3];
    for (let e4 = 1; e4 < t3.length - 1; e4++)
      r3 = "1" === t3[e4] ? r3.right : r3.left, n3.push(r3);
    return n3;
  }
  function a2(e3, t3, r3) {
    let n3 = r3;
    for (let r4 = e3.length - 1; r4 >= 1; r4--)
      n3 = "1" === e3[r4] ? new ao.BranchNode(t3[r4 - 1].left, n3) : new ao.BranchNode(n3, t3[r4 - 1].right);
    return n3;
  }
  function u2(e3, t3, r3) {
    if (0 === t3)
      return e3;
    if (1 === t3)
      return 0 === r3 ? e3.left : e3.right;
    let n3 = e3;
    for (let e4 = t3 - 1; e4 >= 0; e4--)
      n3 = d2(e4, r3) ? n3.left : n3.right;
    return n3;
  }
  function h2(e3, t3, r3, n3) {
    return f2(e3, t3, [r3], [n3]);
  }
  function f2(e3, t3, r3, n3) {
    if (0 === t3)
      return n3.length > 0 ? n3[0] : e3;
    const i3 = new Array(t3), o3 = new Array(t3), s3 = t3 - 1;
    let a3 = s3, u3 = e3;
    i3[s3] = e3;
    for (let e4 = 0; e4 < r3.length; e4++) {
      const t4 = r3[e4];
      for (let e5 = a3; e5 > 0; e5--)
        u3 = d2(e5, t4) ? u3.left : u3.right, i3[e5 - 1] = u3;
      a3 = 0, 1 != (1 & t4) ? t4 + 1 === r3[e4 + 1] ? (u3 = new ao.BranchNode(n3[e4], n3[e4 + 1]), e4++) : u3 = new ao.BranchNode(n3[e4], u3.right) : u3 = new ao.BranchNode(u3.left, n3[e4]);
      const h3 = e4 >= r3.length - 1, f3 = h3 ? s3 : Math.ceil(Math.log2(-~(t4 ^ r3[e4 + 1]))) - 1;
      for (let e5 = 1; e5 <= f3; e5++)
        if (d2(e5, t4))
          h3 || e5 !== f3 ? u3 = new ao.BranchNode(u3, i3[e5].right) : (o3[e5] = u3, u3 = i3[e5]);
        else {
          const t5 = o3[e5];
          void 0 !== t5 ? (u3 = new ao.BranchNode(t5, u3), o3[e5] = void 0) : u3 = new ao.BranchNode(i3[e5].left, u3);
        }
      a3 = f3;
    }
    return u3;
  }
  function c2(e3, t3, r3, n3) {
    if (0 === t3)
      return 0 === r3 && n3 > 0 ? [e3] : [];
    if (1 === t3)
      return 0 === n3 ? [] : 1 === n3 ? 0 === r3 ? [e3.left] : [e3.right] : [e3.left, e3.right];
    const i3 = t3 - 1;
    let o3 = i3, s3 = e3;
    const a3 = new Array(t3), u3 = new Array(t3), h3 = new Array(n3);
    a3[i3] = e3;
    for (let e4 = 0; e4 < n3; e4++) {
      for (let t4 = o3; t4 >= 0; t4--) {
        t4 !== o3 && (a3[t4] = s3);
        const n4 = d2(t4, r3 + e4);
        u3[t4] = n4, s3 = n4 ? s3.left : s3.right;
      }
      h3[e4] = s3;
      for (let e5 = 0; e5 <= i3; e5++)
        if (true === u3[e5]) {
          o3 = e5;
          break;
        }
      s3 = a3[o3];
    }
    return h3;
  }
  function* l2(e3, t3, r3, n3) {
    const i3 = r3 + n3, o3 = t3 - 1;
    let s3 = o3, a3 = e3;
    const u3 = new Array(t3), h3 = new Array(t3);
    u3[o3] = e3;
    for (let e4 = r3; e4 < i3; e4++) {
      for (let t4 = s3; t4 >= 0; t4--) {
        t4 !== s3 && (u3[t4] = a3);
        const r4 = d2(t4, e4);
        h3[t4] = r4, a3 = r4 ? a3.left : a3.right;
      }
      yield a3;
      for (let e5 = 0; e5 <= o3; e5++)
        if (true === h3[e5]) {
          s3 = e5;
          break;
        }
      a3 = u3[s3];
    }
  }
  function d2(e3, t3) {
    if (e3 > 31) {
      const r4 = 1 << e3 - 32;
      return (t3 / 2 ** 32 >>> 0 & r4) !== r4;
    }
    const r3 = 1 << e3;
    return (t3 & r3) !== r3;
  }
  t2.Tree = r2, t2.getNode = n2, t2.setNode = i2, t2.setNodeWithFn = o2, t2.getNodeAtDepth = u2, t2.setNodeAtDepth = h2, t2.setNodesAtDepth = f2, t2.getNodesAtDepth = c2, t2.iterateNodesAtDepth = l2, t2.treeZeroAfterIndex = function(e3, t3, r3) {
    if (r3 < 0)
      return uo.zeroNode(t3);
    const n3 = new Array(t3), i3 = t3 - 1;
    let o3 = i3, s3 = e3;
    n3[i3] = e3;
    for (let e4 = o3; e4 >= 0; e4--)
      s3 = d2(e4, r3) ? s3.left : s3.right, n3[e4 - 1] = s3;
    o3 = 0;
    for (let e4 = 0; e4 <= i3; e4++)
      s3 = d2(e4, r3) ? new ao.BranchNode(s3, uo.zeroNode(e4)) : new ao.BranchNode(n3[e4].left, s3);
    return s3;
  };
});
var yo = ye(function(e2, t2) {
  function r2(e3) {
    const t3 = /* @__PURE__ */ new Set(), r3 = /* @__PURE__ */ new Set();
    let n3 = e3;
    for (; n3.length > 1; ) {
      t3.add(n3);
      const e4 = n3[n3.length - 1], i3 = n3.substring(0, n3.length - 1);
      r3.add(i3 + (1 ^ Number(e4))), n3 = i3;
    }
    return { path: t3, branch: r3 };
  }
  function n2(e3, t3) {
    return e3.length ? e3.map((e4) => e4.padEnd(t3)).sort().map((e4) => e4.trim()) : [];
  }
  function i2(e3) {
    return e3.length ? e3.sort((e4, t3) => {
      if (e4.length < t3.length)
        return 1;
      if (t3.length < e4.length)
        return -1;
      let r3 = e4.indexOf("0"), n3 = t3.indexOf("0");
      for (; ; ) {
        if (-1 === r3)
          return -1;
        if (-1 === n3)
          return 1;
        if (r3 < n3)
          return 1;
        if (n3 < r3)
          return -1;
        r3 = e4.indexOf("0", r3 + 1), n3 = t3.indexOf("0", n3 + 1);
      }
    }) : [];
  }
  function o2(e3) {
    const t3 = e3.slice().sort((e4, t4) => e4.length - t4.length), r3 = [];
    e:
      for (let e4 = 0; e4 < t3.length; e4++) {
        const n3 = t3[e4];
        for (let r4 = e4 + 1; r4 < t3.length; r4++)
          if (t3[r4].startsWith(n3))
            continue e;
        r3.push(n3);
      }
    return r3;
  }
  var s2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.computeMultiProofBitstrings = t2.SortOrder = t2.filterParentBitstrings = t2.sortDecreasingBitstrings = t2.sortInOrderBitstrings = t2.computeProofBitstrings = t2.computeProofGindices = void 0, t2.computeProofGindices = function(e3) {
    const t3 = /* @__PURE__ */ new Set(), r3 = /* @__PURE__ */ new Set();
    let n3 = e3;
    for (; n3 > 1; )
      t3.add(n3), r3.add(eo.gindexSibling(n3)), n3 = eo.gindexParent(n3);
    return { path: t3, branch: r3 };
  }, t2.computeProofBitstrings = r2, t2.sortInOrderBitstrings = n2, t2.sortDecreasingBitstrings = i2, t2.filterParentBitstrings = o2, function(e3) {
    e3[e3.InOrder = 0] = "InOrder", e3[e3.Decreasing = 1] = "Decreasing", e3[e3.Unsorted = 2] = "Unsorted";
  }(s2 = t2.SortOrder || (t2.SortOrder = {})), t2.computeMultiProofBitstrings = function(e3, t3 = true, a2 = s2.InOrder) {
    const u2 = o2(e3), h2 = new Set(t3 ? u2 : []), f2 = /* @__PURE__ */ new Set(), c2 = /* @__PURE__ */ new Set();
    let l2 = 1;
    for (const e4 of u2) {
      e4.length > l2 && (l2 = e4.length);
      const { path: t4, branch: n3 } = r2(e4);
      t4.forEach((e5) => f2.add(e5)), n3.forEach((e5) => c2.add(e5));
    }
    switch (f2.forEach((e4) => c2.delete(e4)), c2.forEach((e4) => h2.add(e4)), a2) {
      case s2.InOrder:
        return n2(Array.from(h2), l2);
      case s2.Decreasing:
        return i2(Array.from(h2));
      case s2.Unsorted:
        return Array.from(h2);
    }
  };
});
var go = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createNodeFromMultiProof = t2.createMultiProof = void 0, t2.createMultiProof = function(e3, t3) {
    const r2 = new po.Tree(e3), n2 = yo.computeMultiProofBitstrings(t3.map((e4) => e4.toString(2)), false, yo.SortOrder.Decreasing), i2 = t3.slice().sort((e4, t4) => e4 < t4 ? 1 : -1), o2 = i2.map((e4) => r2.getRoot(e4)), s2 = n2.map((e4) => r2.getRoot(e4));
    return [o2, s2, i2];
  }, t2.createNodeFromMultiProof = function(e3, t3, r2) {
    var _a3, _b, _c, _d;
    if (e3.length !== r2.length)
      throw new Error("Leaves length should equal gindices length");
    const n2 = r2.map((e4) => e4.toString(2)), i2 = yo.computeMultiProofBitstrings(n2, false, yo.SortOrder.Decreasing);
    if (i2.length !== t3.length)
      throw new Error("Witnesses length should equal witnesses gindices length");
    const o2 = Math.max((_b = (_a3 = n2[0]) == null ? void 0 : _a3.length) != null ? _b : 0, (_d = (_c = i2[0]) == null ? void 0 : _c.length) != null ? _d : 0), s2 = Object.fromEntries(Array.from({ length: o2 }, (e4, t4) => [t4 + 1, {}]));
    for (let t4 = 0; t4 < n2.length; t4++) {
      const r3 = n2[t4];
      s2[r3.length][r3] = ao.LeafNode.fromRoot(e3[t4]);
    }
    for (let e4 = 0; e4 < i2.length; e4++) {
      const r3 = i2[e4];
      s2[r3.length][r3] = ao.LeafNode.fromRoot(t3[e4]);
    }
    for (let e4 = o2; e4 > 1; e4--) {
      const t4 = s2[e4], r3 = s2[e4 - 1];
      for (const e5 of Object.keys(t4)) {
        const n3 = t4[e5];
        if (!n3)
          continue;
        const i3 = "0" === e5[e5.length - 1], o3 = e5.substring(0, e5.length - 1), s3 = o3 + (i3 ? "1" : "0"), a3 = t4[s3];
        if (!a3)
          throw new Error(`Sibling not found: ${s3}`);
        const u2 = i3 ? new ao.BranchNode(n3, a3) : new ao.BranchNode(a3, n3);
        r3[o3] = u2, delete t4[e5], delete t4[s3];
      }
    }
    const a2 = s2[1][1];
    if (!a2)
      throw new Error("Internal consistency error: no root found");
    return a2;
  };
});
var mo = ye(function(e2, t2) {
  function r2(e3, t3, n3) {
    if (n3.length && n3[0].startsWith(t3)) {
      if (t3 === n3[0])
        return n3.shift(), [[], [e3.root]];
      {
        const [i2, o2] = r2(e3.left, t3 + "0", n3), [s2, a2] = r2(e3.right, t3 + "1", n3);
        return [[o2.length].concat(i2, s2), o2.concat(a2)];
      }
    }
    return [[], []];
  }
  function n2(e3, t3) {
    if (t3.length) {
      if (1 === t3.length)
        return ao.LeafNode.fromRoot(t3[0]);
      {
        const r3 = e3[0];
        return new ao.BranchNode(n2(e3.slice(1, r3), t3.slice(0, r3)), n2(e3.slice(r3), t3.slice(r3)));
      }
    }
    throw new Error("Proof must contain gt 0 leaves");
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.deserializeTreeOffsetProof = t2.serializeTreeOffsetProof = t2.computeTreeOffsetProofSerializedLength = t2.createNodeFromTreeOffsetProof = t2.createTreeOffsetProof = t2.treeOffsetProofToNode = t2.nodeToTreeOffsetProof = void 0, t2.nodeToTreeOffsetProof = r2, t2.treeOffsetProofToNode = n2, t2.createTreeOffsetProof = function(e3, t3) {
    return r2(e3, "1", yo.computeMultiProofBitstrings(t3.map((e4) => e4.toString(2))));
  }, t2.createNodeFromTreeOffsetProof = function(e3, t3) {
    return n2(e3, t3);
  }, t2.computeTreeOffsetProofSerializedLength = function(e3, t3) {
    return 2 * (e3.length + 1) + 32 * t3.length;
  }, t2.serializeTreeOffsetProof = function(e3, t3, r3, n3) {
    const i2 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength);
    i2.setUint16(t3, n3.length, true);
    const o2 = t3 + 2;
    for (let e4 = 0; e4 < r3.length; e4++)
      i2.setUint16(2 * e4 + o2, r3[e4], true);
    const s2 = o2 + 2 * r3.length;
    for (let t4 = 0; t4 < n3.length; t4++)
      e3.set(n3[t4], 32 * t4 + s2);
  }, t2.deserializeTreeOffsetProof = function(e3, t3) {
    const r3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength), n3 = r3.getUint16(t3, true);
    if (e3.length < 2 * (n3 - 1) + 32 * n3)
      throw new Error("Unable to deserialize tree offset proof: not enough bytes");
    const i2 = t3 + 2, o2 = Array.from({ length: n3 - 1 }, (e4, t4) => r3.getUint16(2 * t4 + i2, true)), s2 = i2 + 2 * o2.length, a2 = Array.from({ length: n3 }, (t4, r4) => e3.subarray(32 * r4 + s2, 32 * (r4 + 1) + s2));
    return [o2, a2];
  };
});
var wo = ye(function(e2, t2) {
  var r2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.deserializeProof = t2.serializeProof = t2.createNodeFromProof = t2.createProof = t2.ProofTypeSerialized = t2.ProofType = void 0, function(e3) {
    e3.single = "single", e3.treeOffset = "treeOffset", e3.multi = "multi";
  }(r2 = t2.ProofType || (t2.ProofType = {})), t2.ProofTypeSerialized = [r2.single, r2.treeOffset, r2.multi], t2.createProof = function(e3, t3) {
    switch (t3.type) {
      case r2.single: {
        const [n2, i2] = co.createSingleProof(e3, t3.gindex);
        return { type: r2.single, gindex: t3.gindex, leaf: n2, witnesses: i2 };
      }
      case r2.treeOffset: {
        const [n2, i2] = mo.createTreeOffsetProof(e3, t3.gindices);
        return { type: r2.treeOffset, offsets: n2, leaves: i2 };
      }
      case r2.multi: {
        const [n2, i2, o2] = go.createMultiProof(e3, t3.gindices);
        return { type: r2.multi, leaves: n2, witnesses: i2, gindices: o2 };
      }
      default:
        throw new Error("Invalid proof type");
    }
  }, t2.createNodeFromProof = function(e3) {
    switch (e3.type) {
      case r2.single:
        return co.createNodeFromSingleProof(e3.gindex, e3.leaf, e3.witnesses);
      case r2.treeOffset:
        return mo.createNodeFromTreeOffsetProof(e3.offsets, e3.leaves);
      case r2.multi:
        return go.createNodeFromMultiProof(e3.leaves, e3.witnesses, e3.gindices);
      default:
        throw new Error("Invalid proof type");
    }
  }, t2.serializeProof = function(e3) {
    switch (e3.type) {
      case r2.single:
      case r2.multi:
        throw new Error("Not implemented");
      case r2.treeOffset: {
        const n2 = new Uint8Array(1 + mo.computeTreeOffsetProofSerializedLength(e3.offsets, e3.leaves));
        return n2[0] = t2.ProofTypeSerialized.indexOf(r2.treeOffset), mo.serializeTreeOffsetProof(n2, 1, e3.offsets, e3.leaves), n2;
      }
      default:
        throw new Error("Invalid proof type");
    }
  }, t2.deserializeProof = function(e3) {
    const n2 = t2.ProofTypeSerialized[e3[0]];
    if (!n2)
      throw new Error("Invalid proof type");
    switch (n2) {
      case r2.single:
      case r2.multi:
        throw new Error("Not implemented");
      case r2.treeOffset: {
        const [t3, n3] = mo.deserializeTreeOffsetProof(e3, 1);
        return { type: r2.treeOffset, offsets: t3, leaves: n3 };
      }
      default:
        throw new Error("Invalid proof type");
    }
  };
});
var bo = ye(function(e2, t2) {
  var r2 = pe && pe.__createBinding || (Object.create ? function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), Object.defineProperty(e3, n3, { enumerable: true, get: function() {
      return t3[r3];
    } });
  } : function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), e3[n3] = t3[r3];
  }), n2 = pe && pe.__exportStar || function(e3, t3) {
    for (var n3 in e3)
      "default" === n3 || Object.prototype.hasOwnProperty.call(t3, n3) || r2(t3, e3, n3);
  };
  Object.defineProperty(t2, "__esModule", { value: true }), n2(eo, t2), n2(so, t2), n2(ao, t2), n2(fo, t2), n2(lo, t2), n2(ho, t2), n2(po, t2), n2(uo, t2);
});
var vo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.zeroHash = void 0;
  const r2 = [new Uint8Array(32)];
  t2.zeroHash = function(e3) {
    if (e3 >= r2.length)
      for (let t3 = r2.length; t3 <= e3; t3++)
        r2[t3] = oo.digest2Bytes32(r2[t3 - 1], r2[t3 - 1]);
    return r2[e3];
  };
});
var Eo = ye(function(e2, t2) {
  function r2(e3, t3) {
    return oo.digest2Bytes32(e3, t3);
  }
  function n2(e3) {
    return 0 === e3 ? 0 : Math.floor(Math.log2(e3)) + 1;
  }
  function i2(e3) {
    return e3 <= 0 ? 1 : Math.pow(2, n2(e3 - 1));
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.nextPowerOf2 = t2.maxChunksToDepth = t2.bitLength = t2.mixInLength = t2.splitIntoRootChunks = t2.merkleize = t2.hash64 = void 0, t2.hash64 = r2, t2.merkleize = function(e3, t3) {
    const o2 = n2(i2(t3) - 1);
    if (0 == e3.length)
      return vo.zeroHash(o2);
    let s2 = e3.length;
    for (let t4 = 0; t4 < o2; t4++) {
      const n3 = s2 % 2, i3 = s2 + n3;
      for (let r3 = 0; r3 < n3; r3++)
        e3[s2 + r3] = vo.zeroHash(t4);
      for (let t5 = 0; t5 < i3; t5 += 2)
        e3[t5 / 2] = r2(e3[t5], e3[t5 + 1]);
      s2 = i3 / 2;
    }
    return e3[0];
  }, t2.splitIntoRootChunks = function(e3) {
    const t3 = Math.ceil(e3.length / 32), r3 = new Array(t3);
    for (let n3 = 0; n3 < t3; n3++) {
      const t4 = new Uint8Array(32);
      t4.set(e3.slice(32 * n3, 32 * (n3 + 1))), r3[n3] = t4;
    }
    return r3;
  }, t2.mixInLength = function(e3, t3) {
    const n3 = Buffer.alloc(32);
    return n3.writeUIntLE(t3, 0, 6), r2(e3, n3);
  }, t2.bitLength = n2, t2.maxChunksToDepth = function(e3) {
    return 0 === e3 ? 0 : Math.ceil(Math.log2(e3));
  }, t2.nextPowerOf2 = i2;
});
var xo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.namedClass = void 0, t2.namedClass = function(e3, t3) {
    return new Function("superClass", `return class ${t3} extends superClass {}`)(e3);
  };
});
var Bo = ye(function(e2, t2) {
  function r2(e3, t3) {
    return new bo.BranchNode(e3, bo.LeafNode.fromUint32(t3));
  }
  function n2(e3, t3, r3) {
    if (r3 && e3 % 1 != 0)
      throw Error("size not multiple of element fixedSize");
    if (t3.isList) {
      if (e3 > t3.limit)
        throw new Error(`Invalid list length ${e3} over limit ${t3.limit}`);
    } else if (e3 !== t3.length)
      throw new Error(`Incorrect vector length ${e3} expected ${t3.length}`);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertValidArrayLength = t2.value_defaultValueArray = t2.value_equals = t2.value_cloneArray = t2.value_toJsonArray = t2.value_fromJsonArray = t2.tree_deserializeFromBytesArrayBasic = t2.tree_serializeToBytesArrayBasic = t2.value_deserializeFromBytesArrayBasic = t2.value_serializeToBytesArrayBasic = t2.setChunksNode = t2.addLengthNode = t2.getChunksNodeFromRootNode = t2.getLengthFromRootNode = void 0, t2.getLengthFromRootNode = function(e3) {
    return e3.right.getUint(4, 0);
  }, t2.getChunksNodeFromRootNode = function(e3) {
    return e3.left;
  }, t2.addLengthNode = r2, t2.setChunksNode = function(e3, t3, r3) {
    const n3 = void 0 !== r3 ? bo.LeafNode.fromUint32(r3) : e3.right;
    return new bo.BranchNode(t3, n3);
  }, t2.value_serializeToBytesArrayBasic = function(e3, t3, r3, n3, i2) {
    const o2 = e3.byteLength;
    for (let s2 = 0; s2 < t3; s2++)
      e3.value_serializeToBytes(r3, n3 + s2 * o2, i2[s2]);
    return n3 + t3 * o2;
  }, t2.value_deserializeFromBytesArrayBasic = function(e3, t3, r3, i2, o2) {
    const s2 = e3.byteLength, a2 = (i2 - r3) / s2;
    n2(a2, o2, true);
    const u2 = new Array(a2);
    for (let n3 = 0; n3 < a2; n3++)
      u2[n3] = e3.value_deserializeFromBytes(t3, r3 + n3 * s2, r3 + (n3 + 1) * s2);
    return u2;
  }, t2.tree_serializeToBytesArrayBasic = function(e3, t3, r3, n3, i2, o2) {
    const s2 = e3.byteLength * t3, a2 = Math.ceil(s2 / 32), u2 = bo.getNodesAtDepth(o2, r3, 0, a2);
    return bo.packedNodeRootsToBytes(n3.dataView, i2, s2, u2), i2 + s2;
  }, t2.tree_deserializeFromBytesArrayBasic = function(e3, t3, i2, o2, s2, a2) {
    const u2 = (s2 - o2) / e3.byteLength;
    n2(u2, a2, true);
    const h2 = bo.packedRootsBytesToNode(t3, i2.dataView, o2, s2);
    return a2.isList ? r2(h2, u2) : h2;
  }, t2.value_fromJsonArray = function(e3, t3, r3) {
    if (!Array.isArray(t3))
      throw Error("JSON is not an array");
    n2(t3.length, r3);
    const i2 = new Array(t3.length);
    for (let r4 = 0; r4 < t3.length; r4++)
      i2[r4] = e3.fromJson(t3[r4]);
    return i2;
  }, t2.value_toJsonArray = function(e3, t3, r3) {
    const n3 = r3.isList ? t3.length : r3.length, i2 = new Array(n3);
    for (let r4 = 0; r4 < n3; r4++)
      i2[r4] = e3.toJson(t3[r4]);
    return i2;
  }, t2.value_cloneArray = function(e3, t3) {
    const r3 = new Array(t3.length);
    for (let n3 = 0; n3 < t3.length; n3++)
      r3[n3] = e3.clone(t3[n3]);
    return r3;
  }, t2.value_equals = function(e3, t3, r3) {
    if (t3.length !== r3.length)
      return false;
    for (let n3 = 0; n3 < t3.length; n3++)
      if (!e3.equals(t3[n3], r3[n3]))
        return false;
    return true;
  }, t2.value_defaultValueArray = function(e3, t3) {
    const r3 = new Array(t3);
    for (let n3 = 0; n3 < t3; n3++)
      r3[n3] = e3.defaultValue();
    return r3;
  }, t2.assertValidArrayLength = n2;
});
var Ao = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getUint8ByteToBitBooleanArray = t2.BitArray = void 0;
  const r2 = new Array(256);
  class n2 {
    constructor(e3, t3) {
      if (this.uint8Array = e3, this.bitLen = t3, e3.length !== Math.ceil(t3 / 8))
        throw Error("BitArray uint8Array length does not match bitLen");
    }
    static fromBitLen(e3) {
      return new n2(new Uint8Array(Math.ceil(e3 / 8)), e3);
    }
    static fromSingleBit(e3, t3) {
      const r3 = n2.fromBitLen(e3);
      return r3.set(t3, true), r3;
    }
    static fromBoolArray(e3) {
      const t3 = n2.fromBitLen(e3.length);
      for (let r3 = 0; r3 < e3.length; r3++)
        true === e3[r3] && t3.set(r3, true);
      return t3;
    }
    clone() {
      return new n2(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);
    }
    get(e3) {
      const t3 = Math.floor(e3 / 8), r3 = 1 << e3 % 8;
      return (this.uint8Array[t3] & r3) === r3;
    }
    set(e3, t3) {
      if (e3 >= this.bitLen)
        throw Error(`BitArray set bitIndex ${e3} beyond bitLen ${this.bitLen}`);
      const r3 = Math.floor(e3 / 8), n3 = 1 << e3 % 8;
      let i3 = this.uint8Array[r3];
      t3 ? (i3 |= n3, this.uint8Array[r3] = i3) : (i3 & n3) === n3 && (i3 ^= n3, this.uint8Array[r3] = i3);
    }
    mergeOrWith(e3) {
      if (e3.bitLen !== this.bitLen)
        throw Error("Must merge BitArrays of same bitLen");
      for (let t3 = 0; t3 < this.uint8Array.length; t3++)
        this.uint8Array[t3] = this.uint8Array[t3] | e3.uint8Array[t3];
    }
    intersectValues(e3) {
      const t3 = [];
      if (e3.length !== this.bitLen)
        throw Error(`Must not intersect values of length ${e3.length} != bitLen ${this.bitLen}`);
      const r3 = Math.floor(this.bitLen / 8), n3 = this.bitLen % 8, o2 = this.uint8Array;
      for (let n4 = 0; n4 < r3; n4++) {
        const r4 = i2(o2[n4]);
        for (let i3 = 0; i3 < 8; i3++)
          r4[i3] && t3.push(e3[8 * n4 + i3]);
      }
      if (n3 > 0) {
        const s2 = i2(o2[r3]);
        for (let i3 = 0; i3 < n3; i3++)
          s2[i3] && t3.push(e3[8 * r3 + i3]);
      }
      return t3;
    }
    getTrueBitIndexes() {
      const e3 = [], t3 = this.uint8Array;
      for (let r3 = 0, n3 = t3.length; r3 < n3; r3++) {
        const n4 = i2(t3[r3]);
        for (let t4 = 0; t4 < 8; t4++)
          n4[t4] && e3.push(8 * r3 + t4);
      }
      return e3;
    }
    getSingleTrueBit() {
      let e3 = null;
      const t3 = this.uint8Array;
      for (let r3 = 0, n3 = t3.length; r3 < n3; r3++) {
        if (0 === t3[r3])
          continue;
        const n4 = i2(t3[r3]);
        for (let t4 = 0; t4 < 8; t4++)
          if (true === n4[t4]) {
            if (null !== e3)
              return null;
            e3 = 8 * r3 + t4;
          }
      }
      return null === e3 ? null : e3;
    }
    toBoolArray() {
      const e3 = new Array(this.bitLen);
      for (let t3 = 0; t3 < this.bitLen; t3++)
        e3[t3] = this.get(t3);
      return e3;
    }
  }
  function i2(e3) {
    return r2[e3] || (r2[e3] = function(e4) {
      const t3 = e4.toString(2), r3 = t3.length, n3 = new Array(8);
      for (let e5 = 0; e5 < 8; e5++)
        n3[e5] = e5 < r3 && "1" === t3[r3 - e5 - 1];
      return n3;
    }(e3)), r2[e3];
  }
  t2.BitArray = n2, t2.getUint8ByteToBitBooleanArray = i2;
});
var _o = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.byteArrayEquals = t2.fromHexString = t2.toHexString = void 0;
  const r2 = new Array(256);
  t2.toHexString = function(e3) {
    let t3 = "0x";
    for (const n2 of e3)
      r2[n2] || (r2[n2] = n2 < 16 ? "0" + n2.toString(16) : n2.toString(16)), t3 += r2[n2];
    return t3;
  }, t2.fromHexString = function(e3) {
    if ("string" != typeof e3)
      throw new Error(`hex argument type ${typeof e3} must be of type string`);
    if (e3.startsWith("0x") && (e3 = e3.slice(2)), e3.length % 2 != 0)
      throw new Error(`hex string length ${e3.length} must be multiple of 2`);
    const t3 = e3.length / 2, r3 = new Uint8Array(t3);
    for (let n2 = 0; n2 < t3; n2++) {
      const t4 = parseInt(e3.slice(2 * n2, 2 * (n2 + 1)), 16);
      r3[n2] = t4;
    }
    return r3;
  }, t2.byteArrayEquals = function(e3, t3) {
    if (e3.length !== t3.length)
      return false;
    for (let r3 = 0; r3 < e3.length; r3++)
      if (e3[r3] !== t3[r3])
        return false;
    return true;
  };
});
var To = ye(function(e2, t2) {
  function r2(e3) {
    return !e3.isBasic;
  }
  function n2(e3) {
    return "" === e3 ? 0 : parseInt(e3, 2);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.treePostProcessFromProofNode = void 0, t2.treePostProcessFromProofNode = function e3(t3, i2, o2 = "", s2 = 0) {
    if (0 === s2) {
      const e4 = i2.tree_fromProofNode(t3);
      if (e4.done)
        return e4.node;
      t3 = e4.node;
    }
    const a2 = i2.depth === s2;
    if (t3.isLeaf()) {
      if (a2) {
        const e4 = i2.getIndexProperty(n2(o2));
        if (null === e4)
          return t3;
        const s3 = i2.getPropertyType(e4);
        return 1 === s3.maxChunkCount && r2(s3) ? s3.tree_fromProofNode(t3).node : t3;
      }
      return t3;
    }
    if (a2) {
      const s3 = i2.getIndexProperty(n2(o2));
      if (null === s3)
        return t3;
      const a3 = i2.getPropertyType(s3);
      if (!r2(a3))
        throw Error("BranchNode does not map to CompositeType");
      const u2 = a3.tree_fromProofNode(t3);
      return u2.done ? u2.node : e3(u2.node, a3);
    }
    {
      const r3 = e3(t3.left, i2, o2 + "0", s2 + 1), n3 = e3(t3.right, i2, o2 + "1", s2 + 1);
      return r3 === t3.left && n3 === t3.right ? t3 : new bo.BranchNode(r3, n3);
    }
  };
});
var So = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Type = void 0, t2.Type = class {
    value_toTree(e3) {
      const t3 = new Uint8Array(this.value_serializedSize(e3)), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.value_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3), this.tree_deserializeFromBytes({ uint8Array: t3, dataView: r2 }, 0, t3.length);
    }
    tree_toValue(e3) {
      const t3 = new Uint8Array(this.tree_serializedSize(e3)), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.tree_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3), this.value_deserializeFromBytes({ uint8Array: t3, dataView: r2 }, 0, t3.length);
    }
    serialize(e3) {
      const t3 = new Uint8Array(this.value_serializedSize(e3)), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.value_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3), t3;
    }
    deserialize(e3) {
      const t3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength);
      return this.value_deserializeFromBytes({ uint8Array: e3, dataView: t3 }, 0, e3.length);
    }
  };
});
var No = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isCompositeType = t2.CompositeType = t2.LENGTH_GINDEX = void 0, t2.LENGTH_GINDEX = BigInt(3);
  const r2 = Symbol("ssz_cached_permanent_root");
  function n2(e3) {
    return !e3.isBasic;
  }
  t2.CompositeType = class extends So.Type {
    constructor(e3) {
      super(), this.cachePermanentRootStruct = e3, this.isBasic = false;
    }
    defaultView() {
      return this.toView(this.defaultValue());
    }
    defaultViewDU() {
      return this.toViewDU(this.defaultValue());
    }
    deserializeToView(e3) {
      const t3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength), r3 = this.tree_deserializeFromBytes({ uint8Array: e3, dataView: t3 }, 0, e3.length);
      return this.getView(new bo.Tree(r3));
    }
    deserializeToViewDU(e3) {
      const t3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength), r3 = this.tree_deserializeFromBytes({ uint8Array: e3, dataView: t3 }, 0, e3.length);
      return this.getViewDU(r3);
    }
    toView(e3) {
      const t3 = this.value_toTree(e3);
      return this.getView(new bo.Tree(t3));
    }
    toViewDU(e3) {
      const t3 = this.value_toTree(e3);
      return this.getViewDU(t3);
    }
    toValueFromView(e3) {
      const t3 = this.commitView(e3);
      return this.tree_toValue(t3);
    }
    toValueFromViewDU(e3) {
      const t3 = this.commitViewDU(e3);
      return this.tree_toValue(t3);
    }
    toViewFromViewDU(e3) {
      const t3 = this.commitViewDU(e3);
      return this.getView(new bo.Tree(t3));
    }
    toViewDUFromView(e3) {
      const t3 = this.commitView(e3);
      return this.getViewDU(t3);
    }
    hashTreeRoot(e3) {
      if (this.cachePermanentRootStruct) {
        const t4 = e3[r2];
        if (t4)
          return t4;
      }
      const t3 = Eo.merkleize(this.getRoots(e3), this.maxChunkCount);
      return this.cachePermanentRootStruct && (e3[r2] = t3), t3;
    }
    getCachedPermanentRoot(e3) {
      return e3[r2];
    }
    createFromProof(e3, t3) {
      const r3 = bo.Tree.createFromProof(e3).rootNode, n3 = To.treePostProcessFromProofNode(r3, this);
      if (void 0 !== t3 && !_o.byteArrayEquals(n3.root, t3))
        throw new Error("Proof does not match trusted root");
      return this.getView(new bo.Tree(n3));
    }
    tree_createProof(e3, t3) {
      const r3 = this.tree_createProofGindexes(e3, t3);
      return bo.createProof(e3, { type: bo.ProofType.treeOffset, gindices: r3 });
    }
    tree_createProofGindexes(e3, t3) {
      const r3 = [];
      for (const i2 of t3) {
        const { type: t4, gindex: o2 } = this.getPathInfo(i2);
        if (n2(t4)) {
          const n3 = t4.tree_getLeafGindices(o2, null === t4.fixedSize ? bo.getNode(e3, o2) : void 0);
          for (const e4 of n3)
            r3.push(e4);
        } else
          r3.push(o2);
      }
      return r3;
    }
    getPathInfo(e3) {
      const t3 = [];
      let r3 = this;
      for (const n3 of e3) {
        if (r3.isBasic)
          throw new Error("Invalid path: cannot navigate beyond a basic type");
        const e4 = r3.getPropertyGindex(n3);
        null !== e4 && (t3.push(e4), r3 = r3.getPropertyType(n3));
      }
      return { type: r3, gindex: bo.concatGindices(t3) };
    }
    tree_fromProofNode(e3) {
      return { node: e3, done: false };
    }
  }, t2.isCompositeType = n2;
});
var Io = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TreeView = void 0, t2.TreeView = class {
    serialize() {
      const e3 = new Uint8Array(this.type.tree_serializedSize(this.node)), t3 = new DataView(e3.buffer, e3.byteOffset, e3.byteLength);
      return this.type.tree_serializeToBytes({ uint8Array: e3, dataView: t3 }, 0, this.node), e3;
    }
    hashTreeRoot() {
      return this.node.root;
    }
    createProof(e3) {
      return this.type.tree_createProof(this.node, e3);
    }
    toValue() {
      return this.type.tree_toValue(this.node);
    }
    clone() {
      return this.type.getView(new bo.Tree(this.node));
    }
  };
});
var Oo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BitArrayTreeView = void 0, t2.BitArrayTreeView = class extends Io.TreeView {
    constructor(e3, t3) {
      super(), this.type = e3, this.tree = t3, this.bitArray = e3.tree_toValue(t3.rootNode);
    }
    get node() {
      return this.tree.rootNode;
    }
    get uint8Array() {
      return this.bitArray.uint8Array;
    }
    get bitLen() {
      return this.bitArray.bitLen;
    }
    get(e3) {
      return this.bitArray.get(e3);
    }
    set(e3, t3) {
      this.bitArray.set(e3, t3), this.tree.rootNode = this.type.value_toTree(this.bitArray);
    }
    mergeOrWith(e3) {
      this.bitArray.mergeOrWith(e3);
    }
    intersectValues(e3) {
      return this.bitArray.intersectValues(e3);
    }
    getTrueBitIndexes() {
      return this.bitArray.getTrueBitIndexes();
    }
    getSingleTrueBit() {
      return this.bitArray.getSingleTrueBit();
    }
    toBoolArray() {
      return this.bitArray.toBoolArray();
    }
  };
});
var Uo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TreeViewDU = void 0, t2.TreeViewDU = class extends Io.TreeView {
    hashTreeRoot() {
      return this.commit(), super.hashTreeRoot();
    }
    serialize() {
      return this.commit(), super.serialize();
    }
    clone(e3) {
      if (e3)
        return this.type.getViewDU(this.node);
      {
        const e4 = this.cache;
        return this.clearCache(), this.type.getViewDU(this.node, e4);
      }
    }
  };
});
var Lo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BitArrayTreeViewDU = void 0, t2.BitArrayTreeViewDU = class extends Uo.TreeViewDU {
    constructor(e3, t3) {
      super(), this.type = e3, this._rootNode = t3, this._bitArray = null;
    }
    get node() {
      return this._rootNode;
    }
    get cache() {
    }
    commit() {
      null !== this._bitArray && (this._rootNode = this.type.value_toTree(this._bitArray));
    }
    get uint8Array() {
      return this.bitArray.uint8Array;
    }
    get bitLen() {
      return this.bitArray.bitLen;
    }
    get(e3) {
      return this.bitArray.get(e3);
    }
    set(e3, t3) {
      this.bitArray.set(e3, t3);
    }
    mergeOrWith(e3) {
      this.bitArray.mergeOrWith(e3);
    }
    intersectValues(e3) {
      return this.bitArray.intersectValues(e3);
    }
    getTrueBitIndexes() {
      return this.bitArray.getTrueBitIndexes();
    }
    getSingleTrueBit() {
      return this.bitArray.getSingleTrueBit();
    }
    toBoolArray() {
      return this.bitArray.toBoolArray();
    }
    get bitArray() {
      return null === this._bitArray && (this._bitArray = this.type.tree_toValue(this._rootNode)), this._bitArray;
    }
    clearCache() {
      this._bitArray = null;
    }
  };
});
var ko = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BitArrayType = void 0, t2.BitArrayType = class extends No.CompositeType {
    constructor() {
      super(...arguments), this.isViewMutable = true;
    }
    getView(e3) {
      return new Oo.BitArrayTreeView(this, e3);
    }
    getViewDU(e3) {
      return new Lo.BitArrayTreeViewDU(this, e3);
    }
    commitView(e3) {
      return e3.node;
    }
    commitViewDU(e3) {
      return e3.commit(), e3.node;
    }
    cacheOfViewDU(e3) {
      return e3.cache;
    }
    getRoots(e3) {
      return Eo.splitIntoRootChunks(e3.uint8Array);
    }
    getPropertyGindex() {
      return null;
    }
    getPropertyType() {
      throw Error("Must only request BitArray complete data");
    }
    getIndexProperty() {
      throw Error("Must only request BitArray complete data");
    }
    tree_fromProofNode(e3) {
      return { node: e3, done: true };
    }
    tree_getLeafGindices(e3, t3) {
      const r2 = this.tree_getByteLen(t3), n2 = Math.ceil(r2 / 32), i2 = bo.concatGindices([e3, bo.toGindex(this.depth, BigInt(0))]), o2 = new Array(n2);
      for (let e4 = 0, t4 = i2; e4 < n2; e4++, t4++)
        o2[e4] = t4;
      return this.isList && o2.push(bo.concatGindices([e3, No.LENGTH_GINDEX])), o2;
    }
    fromJson(e3) {
      const t3 = _o.fromHexString(e3), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.value_deserializeFromBytes({ uint8Array: t3, dataView: r2 }, 0, t3.length);
    }
    toJson(e3) {
      return _o.toHexString(this.serialize(e3));
    }
    clone(e3) {
      return e3.clone();
    }
    equals(e3, t3) {
      return e3.bitLen === t3.bitLen && _o.byteArrayEquals(e3.uint8Array, t3.uint8Array);
    }
  };
});
var Mo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BitListType = void 0;
  class r2 extends ko.BitArrayType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.limitBits = e3, this.fixedSize = null, this.minSize = 1, this.isList = true, 0 === e3)
        throw Error("List limit must be > 0");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : `BitList[${e3}]`, this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32), this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = 1 + this.chunkDepth, this.maxSize = Math.ceil(e3 / 8) + 1;
    }
    static named(e3, t3) {
      return new (xo.namedClass(r2, t3.typeName))(e3, t3);
    }
    defaultValue() {
      return Ao.BitArray.fromBitLen(0);
    }
    value_serializedSize(e3) {
      return n2(e3.bitLen);
    }
    value_serializeToBytes(e3, t3, r3) {
      return e3.uint8Array.set(r3.uint8Array, t3), i2(e3.uint8Array, t3, r3.bitLen);
    }
    value_deserializeFromBytes(e3, t3, r3) {
      const { uint8Array: n3, bitLen: i3 } = this.deserializeUint8ArrayBitListFromBytes(e3.uint8Array, t3, r3);
      return new Ao.BitArray(n3, i3);
    }
    tree_serializedSize(e3) {
      return n2(Bo.getLengthFromRootNode(e3));
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n3 = Bo.getChunksNodeFromRootNode(r3), o2 = Bo.getLengthFromRootNode(r3), s2 = Math.ceil(o2 / 8), a2 = Math.ceil(s2 / 32), u2 = bo.getNodesAtDepth(n3, this.chunkDepth, 0, a2);
      return bo.packedNodeRootsToBytes(e3.dataView, t3, s2, u2), i2(e3.uint8Array, t3, o2);
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      const { uint8Array: n3, bitLen: i3 } = this.deserializeUint8ArrayBitListFromBytes(e3.uint8Array, t3, r3), o2 = new DataView(n3.buffer, n3.byteOffset, n3.byteLength), s2 = bo.packedRootsBytesToNode(this.chunkDepth, o2, 0, n3.length);
      return Bo.addLengthNode(s2, i3);
    }
    tree_getByteLen(e3) {
      if (!e3)
        throw new Error("BitListType requires a node to get leaves");
      return Math.ceil(Bo.getLengthFromRootNode(e3) / 8);
    }
    hashTreeRoot(e3) {
      return Eo.mixInLength(super.hashTreeRoot(e3), e3.bitLen);
    }
    deserializeUint8ArrayBitListFromBytes(e3, t3, r3) {
      const { uint8Array: n3, bitLen: i3 } = function(e4, t4, r4) {
        if (r4 > e4.length)
          throw Error(`BitList attempting to read byte ${r4} of data length ${e4.length}`);
        const n4 = e4[r4 - 1], i4 = r4 - t4;
        if (0 === n4)
          throw new Error("Invalid deserialized bitlist, padding bit required");
        if (1 === n4)
          return { uint8Array: Uint8Array.prototype.slice.call(e4, t4, r4 - 1), bitLen: 8 * (i4 - 1) };
        const o2 = Uint8Array.prototype.slice.call(e4, t4, r4), s2 = n4.toString(2).length - 1, a2 = 8 * (i4 - 1) + s2;
        return o2[i4 - 1] &= 255 >> 8 - s2, { uint8Array: o2, bitLen: a2 };
      }(e3, t3, r3);
      if (i3 > this.limitBits)
        throw Error(`bitLen over limit ${i3} > ${this.limitBits}`);
      return { uint8Array: n3, bitLen: i3 };
    }
  }
  function n2(e3) {
    const t3 = Math.ceil(e3 / 8);
    return e3 % 8 == 0 ? t3 + 1 : t3;
  }
  function i2(e3, t3, r3) {
    const n3 = t3 + Math.ceil(r3 / 8);
    return r3 % 8 == 0 ? (e3[n3] = 1, n3 + 1) : (e3[n3 - 1] |= 1 << r3 % 8, n3);
  }
  t2.BitListType = r2;
});
var Co = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BitVectorType = void 0;
  class r2 extends ko.BitArrayType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.lengthBits = e3, this.isList = false, 0 === e3)
        throw Error("Vector length must be > 0");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : `BitVector[${e3}]`, this.chunkCount = Math.ceil(this.lengthBits / 8 / 32), this.maxChunkCount = this.chunkCount, this.depth = Eo.maxChunksToDepth(this.chunkCount), this.fixedSize = Math.ceil(this.lengthBits / 8), this.minSize = this.fixedSize, this.maxSize = this.fixedSize, this.zeroBitsMask = e3 % 8 == 0 ? 0 : 255 & 255 << e3 % 8;
    }
    static named(e3, t3) {
      return new (xo.namedClass(r2, t3.typeName))(e3, t3);
    }
    defaultValue() {
      return Ao.BitArray.fromBitLen(this.lengthBits);
    }
    value_serializedSize() {
      return this.fixedSize;
    }
    value_serializeToBytes(e3, t3, r3) {
      return e3.uint8Array.set(r3.uint8Array, t3), t3 + this.fixedSize;
    }
    value_deserializeFromBytes(e3, t3, r3) {
      return this.assertValidLength(e3.uint8Array, t3, r3), new Ao.BitArray(Uint8Array.prototype.slice.call(e3.uint8Array, t3, r3), this.lengthBits);
    }
    tree_serializedSize() {
      return this.fixedSize;
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n2 = bo.getNodesAtDepth(r3, this.depth, 0, this.chunkCount);
      return bo.packedNodeRootsToBytes(e3.dataView, t3, this.fixedSize, n2), t3 + this.fixedSize;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      return this.assertValidLength(e3.uint8Array, t3, r3), bo.packedRootsBytesToNode(this.depth, e3.dataView, t3, r3);
    }
    tree_getByteLen() {
      return this.fixedSize;
    }
    assertValidLength(e3, t3, r3) {
      if (r3 - t3 !== this.fixedSize)
        throw Error(`Invalid BitVector size ${r3 - t3} != ${this.fixedSize}`);
      if (this.zeroBitsMask > 0 && (e3[r3 - 1] & this.zeroBitsMask) > 0)
        throw Error("BitVector: nonzero bits past length");
    }
  }
  t2.BitVectorType = r2;
});
var Po = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isBasicType = t2.BasicType = void 0, t2.BasicType = class extends So.Type {
    constructor() {
      super(...arguments), this.isBasic = true, this.depth = 0, this.maxChunkCount = 1;
    }
    value_serializedSize() {
      return this.byteLength;
    }
    tree_serializedSize() {
      return this.byteLength;
    }
    assertValidSize(e3) {
      if (e3 !== this.byteLength)
        throw Error(`BasicType invalid size ${e3} expected ${this.byteLength}`);
    }
    hashTreeRoot(e3) {
      const t3 = new Uint8Array(32), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.value_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3), t3;
    }
    clone(e3) {
      return e3;
    }
    equals(e3, t3) {
      return e3 === t3;
    }
  }, t2.isBasicType = function(e3) {
    return e3.isBasic;
  };
});
var Ro = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BooleanType = void 0;
  class r2 extends Po.BasicType {
    constructor(e3) {
      var _a3;
      super(), this.byteLength = 1, this.itemsPerChunk = 32, this.fixedSize = 1, this.minSize = 1, this.maxSize = 1, this.typeName = (_a3 = e3 == null ? void 0 : e3.typeName) != null ? _a3 : "boolean";
    }
    static named(e3) {
      return new (xo.namedClass(r2, e3.typeName))(e3);
    }
    defaultValue() {
      return false;
    }
    value_serializeToBytes(e3, t3, r3) {
      return e3.uint8Array[t3] = r3 ? 1 : 0, t3 + 1;
    }
    value_deserializeFromBytes(e3, t3, r3) {
      switch (this.assertValidSize(r3 - t3), e3.uint8Array[t3]) {
        case 1:
          return true;
        case 0:
          return false;
        default:
          throw new Error(`Boolean: invalid value: ${e3.uint8Array[t3]}`);
      }
    }
    tree_serializeToBytes(e3, t3, r3) {
      return e3.uint8Array[t3] = r3.getUint(4, 0), t3 + 1;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      this.assertValidSize(r3 - t3);
      const n2 = e3.uint8Array[t3];
      if (n2 > 1)
        throw Error(`Boolean: invalid value ${n2}`);
      return bo.LeafNode.fromUint32(n2);
    }
    tree_getFromNode(e3) {
      return 1 === e3.getUint(4, 0);
    }
    tree_setToNode(e3, t3) {
      e3.setUint(4, 0, t3 ? 1 : 0);
    }
    tree_getFromPackedNode(e3, t3) {
      return 0 !== e3.getUint(1, t3 % this.itemsPerChunk);
    }
    tree_setToPackedNode(e3, t3, r3) {
      e3.setUint(1, t3 % this.itemsPerChunk, r3 ? 1 : 0);
    }
    fromJson(e3) {
      if ("boolean" != typeof e3)
        throw Error(`JSON invalid type ${typeof e3} expected boolean`);
      return e3;
    }
    toJson(e3) {
      return e3;
    }
  }
  t2.BooleanType = r2;
});
var Do = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ByteArrayType = void 0, t2.ByteArrayType = class extends No.CompositeType {
    constructor() {
      super(...arguments), this.isViewMutable = false;
    }
    defaultValue() {
      return new Uint8Array(this.minSize);
    }
    getView(e3) {
      return this.getViewDU(e3.rootNode);
    }
    getViewDU(e3) {
      return this.tree_toValue(e3);
    }
    commitView(e3) {
      return this.commitViewDU(e3);
    }
    commitViewDU(e3) {
      const t3 = new Uint8Array(this.value_serializedSize(e3)), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.value_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3), this.tree_deserializeFromBytes({ uint8Array: t3, dataView: r2 }, 0, t3.length);
    }
    cacheOfViewDU() {
    }
    toView(e3) {
      return e3;
    }
    toViewDU(e3) {
      return e3;
    }
    value_serializeToBytes(e3, t3, r2) {
      return e3.uint8Array.set(r2, t3), t3 + r2.length;
    }
    value_deserializeFromBytes(e3, t3, r2) {
      return this.assertValidSize(r2 - t3), Uint8Array.prototype.slice.call(e3.uint8Array, t3, r2);
    }
    getRoots(e3) {
      return Eo.splitIntoRootChunks(e3);
    }
    getPropertyGindex() {
      return null;
    }
    getPropertyType() {
      throw Error("Must only request ByteArray complete data");
    }
    getIndexProperty() {
      throw Error("Must only request ByteArray complete data");
    }
    tree_fromProofNode(e3) {
      return { node: e3, done: true };
    }
    tree_getLeafGindices(e3, t3) {
      const r2 = this.tree_getByteLen(t3), n2 = Math.ceil(r2 / 32), i2 = bo.concatGindices([e3, bo.toGindex(this.depth, BigInt(0))]), o2 = new Array(n2);
      for (let e4 = 0, t4 = i2; e4 < n2; e4++, t4++)
        o2[e4] = t4;
      return this.isList && o2.push(bo.concatGindices([e3, No.LENGTH_GINDEX])), o2;
    }
    fromJson(e3) {
      const t3 = _o.fromHexString(e3);
      return this.assertValidSize(t3.length), t3;
    }
    toJson(e3) {
      return _o.toHexString(e3);
    }
    clone(e3) {
      return e3;
    }
    equals(e3, t3) {
      return _o.byteArrayEquals(e3, t3);
    }
  };
});
var zo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ByteListType = void 0;
  class r2 extends Do.ByteArrayType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.limitBytes = e3, this.fixedSize = null, this.isList = true, 0 === e3)
        throw Error("List limit must be > 0");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : `ByteList[${e3}]`, this.maxChunkCount = Math.ceil(this.limitBytes / 32), this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = 1 + this.chunkDepth, this.minSize = 0, this.maxSize = this.limitBytes;
    }
    static named(e3, t3) {
      return new (xo.namedClass(r2, t3.typeName))(e3, t3);
    }
    value_serializedSize(e3) {
      return e3.length;
    }
    tree_serializedSize(e3) {
      return Bo.getLengthFromRootNode(e3);
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n2 = Bo.getChunksNodeFromRootNode(r3), i2 = Bo.getLengthFromRootNode(r3), o2 = Math.ceil(i2 / 32), s2 = bo.getNodesAtDepth(n2, this.chunkDepth, 0, o2);
      return bo.packedNodeRootsToBytes(e3.dataView, t3, i2, s2), t3 + i2;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      this.assertValidSize(r3 - t3);
      const n2 = bo.packedRootsBytesToNode(this.chunkDepth, e3.dataView, t3, r3);
      return Bo.addLengthNode(n2, r3 - t3);
    }
    tree_getByteLen(e3) {
      if (!e3)
        throw new Error("ByteListType requires a node to get leaves");
      return Bo.getLengthFromRootNode(e3);
    }
    hashTreeRoot(e3) {
      return Eo.mixInLength(super.hashTreeRoot(e3), e3.length);
    }
    assertValidSize(e3) {
      if (e3 > this.limitBytes)
        throw Error(`ByteList invalid size ${e3} limit ${this.limitBytes}`);
    }
  }
  t2.ByteListType = r2;
});
var $o = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ByteVectorType = void 0;
  class r2 extends Do.ByteArrayType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.lengthBytes = e3, this.isList = false, 0 === e3)
        throw Error("Vector length must be > 0");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : `ByteVector[${e3}]`, this.maxChunkCount = Math.ceil(this.lengthBytes / 32), this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = this.chunkDepth, this.fixedSize = this.lengthBytes, this.minSize = this.fixedSize, this.maxSize = this.fixedSize;
    }
    static named(e3, t3) {
      return new (xo.namedClass(r2, t3.typeName))(e3, t3);
    }
    value_serializedSize() {
      return this.fixedSize;
    }
    tree_serializedSize() {
      return this.fixedSize;
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n2 = bo.getNodesAtDepth(r3, this.chunkDepth, 0, this.maxChunkCount);
      return bo.packedNodeRootsToBytes(e3.dataView, t3, this.fixedSize, n2), t3 + this.fixedSize;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      return this.assertValidSize(r3 - t3), bo.packedRootsBytesToNode(this.chunkDepth, e3.dataView, t3, r3);
    }
    tree_getByteLen() {
      return this.lengthBytes;
    }
    assertValidSize(e3) {
      if (e3 !== this.lengthBytes)
        throw Error(`ByteVector invalid size ${e3} expected ${this.lengthBytes}`);
    }
  }
  t2.ByteVectorType = r2;
});
var Vo = ye(function(e2) {
  (function() {
    var t2 = function(e3, t3) {
      return e3.replace(/(^|-)/g, "$1\\u" + (t3 = t3 || "")).replace(/,/g, "\\u" + t3);
    }, r2 = t2("20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7", "00"), n2 = "a-z" + t2("DF-F6,F8-FF", "00"), i2 = "A-Z" + t2("C0-D6,D8-DE", "00"), o2 = function(e3, t3, o3, s3) {
      return e3 = e3 || r2, t3 = t3 || n2, o3 = o3 || i2, s3 = s3 || "A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via", { capitalize: new RegExp("(^|[" + e3 + "])([" + t3 + "])", "g"), pascal: new RegExp("(^|[" + e3 + "])+([" + t3 + o3 + "])", "g"), fill: new RegExp("[" + e3 + "]+(.|$)", "g"), sentence: new RegExp('(^\\s*|[\\?\\!\\.]+"?\\s+"?|,\\s+")([' + t3 + "])", "g"), improper: new RegExp("\\b(" + s3 + ")\\b", "g"), relax: new RegExp("([^" + o3 + "])([" + o3 + "]*)([" + o3 + "])(?=[^" + o3 + "]|$)", "g"), upper: new RegExp("^[^" + t3 + "]+$"), hole: /[^\s]\s[^\s]/, apostrophe: /'/g, room: new RegExp("[" + e3 + "]") };
    }, s2 = o2(), a2 = { re: s2, unicodes: t2, regexps: o2, types: [], up: String.prototype.toUpperCase, low: String.prototype.toLowerCase, cap: function(e3) {
      return a2.up.call(e3.charAt(0)) + e3.slice(1);
    }, decap: function(e3) {
      return a2.low.call(e3.charAt(0)) + e3.slice(1);
    }, deapostrophe: function(e3) {
      return e3.replace(s2.apostrophe, "");
    }, fill: function(e3, t3, r3) {
      return null != t3 && (e3 = e3.replace(s2.fill, function(e4, r4) {
        return r4 ? t3 + r4 : "";
      })), r3 && (e3 = a2.deapostrophe(e3)), e3;
    }, prep: function(e3, t3, r3, n3) {
      if (e3 = null == e3 ? "" : e3 + "", !n3 && s2.upper.test(e3) && (e3 = a2.low.call(e3)), !t3 && !s2.hole.test(e3)) {
        var i3 = a2.fill(e3, " ");
        s2.hole.test(i3) && (e3 = i3);
      }
      return r3 || s2.room.test(e3) || (e3 = e3.replace(s2.relax, a2.relax)), e3;
    }, relax: function(e3, t3, r3, n3) {
      return t3 + " " + (r3 ? r3 + " " : "") + n3;
    } }, u2 = { _: a2, of: function(e3) {
      for (var t3 = 0, r3 = a2.types.length; t3 < r3; t3++)
        if (u2[a2.types[t3]].apply(u2, arguments) === e3)
          return a2.types[t3];
    }, flip: function(e3) {
      return e3.replace(/\w/g, function(e4) {
        return (e4 == a2.up.call(e4) ? a2.low : a2.up).call(e4);
      });
    }, random: function(e3) {
      return e3.replace(/\w/g, function(e4) {
        return (Math.round(Math.random()) ? a2.up : a2.low).call(e4);
      });
    }, type: function(e3, t3) {
      u2[e3] = t3, a2.types.push(e3);
    } }, h2 = { lower: function(e3, t3, r3) {
      return a2.fill(a2.low.call(a2.prep(e3, t3)), t3, r3);
    }, snake: function(e3) {
      return u2.lower(e3, "_", true);
    }, constant: function(e3) {
      return u2.upper(e3, "_", true);
    }, camel: function(e3) {
      return a2.decap(u2.pascal(e3));
    }, kebab: function(e3) {
      return u2.lower(e3, "-", true);
    }, upper: function(e3, t3, r3) {
      return a2.fill(a2.up.call(a2.prep(e3, t3, false, true)), t3, r3);
    }, capital: function(e3, t3, r3) {
      return a2.fill(a2.prep(e3).replace(s2.capitalize, function(e4, t4, r4) {
        return t4 + a2.up.call(r4);
      }), t3, r3);
    }, header: function(e3) {
      return u2.capital(e3, "-", true);
    }, pascal: function(e3) {
      return a2.fill(a2.prep(e3, false, true).replace(s2.pascal, function(e4, t3, r3) {
        return a2.up.call(r3);
      }), "", true);
    }, title: function(e3) {
      return u2.capital(e3).replace(s2.improper, function(e4, t3, r3, n3) {
        return r3 > 0 && r3 < n3.lastIndexOf(" ") ? a2.low.call(e4) : e4;
      });
    }, sentence: function(e3, t3, r3) {
      return e3 = u2.lower(e3).replace(s2.sentence, function(e4, t4, r4) {
        return t4 + a2.up.call(r4);
      }), t3 && t3.forEach(function(t4) {
        e3 = e3.replace(new RegExp("\\b" + u2.lower(t4) + "\\b", "g"), a2.cap);
      }), r3 && r3.forEach(function(t4) {
        e3 = e3.replace(new RegExp("(\\b" + u2.lower(t4) + "\\. +)(\\w)"), function(e4, t5, r4) {
          return t5 + a2.low.call(r4);
        });
      }), e3;
    } };
    for (var f2 in h2.squish = h2.pascal, u2.default = u2, h2)
      u2.type(f2, h2[f2]);
    var c2 = "function" == typeof c2 ? c2 : function() {
    };
    c2(e2.exports ? e2.exports = u2 : this.Case = u2);
  }).call(pe);
});
var jo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getContainerTreeViewClass = void 0;
  class r2 extends Io.TreeView {
    constructor(e3, t3) {
      super(), this.type = e3, this.tree = t3;
    }
    get node() {
      return this.tree.rootNode;
    }
  }
  t2.getContainerTreeViewClass = function(e3) {
    class t3 extends r2 {
    }
    for (let r3 = 0; r3 < e3.fieldsEntries.length; r3++) {
      const { fieldName: n2, fieldType: i2 } = e3.fieldsEntries[r3];
      if (Po.isBasicType(i2))
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          const e4 = bo.getNodeAtDepth(this.node, this.type.depth, r3);
          return i2.tree_getFromNode(e4);
        }, set: function(e4) {
          const t4 = bo.getNodeAtDepth(this.node, this.type.depth, r3).clone();
          i2.tree_setToNode(t4, e4), this.tree.setNodeAtDepth(this.type.depth, r3, t4);
        } });
      else {
        if (!No.isCompositeType(i2))
          throw Error(`Unknown fieldType ${i2.typeName} for fieldName ${n2}`);
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          const e4 = bo.toGindexBitstring(this.type.depth, r3);
          return i2.getView(this.tree.getSubtree(e4));
        }, set: function(e4) {
          const t4 = i2.commitView(e4);
          this.tree.setNodeAtDepth(this.type.depth, r3, t4);
        } });
      }
    }
    return Object.defineProperty(t3, "name", { value: e3.typeName, writable: false }), t3;
  };
});
var Fo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getContainerTreeViewDUClass = void 0;
  class r2 extends Uo.TreeViewDU {
    constructor(e3, t3, r3) {
      super(), this.type = e3, this._rootNode = t3, this.nodes = [], this.nodesChanged = /* @__PURE__ */ new Set(), this.viewsChanged = /* @__PURE__ */ new Map(), r3 ? (this.nodes = r3.nodes, this.caches = r3.caches, this.nodesPopulated = r3.nodesPopulated) : (this.nodes = [], this.caches = [], this.nodesPopulated = false);
    }
    get node() {
      return this._rootNode;
    }
    get cache() {
      return { nodes: this.nodes, caches: this.caches, nodesPopulated: this.nodesPopulated };
    }
    commit() {
      if (0 === this.nodesChanged.size && 0 === this.viewsChanged.size)
        return;
      const e3 = [];
      for (const [t4, r4] of this.viewsChanged) {
        const n3 = this.type.fieldsEntries[t4].fieldType, i2 = n3.commitViewDU(r4);
        this.nodes[t4] = i2, e3.push({ index: t4, node: i2 });
        const o2 = n3.cacheOfViewDU(r4);
        o2 && (this.caches[t4] = o2);
      }
      for (const t4 of this.nodesChanged)
        e3.push({ index: t4, node: this.nodes[t4] });
      const t3 = e3.sort((e4, t4) => e4.index - t4.index), r3 = t3.map((e4) => e4.index), n2 = t3.map((e4) => e4.node);
      this._rootNode = bo.setNodesAtDepth(this._rootNode, this.type.depth, r3, n2), this.nodesChanged.clear(), this.viewsChanged.clear();
    }
    clearCache() {
      this.nodes = [], this.caches = [], this.nodesPopulated = false, this.nodesChanged.clear(), this.viewsChanged.clear();
    }
  }
  t2.getContainerTreeViewDUClass = function(e3) {
    class t3 extends r2 {
    }
    for (let r3 = 0; r3 < e3.fieldsEntries.length; r3++) {
      const { fieldName: n2, fieldType: i2 } = e3.fieldsEntries[r3];
      if (Po.isBasicType(i2))
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          let e4 = this.nodes[r3];
          return void 0 === e4 && (e4 = bo.getNodeAtDepth(this._rootNode, this.type.depth, r3), this.nodes[r3] = e4), i2.tree_getFromNode(e4);
        }, set: function(e4) {
          var _a3;
          let t4;
          this.nodesChanged.has(r3) ? t4 = this.nodes[r3] : (t4 = ((_a3 = this.nodes[r3]) != null ? _a3 : bo.getNodeAtDepth(this._rootNode, this.type.depth, r3)).clone(), this.nodes[r3] = t4, this.nodesChanged.add(r3)), i2.tree_setToNode(t4, e4);
        } });
      else {
        if (!No.isCompositeType(i2))
          throw Error(`Unknown fieldType ${i2.typeName} for fieldName ${n2}`);
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          const e4 = this.viewsChanged.get(r3);
          if (e4)
            return e4;
          let t4 = this.nodes[r3];
          void 0 === t4 && (t4 = bo.getNodeAtDepth(this._rootNode, this.type.depth, r3), this.nodes[r3] = t4);
          const n3 = i2.getViewDU(t4, this.caches[r3]);
          return i2.isViewMutable && this.viewsChanged.set(r3, n3), n3;
        }, set: function(e4) {
          this.viewsChanged.set(r3, e4);
        } });
      }
    }
    return Object.defineProperty(t3, "name", { value: e3.typeName, writable: false }), t3;
  };
});
var Ho = ye(function(e2, t2) {
  var r2 = pe && pe.__importDefault || function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.renderContainerTypeName = t2.precomputeJsonKey = t2.ContainerType = void 0;
  const n2 = r2(Vo);
  class i2 extends No.CompositeType {
    constructor(e3, t3) {
      var _a3, _b, _c, _d, _e2;
      super(t3 == null ? void 0 : t3.cachePermanentRootStruct), this.fields = e3, this.opts = t3, this.isList = false, this.isViewMutable = true, this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : s2(e3), this.maxChunkCount = Object.keys(e3).length, this.depth = Eo.maxChunksToDepth(this.maxChunkCount), this.fieldsEntries = [];
      for (const r4 of Object.keys(e3))
        this.fieldsEntries.push({ fieldName: r4, fieldType: this.fields[r4], jsonKey: o2(r4, t3 == null ? void 0 : t3.casingMap, t3 == null ? void 0 : t3.jsonCase), gindex: bo.toGindex(this.depth, BigInt(this.fieldsEntries.length)) });
      if (0 === this.fieldsEntries.length)
        throw Error("Container must have > 0 fields");
      this.fieldsGindex = {};
      for (let e4 = 0; e4 < this.fieldsEntries.length; e4++)
        this.fieldsGindex[this.fieldsEntries[e4].fieldName] = bo.toGindex(this.depth, BigInt(e4));
      this.jsonKeyToFieldName = {};
      for (const { fieldName: e4, jsonKey: t4 } of this.fieldsEntries)
        this.jsonKeyToFieldName[t4] = e4;
      const { minLen: r3, maxLen: n3, fixedSize: i3 } = function(e4) {
        let t4 = 0, r4 = 0, n4 = 0;
        for (const i4 of Object.values(e4))
          t4 += i4.minSize, r4 += i4.maxSize, null === i4.fixedSize ? (t4 += 4, r4 += 4, n4 = null) : null !== n4 && (n4 += i4.fixedSize);
        return { minLen: t4, maxLen: r4, fixedSize: n4 };
      }(e3);
      this.minSize = r3, this.maxSize = n3, this.fixedSize = i3;
      const { isFixedLen: a2, fieldRangesFixedLen: u2, variableOffsetsPosition: h2, fixedEnd: f2 } = function(e4) {
        const t4 = [], r4 = [], n4 = [];
        let i4 = 0;
        for (const o3 of Object.values(e4))
          t4.push(null !== o3.fixedSize), null === o3.fixedSize ? (n4.push(i4), i4 += 4) : (r4.push({ start: i4, end: i4 + o3.fixedSize }), i4 += o3.fixedSize);
        return { isFixedLen: t4, fieldRangesFixedLen: r4, variableOffsetsPosition: n4, fixedEnd: i4 };
      }(e3);
      this.isFixedLen = a2, this.fieldRangesFixedLen = u2, this.variableOffsetsPosition = h2, this.fixedEnd = f2, this.TreeView = (_c = (_b = t3 == null ? void 0 : t3.getContainerTreeViewClass) == null ? void 0 : _b.call(t3, this)) != null ? _c : jo.getContainerTreeViewClass(this), this.TreeViewDU = (_e2 = (_d = t3 == null ? void 0 : t3.getContainerTreeViewDUClass) == null ? void 0 : _d.call(t3, this)) != null ? _e2 : Fo.getContainerTreeViewDUClass(this);
    }
    static named(e3, t3) {
      return new (xo.namedClass(i2, t3.typeName))(e3, t3);
    }
    defaultValue() {
      const e3 = {};
      for (const { fieldName: t3, fieldType: r3 } of this.fieldsEntries)
        e3[t3] = r3.defaultValue();
      return e3;
    }
    getView(e3) {
      return new this.TreeView(this, e3);
    }
    getViewDU(e3, t3) {
      return new this.TreeViewDU(this, e3, t3);
    }
    cacheOfViewDU(e3) {
      return e3.cache;
    }
    commitView(e3) {
      return e3.node;
    }
    commitViewDU(e3) {
      return e3.commit(), e3.node;
    }
    value_serializedSize(e3) {
      let t3 = 0;
      for (let r3 = 0; r3 < this.fieldsEntries.length; r3++) {
        const { fieldName: n3, fieldType: i3 } = this.fieldsEntries[r3];
        t3 += null === i3.fixedSize ? 4 + i3.value_serializedSize(e3[n3]) : i3.fixedSize;
      }
      return t3;
    }
    value_serializeToBytes(e3, t3, r3) {
      let n3 = t3, i3 = t3 + this.fixedEnd;
      for (let o3 = 0; o3 < this.fieldsEntries.length; o3++) {
        const { fieldName: s3, fieldType: a2 } = this.fieldsEntries[o3];
        null === a2.fixedSize ? (e3.dataView.setUint32(n3, i3 - t3, true), n3 += 4, i3 = a2.value_serializeToBytes(e3, i3, r3[s3])) : n3 = a2.value_serializeToBytes(e3, n3, r3[s3]);
      }
      return i3;
    }
    value_deserializeFromBytes(e3, t3, r3) {
      const n3 = this.getFieldRanges(e3.dataView, t3, r3), i3 = {};
      for (let r4 = 0; r4 < this.fieldsEntries.length; r4++) {
        const { fieldName: o3, fieldType: s3 } = this.fieldsEntries[r4], a2 = n3[r4];
        i3[o3] = s3.value_deserializeFromBytes(e3, t3 + a2.start, t3 + a2.end);
      }
      return i3;
    }
    tree_serializedSize(e3) {
      let t3 = 0;
      const r3 = bo.getNodesAtDepth(e3, this.depth, 0, this.fieldsEntries.length);
      for (let e4 = 0; e4 < this.fieldsEntries.length; e4++) {
        const { fieldType: n3 } = this.fieldsEntries[e4];
        t3 += null === n3.fixedSize ? 4 + n3.tree_serializedSize(r3[e4]) : n3.fixedSize;
      }
      return t3;
    }
    tree_serializeToBytes(e3, t3, r3) {
      let n3 = t3, i3 = t3 + this.fixedEnd;
      const o3 = bo.getNodesAtDepth(r3, this.depth, 0, this.fieldsEntries.length);
      for (let r4 = 0; r4 < this.fieldsEntries.length; r4++) {
        const { fieldType: s3 } = this.fieldsEntries[r4], a2 = o3[r4];
        null === s3.fixedSize ? (e3.dataView.setUint32(n3, i3 - t3, true), n3 += 4, i3 = s3.tree_serializeToBytes(e3, i3, a2)) : n3 = s3.tree_serializeToBytes(e3, n3, a2);
      }
      return i3;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      const n3 = this.getFieldRanges(e3.dataView, t3, r3), i3 = new Array(this.fieldsEntries.length);
      for (let r4 = 0; r4 < this.fieldsEntries.length; r4++) {
        const { fieldType: o3 } = this.fieldsEntries[r4], s3 = n3[r4];
        i3[r4] = o3.tree_deserializeFromBytes(e3, t3 + s3.start, t3 + s3.end);
      }
      return bo.subtreeFillToContents(i3, this.depth);
    }
    getRoots(e3) {
      const t3 = new Array(this.fieldsEntries.length);
      for (let r3 = 0; r3 < this.fieldsEntries.length; r3++) {
        const { fieldName: n3, fieldType: i3 } = this.fieldsEntries[r3];
        t3[r3] = i3.hashTreeRoot(e3[n3]);
      }
      return t3;
    }
    getPropertyGindex(e3) {
      var _a3;
      const t3 = (_a3 = this.fieldsGindex[e3]) != null ? _a3 : this.fieldsGindex[this.jsonKeyToFieldName[e3]];
      if (void 0 === t3)
        throw Error(`Unknown container property ${e3}`);
      return t3;
    }
    getPropertyType(e3) {
      var _a3;
      const t3 = (_a3 = this.fields[e3]) != null ? _a3 : this.fields[this.jsonKeyToFieldName[e3]];
      if (void 0 === t3)
        throw Error(`Unknown container property ${e3}`);
      return t3;
    }
    getIndexProperty(e3) {
      return e3 >= this.fieldsEntries.length ? null : this.fieldsEntries[e3].fieldName;
    }
    tree_getLeafGindices(e3, t3) {
      const r3 = [];
      for (let n3 = 0; n3 < this.fieldsEntries.length; n3++) {
        const { fieldName: i3, fieldType: o3 } = this.fieldsEntries[n3], s3 = this.fieldsGindex[i3], a2 = bo.concatGindices([e3, s3]);
        if (o3.isBasic)
          r3.push(a2);
        else {
          const e4 = o3;
          if (null === o3.fixedSize) {
            if (!t3)
              throw new Error("variable type requires tree argument to get leaves");
            r3.push(...e4.tree_getLeafGindices(a2, bo.getNode(t3, s3)));
          } else
            r3.push(...e4.tree_getLeafGindices(a2));
        }
      }
      return r3;
    }
    fromJson(e3) {
      if ("object" != typeof e3)
        throw Error("JSON must be of type object");
      if (null === e3)
        throw Error("JSON must not be null");
      const t3 = {};
      for (let r3 = 0; r3 < this.fieldsEntries.length; r3++) {
        const { fieldName: n3, fieldType: i3, jsonKey: o3 } = this.fieldsEntries[r3], s3 = e3[o3];
        if (void 0 === s3)
          throw Error(`JSON expected key ${o3} is undefined`);
        t3[n3] = i3.fromJson(s3);
      }
      return t3;
    }
    toJson(e3) {
      const t3 = {};
      for (let r3 = 0; r3 < this.fieldsEntries.length; r3++) {
        const { fieldName: n3, fieldType: i3, jsonKey: o3 } = this.fieldsEntries[r3];
        t3[o3] = i3.toJson(e3[n3]);
      }
      return t3;
    }
    clone(e3) {
      const t3 = {};
      for (let r3 = 0; r3 < this.fieldsEntries.length; r3++) {
        const { fieldName: n3, fieldType: i3 } = this.fieldsEntries[r3];
        t3[n3] = i3.clone(e3[n3]);
      }
      return t3;
    }
    equals(e3, t3) {
      for (let r3 = 0; r3 < this.fieldsEntries.length; r3++) {
        const { fieldName: n3, fieldType: i3 } = this.fieldsEntries[r3];
        if (!i3.equals(e3[n3], t3[n3]))
          return false;
      }
      return true;
    }
    getFieldRanges(e3, t3, r3) {
      if (0 === this.variableOffsetsPosition.length) {
        const e4 = r3 - t3;
        if (e4 !== this.fixedEnd)
          throw Error(`${this.typeName} size ${e4} not equal fixed size ${this.fixedEnd}`);
        return this.fieldRangesFixedLen;
      }
      const n3 = function(e4, t4, r4, n4, i4) {
        const o4 = r4 - t4, s4 = new Array(i4.length);
        for (let r5 = 0; r5 < i4.length; r5++) {
          const a2 = e4.getUint32(t4 + i4[r5], true);
          if (a2 > o4)
            throw new Error(`Offset out of bounds ${a2} > ${o4}`);
          if (0 === r5) {
            if (a2 !== n4)
              throw new Error(`First offset must equal to fixedEnd ${a2} != ${n4}`);
          } else if (a2 < s4[r5 - 1])
            throw new Error(`Offsets must be increasing ${a2} < ${s4[r5 - 1]}`);
          s4[r5] = a2;
        }
        return s4;
      }(e3, t3, r3, this.fixedEnd, this.variableOffsetsPosition);
      n3.push(r3 - t3);
      let i3 = 0, o3 = 0;
      const s3 = new Array(this.isFixedLen.length);
      for (let e4 = 0; e4 < this.isFixedLen.length; e4++)
        this.isFixedLen[e4] ? s3[e4] = this.fieldRangesFixedLen[o3++] : (s3[e4] = { start: n3[i3], end: n3[i3 + 1] }, i3++);
      return s3;
    }
  }
  function o2(e3, t3, r3) {
    if (t3) {
      const r4 = t3[e3];
      if (void 0 === r4)
        throw Error(`casingMap[${e3}] not defined`);
      return r4;
    }
    return r3 ? "eth2" === r3 ? n2.default.snake(e3).replace(/(\d)$/, "_$1") : n2.default[r3](e3) : e3;
  }
  function s2(e3, t3 = "Container") {
    return `${t3}({${Object.keys(e3).map((t4) => `${t4}: ${e3[t4].typeName}`).join(", ")}})`;
  }
  t2.ContainerType = i2, t2.precomputeJsonKey = o2, t2.renderContainerTypeName = s2;
});
var Ko = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BranchNodeStruct = void 0, t2.BranchNodeStruct = class extends bo.Node {
    constructor(e3, t3) {
      super(null, 0, 0, 0, 0, 0, 0, 0), this.valueToNode = e3, this.value = t3;
    }
    get rootHashObject() {
      if (null === this.h0) {
        const e3 = this.valueToNode(this.value);
        super.applyHash(e3.rootHashObject);
      }
      return this;
    }
    get root() {
      return bo.hashObjectToUint8Array(this.rootHashObject);
    }
    isLeaf() {
      return false;
    }
    get left() {
      return this.valueToNode(this.value).left;
    }
    get right() {
      return this.valueToNode(this.value).right;
    }
  };
});
var Go = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getContainerTreeViewClass = void 0;
  class r2 extends Io.TreeView {
    constructor(e3, t3) {
      super(), this.type = e3, this.tree = t3;
    }
    get node() {
      return this.tree.rootNode;
    }
  }
  t2.getContainerTreeViewClass = function(e3) {
    class t3 extends r2 {
    }
    for (let r3 = 0; r3 < e3.fieldsEntries.length; r3++) {
      const { fieldName: n2, fieldType: i2 } = e3.fieldsEntries[r3];
      if (i2.isBasic)
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          return this.tree.rootNode.value[n2];
        }, set: function(e4) {
          const t4 = this.tree.rootNode, r4 = this.type.clone(t4.value);
          r4[n2] = e4, this.tree.rootNode = new Ko.BranchNodeStruct(t4.valueToNode, r4);
        } });
      else {
        if (!No.isCompositeType(i2))
          throw Error(`Unknown fieldType ${i2.typeName} for fieldName ${n2}`);
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          const { value: e4 } = this.tree.rootNode;
          return i2.toView(e4[n2]);
        }, set: function(e4) {
          const t4 = this.tree.rootNode, r4 = this.type.clone(t4.value);
          r4[n2] = i2.toValueFromView(e4), this.tree.rootNode = new Ko.BranchNodeStruct(t4.valueToNode, r4);
        } });
      }
    }
    return Object.defineProperty(t3, "name", { value: e3.typeName, writable: false }), t3;
  };
});
var qo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getContainerTreeViewDUClass = void 0;
  class r2 extends Uo.TreeViewDU {
    constructor(e3, t3) {
      super(), this.type = e3, this.valueChanged = null, this._rootNode = t3;
    }
    get node() {
      return this._rootNode;
    }
    get cache() {
    }
    commit() {
      if (null === this.valueChanged)
        return;
      const e3 = this.valueChanged;
      this.valueChanged = null, this._rootNode = this.type.value_toTree(e3);
    }
    clearCache() {
      this.valueChanged = null;
    }
  }
  t2.getContainerTreeViewDUClass = function(e3) {
    class t3 extends r2 {
    }
    for (let r3 = 0; r3 < e3.fieldsEntries.length; r3++) {
      const { fieldName: n2, fieldType: i2 } = e3.fieldsEntries[r3];
      if (i2.isBasic)
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          return (this.valueChanged || this._rootNode.value)[n2];
        }, set: function(e4) {
          null === this.valueChanged && (this.valueChanged = this.type.clone(this._rootNode.value)), this.valueChanged[n2] = e4;
        } });
      else {
        if (!No.isCompositeType(i2))
          throw Error(`Unknown fieldType ${i2.typeName} for fieldName ${n2}`);
        Object.defineProperty(t3.prototype, n2, { configurable: false, enumerable: true, get: function() {
          return i2.toViewDU((this.valueChanged || this._rootNode.value)[n2]);
        }, set: function(e4) {
          null === this.valueChanged && (this.valueChanged = this.type.clone(this._rootNode.value));
          const t4 = i2.toValueFromViewDU(e4);
          this.valueChanged[n2] = t4;
        } });
      }
    }
    return Object.defineProperty(t3, "name", { value: e3.typeName, writable: false }), t3;
  };
});
var Jo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ContainerNodeStructType = void 0, t2.ContainerNodeStructType = class extends Ho.ContainerType {
    constructor(e3, t3) {
      var _a3;
      super(e3, { typeName: (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : Ho.renderContainerTypeName(e3, "ContainerNodeStruct"), ...t3, getContainerTreeViewClass: Go.getContainerTreeViewClass, getContainerTreeViewDUClass: qo.getContainerTreeViewDUClass }), this.fields = e3;
      for (const { fieldName: e4, fieldType: t4 } of this.fieldsEntries)
        if (No.isCompositeType(t4) && t4.isViewMutable)
          throw Error(`ContainerNodeStructType field '${e4}' ${t4.typeName} view is mutable`);
    }
    static named(e3, t3) {
      return new (xo.namedClass(Ho.ContainerType, t3.typeName))(e3, t3);
    }
    tree_serializedSize(e3) {
      return this.value_serializedSize(e3.value);
    }
    tree_serializeToBytes(e3, t3, r2) {
      const { value: n2 } = r2;
      return this.value_serializeToBytes(e3, t3, n2);
    }
    tree_deserializeFromBytes(e3, t3, r2) {
      const n2 = this.value_deserializeFromBytes(e3, t3, r2);
      return new Ko.BranchNodeStruct(this.valueToTree.bind(this), n2);
    }
    getPropertyGindex() {
      return null;
    }
    tree_fromProofNode(e3) {
      const t3 = new Uint8Array(super.tree_serializedSize(e3)), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      super.tree_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3);
      const n2 = this.value_deserializeFromBytes({ uint8Array: t3, dataView: r2 }, 0, t3.length);
      return { node: new Ko.BranchNodeStruct(this.valueToTree.bind(this), n2), done: true };
    }
    tree_toValue(e3) {
      return e3.value;
    }
    value_toTree(e3) {
      return new Ko.BranchNodeStruct(this.valueToTree.bind(this), e3);
    }
    valueToTree(e3) {
      const t3 = new Uint8Array(this.value_serializedSize(e3)), r2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return this.value_serializeToBytes({ uint8Array: t3, dataView: r2 }, 0, e3), super.tree_deserializeFromBytes({ uint8Array: t3, dataView: r2 }, 0, t3.length);
    }
  };
});
var Wo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayBasicTreeView = void 0, t2.ArrayBasicTreeView = class extends Io.TreeView {
    constructor(e3, t3) {
      super(), this.type = e3, this.tree = t3;
    }
    get length() {
      return this.type.tree_getLength(this.tree.rootNode);
    }
    get node() {
      return this.tree.rootNode;
    }
    get(e3) {
      const t3 = Math.floor(e3 / this.type.itemsPerChunk), r2 = this.tree.getNodeAtDepth(this.type.depth, t3);
      return this.type.elementType.tree_getFromPackedNode(r2, e3);
    }
    set(e3, t3) {
      const r2 = this.length;
      if (e3 >= r2)
        throw Error(`Error setting index over length ${e3} > ${r2}`);
      const n2 = Math.floor(e3 / this.type.itemsPerChunk), i2 = this.tree.getNodeAtDepth(this.type.depth, n2).clone();
      this.type.elementType.tree_setToPackedNode(i2, e3, t3), this.tree.setNodeAtDepth(this.type.depth, n2, i2);
    }
    getAll() {
      const e3 = this.length, t3 = this.type.tree_getChunksNode(this.node), r2 = Math.ceil(e3 / this.type.itemsPerChunk), n2 = bo.getNodesAtDepth(t3, this.type.chunkDepth, 0, r2), i2 = new Array(e3), o2 = this.type.itemsPerChunk, s2 = Math.floor(e3 / o2), a2 = e3 % o2;
      for (let e4 = 0; e4 < s2; e4++) {
        const t4 = n2[e4];
        for (let r3 = 0; r3 < o2; r3++)
          i2[e4 * o2 + r3] = this.type.elementType.tree_getFromPackedNode(t4, r3);
      }
      if (a2 > 0) {
        const e4 = n2[s2];
        for (let t4 = 0; t4 < a2; t4++)
          i2[s2 * o2 + t4] = this.type.elementType.tree_getFromPackedNode(e4, t4);
      }
      return i2;
    }
  };
});
var Zo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ListBasicTreeView = void 0, t2.ListBasicTreeView = class extends Wo.ArrayBasicTreeView {
    constructor(e3, t3) {
      super(e3, t3), this.type = e3, this.tree = t3;
    }
    push(e3) {
      const t3 = this.length;
      if (t3 >= this.type.limit)
        throw Error("Error pushing over limit");
      if (this.type.tree_setLength(this.tree, t3 + 1), t3 % this.type.itemsPerChunk == 0) {
        const r2 = bo.LeafNode.fromZero();
        this.type.elementType.tree_setToPackedNode(r2, t3, e3);
        const n2 = Math.floor(t3 / this.type.itemsPerChunk);
        this.tree.setNodeAtDepth(this.type.depth, n2, r2);
      } else
        this.set(t3, e3);
    }
  };
});
var Yo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayBasicTreeViewDU = void 0, t2.ArrayBasicTreeViewDU = class extends Uo.TreeViewDU {
    constructor(e3, t3, r2) {
      super(), this.type = e3, this._rootNode = t3, this.nodesChanged = /* @__PURE__ */ new Set(), this.dirtyLength = false, r2 ? (this.nodes = r2.nodes, this._length = r2.length, this.nodesPopulated = r2.nodesPopulated) : (this.nodes = [], this._length = this.type.tree_getLength(t3), this.nodesPopulated = false);
    }
    get length() {
      return this._length;
    }
    get node() {
      return this._rootNode;
    }
    get cache() {
      return { nodes: this.nodes, length: this._length, nodesPopulated: this.nodesPopulated };
    }
    get(e3) {
      const t3 = Math.floor(e3 / this.type.itemsPerChunk);
      let r2 = this.nodes[t3];
      return void 0 === r2 && (r2 = bo.getNodeAtDepth(this._rootNode, this.type.depth, t3), this.nodes[t3] = r2), this.type.elementType.tree_getFromPackedNode(r2, e3);
    }
    set(e3, t3) {
      var _a3;
      if (e3 >= this._length)
        throw Error(`Error setting index over length ${e3} > ${this._length}`);
      const r2 = Math.floor(e3 / this.type.itemsPerChunk);
      let n2;
      this.nodesChanged.has(r2) ? n2 = this.nodes[r2] : (n2 = ((_a3 = this.nodes[r2]) != null ? _a3 : bo.getNodeAtDepth(this._rootNode, this.type.depth, r2)).clone(), this.nodes[r2] = n2, this.nodesChanged.add(r2)), this.type.elementType.tree_setToPackedNode(n2, e3, t3);
    }
    getAll() {
      if (!this.nodesPopulated) {
        const e4 = this.nodes, t4 = this.type.tree_getChunksNode(this.node), r3 = Math.ceil(this._length / this.type.itemsPerChunk);
        this.nodes = bo.getNodesAtDepth(t4, this.type.chunkDepth, 0, r3);
        for (const t5 of this.nodesChanged)
          this.nodes[t5] = e4[t5];
        this.nodesPopulated = true;
      }
      const e3 = new Array(this._length), t3 = this.type.itemsPerChunk, r2 = Math.floor(this._length / t3), n2 = this._length % t3;
      for (let n3 = 0; n3 < r2; n3++) {
        const r3 = this.nodes[n3];
        for (let i2 = 0; i2 < t3; i2++)
          e3[n3 * t3 + i2] = this.type.elementType.tree_getFromPackedNode(r3, i2);
      }
      if (n2 > 0) {
        const i2 = this.nodes[r2];
        for (let o2 = 0; o2 < n2; o2++)
          e3[r2 * t3 + o2] = this.type.elementType.tree_getFromPackedNode(i2, o2);
      }
      return e3;
    }
    commit() {
      if (0 === this.nodesChanged.size)
        return;
      const e3 = Array.from(this.nodesChanged.keys()).sort((e4, t4) => e4 - t4), t3 = new Array(e3.length);
      for (let r3 = 0; r3 < e3.length; r3++)
        t3[r3] = this.nodes[e3[r3]];
      const r2 = this.type.tree_getChunksNode(this._rootNode), n2 = bo.setNodesAtDepth(r2, this.type.chunkDepth, e3, t3);
      this._rootNode = this.type.tree_setChunksNode(this._rootNode, n2, this.dirtyLength ? this._length : void 0), this.nodesChanged.clear(), this.dirtyLength = false;
    }
    clearCache() {
      this.nodes = [], this.nodesPopulated = false, this.nodesChanged.clear(), this.dirtyLength && (this._length = this.type.tree_getLength(this._rootNode), this.dirtyLength = false);
    }
  };
});
var Xo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ListBasicTreeViewDU = void 0, t2.ListBasicTreeViewDU = class extends Yo.ArrayBasicTreeViewDU {
    constructor(e3, t3, r2) {
      super(e3, t3, r2), this.type = e3, this._rootNode = t3;
    }
    push(e3) {
      if (this._length >= this.type.limit)
        throw Error("Error pushing over limit");
      this.dirtyLength = true;
      const t3 = this._length++;
      if (t3 % this.type.itemsPerChunk == 0) {
        const e4 = Math.floor(t3 / this.type.itemsPerChunk);
        this.nodes[e4] = bo.zeroNode(0);
      }
      this.set(t3, e3);
    }
  };
});
var Qo = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayType = void 0, t2.ArrayType = class extends No.CompositeType {
    constructor(e3) {
      super(), this.elementType = e3;
    }
    defaultValue() {
      return Bo.value_defaultValueArray(this.elementType, this.defaultLen);
    }
    getPropertyType() {
      return this.elementType;
    }
    getPropertyGindex(e3) {
      if ("number" != typeof e3)
        throw Error(`Invalid array index: ${e3}`);
      const t3 = Math.floor(e3 / this.itemsPerChunk);
      return bo.toGindex(this.depth, BigInt(t3));
    }
    getIndexProperty(e3) {
      return e3;
    }
    tree_getLeafGindices(e3, t3) {
      let r2;
      if (this.isList) {
        if (!t3)
          throw new Error("List type requires tree argument to get leaves");
        r2 = this.tree_getLength(t3);
      } else
        r2 = this.tree_getLength(null);
      const n2 = [];
      if (No.isCompositeType(this.elementType)) {
        const i2 = bo.toGindex(this.depth, BigInt(0)), o2 = i2 + BigInt(r2), s2 = bo.concatGindices([e3, i2]);
        if (null === this.elementType.fixedSize) {
          if (!t3)
            throw new Error("Array of variable size requires tree argument to get leaves");
          for (let e4 = i2, r3 = s2; e4 < o2; e4++, r3++)
            n2.push(...this.elementType.tree_getLeafGindices(r3, bo.getNode(t3, e4)));
        } else
          for (let e4 = 0, t4 = s2; e4 < r2; e4++, t4++)
            n2.push(...this.elementType.tree_getLeafGindices(t4));
      } else {
        const t4 = Math.ceil(r2 / this.itemsPerChunk), i2 = bo.concatGindices([e3, bo.toGindex(this.depth, BigInt(0))]), o2 = i2 + BigInt(t4);
        for (let e4 = i2; e4 < o2; e4++)
          n2.push(e4);
      }
      return this.isList && n2.push(bo.concatGindices([e3, No.LENGTH_GINDEX])), n2;
    }
    fromJson(e3) {
      return Bo.value_fromJsonArray(this.elementType, e3, this);
    }
    toJson(e3) {
      return Bo.value_toJsonArray(this.elementType, e3, this);
    }
    clone(e3) {
      return Bo.value_cloneArray(this.elementType, e3);
    }
    equals(e3, t3) {
      return Bo.value_equals(this.elementType, e3, t3);
    }
  };
});
var es = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ListBasicType = void 0;
  class r2 extends Qo.ArrayType {
    constructor(e3, t3, r3) {
      var _a3;
      if (super(e3), this.elementType = e3, this.limit = t3, this.fixedSize = null, this.isList = true, this.isViewMutable = true, this.defaultLen = 0, !e3.isBasic)
        throw Error("elementType must be basic");
      if (0 === t3)
        throw Error("List limit must be > 0");
      this.typeName = (_a3 = r3 == null ? void 0 : r3.typeName) != null ? _a3 : `List[${e3.typeName}, ${t3}]`, this.itemsPerChunk = 32 / e3.byteLength, this.maxChunkCount = Math.ceil(this.limit * e3.byteLength / 32), this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = this.chunkDepth + 1, this.minSize = 0, this.maxSize = this.limit * e3.maxSize;
    }
    static named(e3, t3, n2) {
      return new (xo.namedClass(r2, n2.typeName))(e3, t3, n2);
    }
    getView(e3) {
      return new Zo.ListBasicTreeView(this, e3);
    }
    getViewDU(e3, t3) {
      return new Xo.ListBasicTreeViewDU(this, e3, t3);
    }
    commitView(e3) {
      return e3.node;
    }
    commitViewDU(e3) {
      return e3.commit(), e3.node;
    }
    cacheOfViewDU(e3) {
      return e3.cache;
    }
    value_serializedSize(e3) {
      return e3.length * this.elementType.byteLength;
    }
    value_serializeToBytes(e3, t3, r3) {
      return Bo.value_serializeToBytesArrayBasic(this.elementType, r3.length, e3, t3, r3);
    }
    value_deserializeFromBytes(e3, t3, r3) {
      return Bo.value_deserializeFromBytesArrayBasic(this.elementType, e3, t3, r3, this);
    }
    tree_serializedSize(e3) {
      return this.tree_getLength(e3) * this.elementType.byteLength;
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n2 = this.tree_getChunksNode(r3), i2 = this.tree_getLength(r3);
      return Bo.tree_serializeToBytesArrayBasic(this.elementType, i2, this.chunkDepth, e3, t3, n2);
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      return Bo.tree_deserializeFromBytesArrayBasic(this.elementType, this.chunkDepth, e3, t3, r3, this);
    }
    tree_getLength(e3) {
      return e3.right.getUint(4, 0);
    }
    tree_setLength(e3, t3) {
      e3.rootNode = Bo.addLengthNode(e3.rootNode.left, t3);
    }
    tree_getChunksNode(e3) {
      return e3.left;
    }
    tree_setChunksNode(e3, t3, r3) {
      return Bo.setChunksNode(e3, t3, r3);
    }
    hashTreeRoot(e3) {
      return Eo.mixInLength(super.hashTreeRoot(e3), e3.length);
    }
    getRoots(e3) {
      const t3 = new Uint8Array(this.value_serializedSize(e3)), r3 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return Bo.value_serializeToBytesArrayBasic(this.elementType, e3.length, { uint8Array: t3, dataView: r3 }, 0, e3), Eo.splitIntoRootChunks(t3);
    }
  }
  t2.ListBasicType = r2;
});
var ts = ye(function(e2, t2) {
  function r2(e3, t3, r3, n2, i2) {
    const o2 = n2 - r3;
    let s2;
    if (null === e3)
      s2 = function(e4, t4, r4) {
        if (0 === r4)
          return new Uint32Array(0);
        const n3 = e4.getUint32(t4, true), i3 = n3;
        if (0 === n3)
          throw Error("First offset must be > 0");
        if (i3 % 4 != 0)
          throw Error("Offset data length not multiple of 4");
        const o3 = i3 / 4, s3 = new Uint32Array(o3);
        s3[0] = n3;
        for (let n4 = 1; n4 < o3; n4++) {
          const i4 = e4.getUint32(t4 + 4 * n4, true);
          if (s3[n4] = i4, i4 > r4)
            throw new Error(`Offset out of bounds ${i4} > ${r4}`);
          if (i4 < s3[n4 - 1])
            throw new Error(`Offsets must be increasing ${i4} < ${s3[n4 - 1]}`);
        }
        return s3;
      }(t3, r3, o2);
    else {
      if (0 === e3)
        throw Error("element fixed length is 0");
      if (o2 % e3 != 0)
        throw Error(`size ${o2} is not multiple of element fixedSize ${e3}`);
      const t4 = o2 / e3;
      s2 = new Uint32Array(t4);
      for (let r4 = 0; r4 < t4; r4++)
        s2[r4] = r4 * e3;
    }
    return Bo.assertValidArrayLength(s2.length, i2), s2;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.value_getRootsArrayComposite = t2.tree_deserializeFromBytesArrayComposite = t2.tree_serializeToBytesArrayComposite = t2.tree_serializedSizeArrayComposite = t2.value_deserializeFromBytesArrayComposite = t2.value_serializeToBytesArrayComposite = t2.value_serializedSizeArrayComposite = t2.maxSizeArrayComposite = t2.minSizeArrayComposite = void 0, t2.minSizeArrayComposite = function(e3, t3) {
    return null === e3.fixedSize ? t3 * (4 + e3.minSize) : t3 * e3.minSize;
  }, t2.maxSizeArrayComposite = function(e3, t3) {
    return null === e3.fixedSize ? t3 * (4 + e3.maxSize) : t3 * e3.maxSize;
  }, t2.value_serializedSizeArrayComposite = function(e3, t3, r3) {
    if (null === e3.fixedSize) {
      let n2 = 0;
      for (let i2 = 0; i2 < t3; i2++)
        n2 += 4 + e3.value_serializedSize(r3[i2]);
      return n2;
    }
    return t3 * e3.fixedSize;
  }, t2.value_serializeToBytesArrayComposite = function(e3, t3, r3, n2, i2) {
    if (null === e3.fixedSize) {
      let o2 = n2 + 4 * t3;
      for (let s2 = 0; s2 < t3; s2++)
        r3.dataView.setUint32(n2 + 4 * s2, o2 - n2, true), o2 = e3.value_serializeToBytes(r3, o2, i2[s2]);
      return o2;
    }
    for (let o2 = 0; o2 < t3; o2++)
      e3.value_serializeToBytes(r3, n2 + o2 * e3.fixedSize, i2[o2]);
    return n2 + t3 * e3.fixedSize;
  }, t2.value_deserializeFromBytesArrayComposite = function(e3, t3, n2, i2, o2) {
    const s2 = r2(e3.fixedSize, t3.dataView, n2, i2, o2), a2 = s2.length, u2 = new Array(a2);
    for (let r3 = 0; r3 < a2; r3++)
      u2[r3] = e3.value_deserializeFromBytes(t3, n2 + s2[r3], r3 === a2 - 1 ? i2 : n2 + s2[r3 + 1]);
    return u2;
  }, t2.tree_serializedSizeArrayComposite = function(e3, t3, r3, n2) {
    if (null === e3.fixedSize) {
      const i2 = bo.getNodesAtDepth(n2, r3, 0, t3);
      let o2 = 0;
      for (let t4 = 0; t4 < i2.length; t4++)
        o2 += 4 + e3.tree_serializedSize(i2[t4]);
      return o2;
    }
    return t3 * e3.fixedSize;
  }, t2.tree_serializeToBytesArrayComposite = function(e3, t3, r3, n2, i2, o2) {
    const s2 = bo.getNodesAtDepth(n2, r3, 0, t3);
    if (null === e3.fixedSize) {
      let r4 = o2 + 4 * t3;
      const { dataView: n3 } = i2;
      for (let t4 = 0; t4 < s2.length; t4++)
        n3.setUint32(o2 + 4 * t4, r4 - o2, true), r4 = e3.tree_serializeToBytes(i2, r4, s2[t4]);
      return r4;
    }
    for (let t4 = 0; t4 < s2.length; t4++)
      o2 = e3.tree_serializeToBytes(i2, o2, s2[t4]);
    return o2;
  }, t2.tree_deserializeFromBytesArrayComposite = function(e3, t3, n2, i2, o2, s2) {
    const a2 = r2(e3.fixedSize, n2.dataView, i2, o2, s2), u2 = a2.length, h2 = new Array(u2);
    for (let t4 = 0; t4 < u2; t4++)
      h2[t4] = e3.tree_deserializeFromBytes(n2, i2 + a2[t4], t4 === u2 - 1 ? o2 : i2 + a2[t4 + 1]);
    const f2 = bo.subtreeFillToContents(h2, t3);
    return s2.isList ? Bo.addLengthNode(f2, u2) : f2;
  }, t2.value_getRootsArrayComposite = function(e3, t3, r3) {
    const n2 = new Array(t3);
    for (let i2 = 0; i2 < t3; i2++)
      n2[i2] = e3.hashTreeRoot(r3[i2]);
    return n2;
  };
});
var rs = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayCompositeTreeView = void 0, t2.ArrayCompositeTreeView = class extends Io.TreeView {
    constructor(e3, t3) {
      super(), this.type = e3, this.tree = t3;
    }
    get length() {
      return this.type.tree_getLength(this.tree.rootNode);
    }
    get node() {
      return this.tree.rootNode;
    }
    get(e3) {
      const t3 = bo.toGindexBitstring(this.type.depth, e3), r2 = this.tree.getSubtree(t3);
      return this.type.elementType.getView(r2);
    }
    getReadonly(e3) {
      const t3 = bo.toGindexBitstring(this.type.depth, e3), r2 = new bo.Tree(this.tree.getNode(t3));
      return this.type.elementType.getView(r2);
    }
    set(e3, t3) {
      const r2 = this.length;
      if (e3 >= r2)
        throw Error(`Error setting index over length ${e3} > ${r2}`);
      const n2 = this.type.elementType.commitView(t3);
      this.tree.setNodeAtDepth(this.type.depth, e3, n2);
    }
    getAllReadonly() {
      const e3 = this.length, t3 = this.type.tree_getChunksNode(this.node), r2 = bo.getNodesAtDepth(t3, this.type.chunkDepth, 0, e3), n2 = new Array(e3);
      for (let t4 = 0; t4 < e3; t4++)
        n2[t4] = this.type.elementType.getView(new bo.Tree(r2[t4]));
      return n2;
    }
    getAllReadonlyValues() {
      const e3 = this.length, t3 = this.type.tree_getChunksNode(this.node), r2 = bo.getNodesAtDepth(t3, this.type.chunkDepth, 0, e3), n2 = new Array(e3);
      for (let t4 = 0; t4 < e3; t4++)
        n2[t4] = this.type.elementType.tree_toValue(r2[t4]);
      return n2;
    }
  };
});
var ns = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ListCompositeTreeView = void 0, t2.ListCompositeTreeView = class extends rs.ArrayCompositeTreeView {
    constructor(e3, t3) {
      super(e3, t3), this.type = e3, this.tree = t3;
    }
    push(e3) {
      const t3 = this.length;
      if (t3 >= this.type.limit)
        throw Error("Error pushing over limit");
      this.type.tree_setLength(this.tree, t3 + 1), this.set(t3, e3);
    }
  };
});
var is = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayCompositeTreeViewDU = void 0, t2.ArrayCompositeTreeViewDU = class extends Uo.TreeViewDU {
    constructor(e3, t3, r2) {
      super(), this.type = e3, this._rootNode = t3, this.viewsChanged = /* @__PURE__ */ new Map(), this.dirtyLength = false, r2 ? (this.nodes = r2.nodes, this.caches = r2.caches, this._length = r2.length, this.nodesPopulated = r2.nodesPopulated) : (this.nodes = [], this.caches = [], this._length = this.type.tree_getLength(t3), this.nodesPopulated = 0 === this._length);
    }
    get length() {
      return this._length;
    }
    get node() {
      return this._rootNode;
    }
    get cache() {
      return { nodes: this.nodes, caches: this.caches, length: this._length, nodesPopulated: this.nodesPopulated };
    }
    get(e3) {
      const t3 = this.viewsChanged.get(e3);
      if (t3)
        return t3;
      let r2 = this.nodes[e3];
      void 0 === r2 && (r2 = bo.getNodeAtDepth(this._rootNode, this.type.depth, e3), this.nodes[e3] = r2);
      const n2 = this.type.elementType.getViewDU(r2, this.caches[e3]);
      return this.type.elementType.isViewMutable && this.viewsChanged.set(e3, n2), n2;
    }
    getReadonly(e3) {
      const t3 = this.viewsChanged.get(e3);
      if (t3)
        return t3;
      let r2 = this.nodes[e3];
      return void 0 === r2 && (r2 = bo.getNodeAtDepth(this._rootNode, this.type.depth, e3), this.nodes[e3] = r2), this.type.elementType.getViewDU(r2, this.caches[e3]);
    }
    set(e3, t3) {
      if (e3 >= this._length)
        throw Error(`Error setting index over length ${e3} > ${this._length}`);
      this.viewsChanged.set(e3, t3);
    }
    getAllReadonly() {
      this.populateAllNodes();
      const e3 = new Array(this._length);
      for (let t3 = 0; t3 < this._length; t3++)
        e3[t3] = this.type.elementType.getViewDU(this.nodes[t3], this.caches[t3]);
      return e3;
    }
    getAllReadonlyValues() {
      this.populateAllNodes();
      const e3 = new Array(this._length);
      for (let t3 = 0; t3 < this._length; t3++)
        e3[t3] = this.type.elementType.tree_toValue(this.nodes[t3]);
      return e3;
    }
    commit() {
      if (0 === this.viewsChanged.size)
        return;
      const e3 = [];
      for (const [t4, r3] of this.viewsChanged) {
        const n3 = this.type.elementType.commitViewDU(r3);
        this.nodes[t4] = n3, e3.push({ index: t4, node: n3 });
        const i3 = this.type.elementType.cacheOfViewDU(r3);
        i3 && (this.caches[t4] = i3);
      }
      const t3 = e3.sort((e4, t4) => e4.index - t4.index), r2 = t3.map((e4) => e4.index), n2 = t3.map((e4) => e4.node), i2 = this.type.tree_getChunksNode(this._rootNode), o2 = bo.setNodesAtDepth(i2, this.type.chunkDepth, r2, n2);
      this._rootNode = this.type.tree_setChunksNode(this._rootNode, o2, this.dirtyLength ? this._length : void 0), this.viewsChanged.clear(), this.dirtyLength = false;
    }
    clearCache() {
      this.nodes = [], this.caches = [], this.nodesPopulated = false, this.viewsChanged.clear(), this.dirtyLength && (this._length = this.type.tree_getLength(this._rootNode), this.dirtyLength = false);
    }
    populateAllNodes() {
      if (this.viewsChanged.size > 0)
        throw Error("Must commit changes before reading all nodes");
      this.nodesPopulated || (this.nodes = bo.getNodesAtDepth(this._rootNode, this.type.depth, 0, this.length), this.nodesPopulated = true);
    }
  };
});
var os = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ListCompositeTreeViewDU = void 0, t2.ListCompositeTreeViewDU = class extends is.ArrayCompositeTreeViewDU {
    constructor(e3, t3, r2) {
      super(e3, t3, r2), this.type = e3, this._rootNode = t3;
    }
    push(e3) {
      if (this._length >= this.type.limit)
        throw Error("Error pushing over limit");
      this.dirtyLength = true;
      const t3 = this._length++;
      this.set(t3, e3);
    }
    sliceTo(e3) {
      this.commit();
      const t3 = this._rootNode;
      if (e3 >= this.type.tree_getLength(t3) - 1)
        return this;
      const r2 = this.type.tree_getChunksNode(t3), n2 = bo.treeZeroAfterIndex(r2, this.type.chunkDepth, e3), i2 = this.type.tree_setChunksNode(t3, n2, e3 + 1);
      return this.type.getViewDU(i2);
    }
  };
});
var ss = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ListCompositeType = void 0;
  class r2 extends Qo.ArrayType {
    constructor(e3, t3, r3) {
      var _a3;
      if (super(e3), this.elementType = e3, this.limit = t3, this.itemsPerChunk = 1, this.fixedSize = null, this.isList = true, this.isViewMutable = true, this.defaultLen = 0, e3.isBasic)
        throw Error("elementType must not be basic");
      if (0 === t3)
        throw Error("List limit must be > 0");
      this.typeName = (_a3 = r3 == null ? void 0 : r3.typeName) != null ? _a3 : `List[${e3.typeName}, ${t3}]`, this.maxChunkCount = this.limit, this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = this.chunkDepth + 1, this.minSize = 0, this.maxSize = ts.maxSizeArrayComposite(e3, this.limit);
    }
    static named(e3, t3, n2) {
      return new (xo.namedClass(r2, n2.typeName))(e3, t3, n2);
    }
    getView(e3) {
      return new ns.ListCompositeTreeView(this, e3);
    }
    getViewDU(e3, t3) {
      return new os.ListCompositeTreeViewDU(this, e3, t3);
    }
    commitView(e3) {
      return e3.node;
    }
    commitViewDU(e3) {
      return e3.commit(), e3.node;
    }
    cacheOfViewDU(e3) {
      return e3.cache;
    }
    value_serializedSize(e3) {
      return ts.value_serializedSizeArrayComposite(this.elementType, e3.length, e3);
    }
    value_serializeToBytes(e3, t3, r3) {
      return ts.value_serializeToBytesArrayComposite(this.elementType, r3.length, e3, t3, r3);
    }
    value_deserializeFromBytes(e3, t3, r3) {
      return ts.value_deserializeFromBytesArrayComposite(this.elementType, e3, t3, r3, this);
    }
    tree_serializedSize(e3) {
      const t3 = this.tree_getChunksNode(e3), r3 = this.tree_getLength(e3);
      return ts.tree_serializedSizeArrayComposite(this.elementType, r3, this.chunkDepth, t3);
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n2 = this.tree_getChunksNode(r3), i2 = this.tree_getLength(r3);
      return ts.tree_serializeToBytesArrayComposite(this.elementType, i2, this.chunkDepth, n2, e3, t3);
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      return ts.tree_deserializeFromBytesArrayComposite(this.elementType, this.chunkDepth, e3, t3, r3, this);
    }
    tree_getLength(e3) {
      return Bo.getLengthFromRootNode(e3);
    }
    tree_setLength(e3, t3) {
      e3.rootNode = Bo.addLengthNode(e3.rootNode.left, t3);
    }
    tree_getChunksNode(e3) {
      return e3.left;
    }
    tree_setChunksNode(e3, t3, r3) {
      return Bo.setChunksNode(e3, t3, r3);
    }
    hashTreeRoot(e3) {
      return Eo.mixInLength(super.hashTreeRoot(e3), e3.length);
    }
    getRoots(e3) {
      return ts.value_getRootsArrayComposite(this.elementType, e3.length, e3);
    }
  }
  t2.ListCompositeType = r2;
});
var as = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.NoneType = void 0, t2.NoneType = class extends Po.BasicType {
    constructor() {
      super(...arguments), this.typeName = "none", this.byteLength = 0, this.itemsPerChunk = 32, this.fixedSize = 0, this.minSize = 0, this.maxSize = 0;
    }
    defaultValue() {
      return null;
    }
    value_serializeToBytes(e3, t3, r2) {
      return t3;
    }
    value_deserializeFromBytes(e3, t3) {
      return null;
    }
    tree_serializeToBytes(e3, t3, r2) {
      return t3;
    }
    tree_deserializeFromBytes(e3, t3, r2) {
      return bo.zeroNode(0);
    }
    tree_getFromNode(e3) {
      return null;
    }
    tree_setToNode(e3, t3) {
    }
    tree_getFromPackedNode(e3, t3) {
      return null;
    }
    tree_setToPackedNode(e3, t3, r2) {
    }
    fromJson(e3) {
      if (null !== e3)
        throw Error("JSON invalid type none must be null");
      return null;
    }
    toJson(e3) {
      return null;
    }
  };
});
var us = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.UintBigintType = t2.UintNumberType = t2.uintBigintByteLens = t2.uintNumberByteLens = void 0;
  const r2 = BigInt(Number.MAX_SAFE_INTEGER), n2 = BigInt(2) ** BigInt(64), i2 = BigInt(2) ** BigInt(128), o2 = BigInt(2) ** BigInt(192), s2 = 2 ** 32, a2 = 4294967295;
  t2.uintNumberByteLens = [1, 2, 4, 8], t2.uintBigintByteLens = [1, 2, 4, 8, 16, 32];
  class u2 extends Po.BasicType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.byteLength = e3, e3 > 8)
        throw Error("UintNumber byteLength limit is 8");
      if (Math.log2(e3) % 1 != 0)
        throw Error("byteLength must be a power of 2");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : "uint" + 8 * e3, (t3 == null ? void 0 : t3.clipInfinity) && (this.typeName += "Inf"), (t3 == null ? void 0 : t3.setBitwiseOR) && (this.typeName += "OR"), this.itemsPerChunk = 32 / this.byteLength, this.fixedSize = e3, this.minSize = e3, this.maxSize = e3, this.maxDecimalStr = (BigInt(2) ** BigInt(8 * this.byteLength) - BigInt(1)).toString(10), this.clipInfinity = true === (t3 == null ? void 0 : t3.clipInfinity), this.setBitwiseOR = true === (t3 == null ? void 0 : t3.setBitwiseOR);
    }
    static named(e3, t3) {
      return new (xo.namedClass(u2, t3.typeName))(e3, t3);
    }
    defaultValue() {
      return 0;
    }
    value_serializeToBytes({ dataView: e3 }, t3, r3) {
      switch (this.byteLength) {
        case 1:
          e3.setInt8(t3, r3);
          break;
        case 2:
          e3.setUint16(t3, r3, true);
          break;
        case 4:
          e3.setUint32(t3, r3, true);
          break;
        case 8:
          Infinity === r3 ? (e3.setUint32(t3, 4294967295), e3.setUint32(t3 + 4, 4294967295)) : (e3.setUint32(t3, 4294967295 & r3, true), e3.setUint32(t3 + 4, r3 / s2 & 4294967295, true));
      }
      return t3 + this.byteLength;
    }
    value_deserializeFromBytes({ dataView: e3 }, t3, r3) {
      switch (this.assertValidSize(r3 - t3), this.byteLength) {
        case 1:
          return e3.getUint8(t3);
        case 2:
          return e3.getUint16(t3, true);
        case 4:
          return e3.getUint32(t3, true);
        case 8: {
          const r4 = e3.getUint32(t3, true), n3 = e3.getUint32(t3 + 4, true);
          return n3 === a2 && r4 === a2 && this.clipInfinity ? Infinity : n3 * s2 + r4;
        }
      }
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n3 = r3.getUint(this.byteLength, 0, this.clipInfinity);
      return this.value_serializeToBytes(e3, t3, n3), t3 + this.byteLength;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      this.assertValidSize(r3 - t3);
      const n3 = this.value_deserializeFromBytes(e3, t3, r3), i3 = bo.LeafNode.fromZero();
      return i3.setUint(this.byteLength, 0, n3, this.clipInfinity), i3;
    }
    tree_getFromNode(e3) {
      return e3.getUint(this.byteLength, 0, this.clipInfinity);
    }
    tree_setToNode(e3, t3) {
      this.tree_setToPackedNode(e3, 0, t3);
    }
    tree_getFromPackedNode(e3, t3) {
      return e3.getUint(this.byteLength, this.byteLength * (t3 % this.itemsPerChunk), this.clipInfinity);
    }
    tree_setToPackedNode(e3, t3, r3) {
      const n3 = this.byteLength * (t3 % this.itemsPerChunk);
      this.setBitwiseOR ? e3.bitwiseOrUint(this.byteLength, n3, r3) : e3.setUint(this.byteLength, n3, r3, this.clipInfinity);
    }
    fromJson(e3) {
      if ("number" == typeof e3)
        return e3;
      if ("string" == typeof e3) {
        if (this.clipInfinity && e3 === this.maxDecimalStr)
          return Infinity;
        {
          const t3 = parseInt(e3, 10);
          if (isNaN(t3))
            throw Error("JSON invalid number isNaN");
          if (t3 > Number.MAX_SAFE_INTEGER)
            throw Error("JSON invalid number > MAX_SAFE_INTEGER");
          return t3;
        }
      }
      if ("bigint" == typeof e3) {
        if (e3 > r2)
          throw Error("JSON invalid number > MAX_SAFE_INTEGER_BN");
        return Number(e3);
      }
      throw Error(`JSON invalid type ${typeof e3} expected number`);
    }
    toJson(e3) {
      return Infinity === e3 ? this.maxDecimalStr : e3.toString(10);
    }
  }
  t2.UintNumberType = u2;
  class h2 extends Po.BasicType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.byteLength = e3, e3 > 32)
        throw Error("UintBigint byteLength limit is 32");
      if (Math.log2(e3) % 1 != 0)
        throw Error("byteLength must be a power of 2");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : "uintBigint" + 8 * e3, this.byteLength = e3, this.itemsPerChunk = 32 / this.byteLength, this.fixedSize = e3, this.minSize = e3, this.maxSize = e3;
    }
    static named(e3, t3) {
      return new (xo.namedClass(h2, t3.typeName))(e3, t3);
    }
    defaultValue() {
      return BigInt(0);
    }
    value_serializeToBytes({ dataView: e3 }, t3, r3) {
      switch (this.byteLength) {
        case 1:
          e3.setInt8(t3, Number(r3));
          break;
        case 2:
          e3.setUint16(t3, Number(r3), true);
          break;
        case 4:
          e3.setUint32(t3, Number(r3), true);
          break;
        case 8:
          e3.setBigUint64(t3, r3, true);
          break;
        default:
          for (let i3 = 0; i3 < this.byteLength; i3 += 8) {
            i3 > 0 && (r3 /= n2);
            const o3 = BigInt.asUintN(64, r3);
            e3.setBigUint64(t3 + i3, o3, true);
          }
      }
      return t3 + this.byteLength;
    }
    value_deserializeFromBytes({ dataView: e3 }, t3, r3) {
      const s3 = r3 - t3;
      if (s3 !== this.byteLength)
        throw Error(`Invalid size ${s3} expected ${this.byteLength}`);
      switch (this.byteLength) {
        case 1:
          return BigInt(e3.getUint8(t3));
        case 2:
          return BigInt(e3.getUint16(t3, true));
        case 4:
          return BigInt(e3.getUint32(t3, true));
        case 8:
          return e3.getBigUint64(t3, true);
        case 16: {
          const r4 = e3.getBigUint64(t3, true);
          return e3.getBigUint64(t3 + 8, true) * n2 + r4;
        }
        case 32: {
          const r4 = e3.getBigUint64(t3, true), s4 = e3.getBigUint64(t3 + 8, true), a3 = e3.getBigUint64(t3 + 16, true);
          return e3.getBigUint64(t3 + 24, true) * o2 + a3 * i2 + s4 * n2 + r4;
        }
      }
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n3 = r3.getUintBigint(this.byteLength, 0);
      return this.value_serializeToBytes(e3, t3, n3), t3 + this.byteLength;
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      const n3 = r3 - t3;
      if (n3 !== this.byteLength)
        throw Error(`Invalid size ${n3} expected ${this.byteLength}`);
      const i3 = this.value_deserializeFromBytes(e3, t3, r3), o3 = bo.LeafNode.fromZero();
      return o3.setUintBigint(this.byteLength, 0, i3), o3;
    }
    tree_getFromNode(e3) {
      return e3.getUintBigint(this.byteLength, 0);
    }
    tree_setToNode(e3, t3) {
      this.tree_setToPackedNode(e3, 0, t3);
    }
    tree_getFromPackedNode(e3, t3) {
      return e3.getUintBigint(this.byteLength, this.byteLength * (t3 % this.itemsPerChunk));
    }
    tree_setToPackedNode(e3, t3, r3) {
      e3.setUintBigint(this.byteLength, this.byteLength * (t3 % this.itemsPerChunk), r3);
    }
    fromJson(e3) {
      if ("bigint" == typeof e3)
        return e3;
      if ("string" == typeof e3 || "number" == typeof e3)
        return BigInt(e3);
      throw Error(`JSON invalid type ${typeof e3} expected bigint`);
    }
    toJson(e3) {
      return e3.toString(10);
    }
  }
  t2.UintBigintType = h2;
});
var hs = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.UnionType = void 0;
  const r2 = BigInt(2), n2 = BigInt(3);
  class i2 extends No.CompositeType {
    constructor(e3, t3) {
      var _a3;
      if (super(), this.types = e3, this.depth = 1, this.maxChunkCount = 1, this.fixedSize = null, this.isList = true, this.isViewMutable = true, e3.length >= 128)
        throw Error("Must have less than 128 types");
      if (0 === e3.length)
        throw Error("Must have at least 1 type option");
      if (e3[0] instanceof as.NoneType && e3.length < 2)
        throw Error("Must have at least 2 type options if the first is None");
      for (let t4 = 1; t4 < e3.length; t4++)
        if (e3[t4] instanceof as.NoneType)
          throw Error("None may only be the first option");
      this.typeName = (_a3 = t3 == null ? void 0 : t3.typeName) != null ? _a3 : `Union[${e3.map((e4) => e4.typeName).join(",")}]`;
      const r3 = [], n3 = [];
      for (const t4 of e3)
        r3.push(t4.minSize), n3.push(t4.maxSize);
      this.minSize = 1 + Math.min(...r3), this.maxSize = 1 + Math.max(...n3), this.maxSelector = this.types.length - 1;
    }
    static named(e3, t3) {
      return new (xo.namedClass(i2, t3.typeName))(e3, t3);
    }
    defaultValue() {
      return { selector: 0, value: this.types[0].defaultValue() };
    }
    getView(e3) {
      return this.tree_toValue(e3.rootNode);
    }
    getViewDU(e3) {
      return this.tree_toValue(e3);
    }
    cacheOfViewDU() {
    }
    commitView(e3) {
      return this.value_toTree(e3);
    }
    commitViewDU(e3) {
      return this.value_toTree(e3);
    }
    value_serializedSize(e3) {
      return 1 + this.types[e3.selector].value_serializedSize(e3.value);
    }
    value_serializeToBytes(e3, t3, r3) {
      return e3.uint8Array[t3] = r3.selector, this.types[r3.selector].value_serializeToBytes(e3, t3 + 1, r3.value);
    }
    value_deserializeFromBytes(e3, t3, r3) {
      const n3 = e3.uint8Array[t3];
      if (n3 > this.maxSelector)
        throw Error(`Invalid selector ${n3}`);
      return { selector: n3, value: this.types[n3].value_deserializeFromBytes(e3, t3 + 1, r3) };
    }
    tree_serializedSize(e3) {
      const t3 = Bo.getLengthFromRootNode(e3);
      return 1 + this.types[t3].value_serializedSize(e3.left);
    }
    tree_serializeToBytes(e3, t3, r3) {
      const n3 = Bo.getLengthFromRootNode(r3), i3 = r3.left;
      return e3.uint8Array[t3] = n3, this.types[n3].tree_serializeToBytes(e3, t3 + 1, i3);
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      const n3 = e3.uint8Array[t3];
      if (n3 > this.maxSelector)
        throw Error(`Invalid selector ${n3}`);
      const i3 = this.types[n3].tree_deserializeFromBytes(e3, t3 + 1, r3);
      return Bo.addLengthNode(i3, n3);
    }
    hashTreeRoot(e3) {
      return Eo.mixInLength(super.hashTreeRoot(e3), e3.selector);
    }
    getRoots(e3) {
      return [this.types[e3.selector].hashTreeRoot(e3.value)];
    }
    getPropertyGindex(e3) {
      switch (e3) {
        case "value":
          return r2;
        case "selector":
          return n2;
        default:
          throw new Error(`Invalid Union type property ${e3}`);
      }
    }
    getPropertyType() {
      throw new Error("Not applicable for Union type");
    }
    getIndexProperty(e3) {
      if (0 === e3)
        return "value";
      if (1 === e3)
        return "selector";
      throw Error("Union index of out bounds");
    }
    tree_getLeafGindices(e3, t3) {
      if (!t3)
        throw Error("rootNode required");
      const i3 = [bo.concatGindices([e3, n2])], o2 = Bo.getLengthFromRootNode(t3), s2 = this.types[o2], a2 = bo.concatGindices([e3, r2]);
      return No.isCompositeType(s2) ? i3.push(...s2.tree_getLeafGindices(a2, bo.getNode(t3, r2))) : i3.push(a2), i3;
    }
    fromJson(e3) {
      if ("object" != typeof e3)
        throw new Error("JSON must be of type object");
      const t3 = e3;
      if ("number" != typeof t3.selector)
        throw new Error("Invalid JSON Union selector must be number");
      const r3 = this.types[t3.selector];
      if (!r3)
        throw new Error("Invalid JSON Union selector out of range");
      return { selector: t3.selector, value: r3.toJson(t3.value) };
    }
    toJson(e3) {
      return { selector: e3.selector, value: this.types[e3.selector].toJson(e3.value) };
    }
    clone(e3) {
      return { selector: e3.selector, value: this.types[e3.selector].clone(e3.value) };
    }
    equals(e3, t3) {
      return e3.selector === t3.selector && this.types[e3.selector].equals(e3.value, t3.value);
    }
  }
  t2.UnionType = i2;
});
var fs = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.VectorBasicType = void 0;
  class r2 extends Qo.ArrayType {
    constructor(e3, t3, r3) {
      var _a3;
      if (super(e3), this.elementType = e3, this.length = t3, this.isList = false, this.isViewMutable = true, !e3.isBasic)
        throw Error("elementType must be basic");
      if (0 === t3)
        throw Error("Vector length must be > 0");
      this.typeName = (_a3 = r3 == null ? void 0 : r3.typeName) != null ? _a3 : `Vector[${e3.typeName}, ${t3}]`, this.itemsPerChunk = 32 / e3.byteLength, this.maxChunkCount = Math.ceil(t3 * e3.byteLength / 32), this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = this.chunkDepth, this.fixedSize = t3 * e3.byteLength, this.minSize = this.fixedSize, this.maxSize = this.fixedSize, this.defaultLen = t3;
    }
    static named(e3, t3, n2) {
      return new (xo.namedClass(r2, n2.typeName))(e3, t3, n2);
    }
    getView(e3) {
      return new Wo.ArrayBasicTreeView(this, e3);
    }
    getViewDU(e3, t3) {
      return new Yo.ArrayBasicTreeViewDU(this, e3, t3);
    }
    commitView(e3) {
      return e3.node;
    }
    commitViewDU(e3) {
      return e3.commit(), e3.node;
    }
    cacheOfViewDU(e3) {
      return e3.cache;
    }
    value_serializedSize() {
      return this.fixedSize;
    }
    value_serializeToBytes(e3, t3, r3) {
      return Bo.value_serializeToBytesArrayBasic(this.elementType, this.length, e3, t3, r3);
    }
    value_deserializeFromBytes(e3, t3, r3) {
      return Bo.value_deserializeFromBytesArrayBasic(this.elementType, e3, t3, r3, this);
    }
    tree_serializedSize() {
      return this.fixedSize;
    }
    tree_serializeToBytes(e3, t3, r3) {
      return Bo.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, e3, t3, r3);
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      return Bo.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, e3, t3, r3, this);
    }
    tree_getLength() {
      return this.length;
    }
    tree_setLength() {
    }
    tree_getChunksNode(e3) {
      return e3;
    }
    tree_setChunksNode(e3, t3) {
      return t3;
    }
    getRoots(e3) {
      const t3 = new Uint8Array(this.fixedSize), r3 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
      return Bo.value_serializeToBytesArrayBasic(this.elementType, this.length, { uint8Array: t3, dataView: r3 }, 0, e3), Eo.splitIntoRootChunks(t3);
    }
  }
  t2.VectorBasicType = r2;
});
var cs = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.VectorCompositeType = void 0;
  class r2 extends Qo.ArrayType {
    constructor(e3, t3, r3) {
      var _a3;
      if (super(e3), this.elementType = e3, this.length = t3, this.itemsPerChunk = 1, this.isList = false, this.isViewMutable = true, e3.isBasic)
        throw Error("elementType must not be basic");
      if (0 === t3)
        throw Error("Vector length must be > 0");
      this.typeName = (_a3 = r3 == null ? void 0 : r3.typeName) != null ? _a3 : `Vector[${e3.typeName}, ${t3}]`, this.maxChunkCount = t3, this.chunkDepth = Eo.maxChunksToDepth(this.maxChunkCount), this.depth = this.chunkDepth, this.fixedSize = null === e3.fixedSize ? null : t3 * e3.fixedSize, this.minSize = ts.minSizeArrayComposite(e3, t3), this.maxSize = ts.maxSizeArrayComposite(e3, t3), this.defaultLen = t3;
    }
    static named(e3, t3, n2) {
      return new (xo.namedClass(r2, n2.typeName))(e3, t3, n2);
    }
    getView(e3) {
      return new rs.ArrayCompositeTreeView(this, e3);
    }
    getViewDU(e3, t3) {
      return new is.ArrayCompositeTreeViewDU(this, e3, t3);
    }
    commitView(e3) {
      return e3.node;
    }
    commitViewDU(e3) {
      return e3.commit(), e3.node;
    }
    cacheOfViewDU(e3) {
      return e3.cache;
    }
    value_serializedSize(e3) {
      return ts.value_serializedSizeArrayComposite(this.elementType, this.length, e3);
    }
    value_serializeToBytes(e3, t3, r3) {
      return ts.value_serializeToBytesArrayComposite(this.elementType, this.length, e3, t3, r3);
    }
    value_deserializeFromBytes(e3, t3, r3) {
      return ts.value_deserializeFromBytesArrayComposite(this.elementType, e3, t3, r3, this);
    }
    tree_serializedSize(e3) {
      return ts.tree_serializedSizeArrayComposite(this.elementType, this.length, this.depth, e3);
    }
    tree_serializeToBytes(e3, t3, r3) {
      return ts.tree_serializeToBytesArrayComposite(this.elementType, this.length, this.depth, r3, e3, t3);
    }
    tree_deserializeFromBytes(e3, t3, r3) {
      return ts.tree_deserializeFromBytesArrayComposite(this.elementType, this.depth, e3, t3, r3, this);
    }
    tree_getLength() {
      return this.length;
    }
    tree_setLength() {
    }
    tree_getChunksNode(e3) {
      return e3;
    }
    tree_setChunksNode(e3, t3) {
      return t3;
    }
    getRoots(e3) {
      return ts.value_getRootsArrayComposite(this.elementType, this.length, e3);
    }
  }
  t2.VectorCompositeType = r2;
});
var ls = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.hash64 = t2.byteArrayEquals = t2.toHexString = t2.fromHexString = t2.getUint8ByteToBitBooleanArray = t2.BitArray = t2.TreeViewDU = t2.TreeView = t2.isCompositeType = t2.CompositeType = t2.isBasicType = t2.BasicType = t2.Type = t2.ByteArrayType = t2.BitArrayType = t2.ArrayType = t2.VectorCompositeType = t2.VectorBasicType = t2.UnionType = t2.UintNumberType = t2.UintBigintType = t2.NoneType = t2.ListCompositeType = t2.ListBasicType = t2.ContainerNodeStructType = t2.ContainerType = t2.ByteVectorType = t2.ByteListType = t2.BooleanType = t2.BitVectorType = t2.BitListType = void 0, Object.defineProperty(t2, "BitListType", { enumerable: true, get: function() {
    return Mo.BitListType;
  } }), Object.defineProperty(t2, "BitVectorType", { enumerable: true, get: function() {
    return Co.BitVectorType;
  } }), Object.defineProperty(t2, "BooleanType", { enumerable: true, get: function() {
    return Ro.BooleanType;
  } }), Object.defineProperty(t2, "ByteListType", { enumerable: true, get: function() {
    return zo.ByteListType;
  } }), Object.defineProperty(t2, "ByteVectorType", { enumerable: true, get: function() {
    return $o.ByteVectorType;
  } }), Object.defineProperty(t2, "ContainerType", { enumerable: true, get: function() {
    return Ho.ContainerType;
  } }), Object.defineProperty(t2, "ContainerNodeStructType", { enumerable: true, get: function() {
    return Jo.ContainerNodeStructType;
  } }), Object.defineProperty(t2, "ListBasicType", { enumerable: true, get: function() {
    return es.ListBasicType;
  } }), Object.defineProperty(t2, "ListCompositeType", { enumerable: true, get: function() {
    return ss.ListCompositeType;
  } }), Object.defineProperty(t2, "NoneType", { enumerable: true, get: function() {
    return as.NoneType;
  } }), Object.defineProperty(t2, "UintBigintType", { enumerable: true, get: function() {
    return us.UintBigintType;
  } }), Object.defineProperty(t2, "UintNumberType", { enumerable: true, get: function() {
    return us.UintNumberType;
  } }), Object.defineProperty(t2, "UnionType", { enumerable: true, get: function() {
    return hs.UnionType;
  } }), Object.defineProperty(t2, "VectorBasicType", { enumerable: true, get: function() {
    return fs.VectorBasicType;
  } }), Object.defineProperty(t2, "VectorCompositeType", { enumerable: true, get: function() {
    return cs.VectorCompositeType;
  } }), Object.defineProperty(t2, "ArrayType", { enumerable: true, get: function() {
    return Qo.ArrayType;
  } }), Object.defineProperty(t2, "BitArrayType", { enumerable: true, get: function() {
    return ko.BitArrayType;
  } }), Object.defineProperty(t2, "ByteArrayType", { enumerable: true, get: function() {
    return Do.ByteArrayType;
  } }), Object.defineProperty(t2, "Type", { enumerable: true, get: function() {
    return So.Type;
  } }), Object.defineProperty(t2, "BasicType", { enumerable: true, get: function() {
    return Po.BasicType;
  } }), Object.defineProperty(t2, "isBasicType", { enumerable: true, get: function() {
    return Po.isBasicType;
  } }), Object.defineProperty(t2, "CompositeType", { enumerable: true, get: function() {
    return No.CompositeType;
  } }), Object.defineProperty(t2, "isCompositeType", { enumerable: true, get: function() {
    return No.isCompositeType;
  } }), Object.defineProperty(t2, "TreeView", { enumerable: true, get: function() {
    return Io.TreeView;
  } }), Object.defineProperty(t2, "TreeViewDU", { enumerable: true, get: function() {
    return Uo.TreeViewDU;
  } }), Object.defineProperty(t2, "BitArray", { enumerable: true, get: function() {
    return Ao.BitArray;
  } }), Object.defineProperty(t2, "getUint8ByteToBitBooleanArray", { enumerable: true, get: function() {
    return Ao.getUint8ByteToBitBooleanArray;
  } }), Object.defineProperty(t2, "fromHexString", { enumerable: true, get: function() {
    return _o.fromHexString;
  } }), Object.defineProperty(t2, "toHexString", { enumerable: true, get: function() {
    return _o.toHexString;
  } }), Object.defineProperty(t2, "byteArrayEquals", { enumerable: true, get: function() {
    return _o.byteArrayEquals;
  } }), Object.defineProperty(t2, "hash64", { enumerable: true, get: function() {
    return Eo.hash64;
  } });
});
var ds = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Withdrawals = t2.Withdrawal = t2.Bytes20 = t2.UintBigInt64 = t2.UintNum64 = void 0, t2.UintNum64 = new ls.UintNumberType(8), t2.UintBigInt64 = new ls.UintBigintType(8), t2.Bytes20 = new ls.ByteVectorType(20), t2.Withdrawal = new ls.ContainerType({ index: t2.UintBigInt64, validatorIndex: t2.UintBigInt64, address: t2.Bytes20, amount: t2.UintBigInt64 }, { typeName: "Withdrawal", jsonCase: "eth2" }), t2.Withdrawals = new ls.ListCompositeType(t2.Withdrawal, Di.MAX_WITHDRAWALS_PER_PAYLOAD);
});
var ps = "object" == typeof Reflect ? Reflect : null;
var ys = ps && "function" == typeof ps.apply ? ps.apply : function(e2, t2, r2) {
  return Function.prototype.apply.call(e2, t2, r2);
};
Li = ps && "function" == typeof ps.ownKeys ? ps.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
  return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
} : function(e2) {
  return Object.getOwnPropertyNames(e2);
};
var gs = Number.isNaN || function(e2) {
  return e2 != e2;
};
function ms() {
  ms.init.call(this);
}
var ws = ms;
ms.EventEmitter = ms, ms.prototype._events = void 0, ms.prototype._eventsCount = 0, ms.prototype._maxListeners = void 0;
var bs = 10;
function vs(e2) {
  if ("function" != typeof e2)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
}
function Es(e2) {
  return void 0 === e2._maxListeners ? ms.defaultMaxListeners : e2._maxListeners;
}
function xs(e2, t2, r2, n2) {
  var i2, o2, s2;
  if (vs(r2), void 0 === (o2 = e2._events) ? (o2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== o2.newListener && (e2.emit("newListener", t2, r2.listener ? r2.listener : r2), o2 = e2._events), s2 = o2[t2]), void 0 === s2)
    s2 = o2[t2] = r2, ++e2._eventsCount;
  else if ("function" == typeof s2 ? s2 = o2[t2] = n2 ? [r2, s2] : [s2, r2] : n2 ? s2.unshift(r2) : s2.push(r2), (i2 = Es(e2)) > 0 && s2.length > i2 && !s2.warned) {
    s2.warned = true;
    var a2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a2.name = "MaxListenersExceededWarning", a2.emitter = e2, a2.type = t2, a2.count = s2.length, console && console.warn && console.warn(a2);
  }
  return e2;
}
function Bs() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function As(e2, t2, r2) {
  var n2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: r2 }, i2 = Bs.bind(n2);
  return i2.listener = r2, n2.wrapFn = i2, i2;
}
function _s(e2, t2, r2) {
  var n2 = e2._events;
  if (void 0 === n2)
    return [];
  var i2 = n2[t2];
  return void 0 === i2 ? [] : "function" == typeof i2 ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(e3) {
    for (var t3 = new Array(e3.length), r3 = 0; r3 < t3.length; ++r3)
      t3[r3] = e3[r3].listener || e3[r3];
    return t3;
  }(i2) : Ss(i2, i2.length);
}
function Ts(e2) {
  var t2 = this._events;
  if (void 0 !== t2) {
    var r2 = t2[e2];
    if ("function" == typeof r2)
      return 1;
    if (void 0 !== r2)
      return r2.length;
  }
  return 0;
}
function Ss(e2, t2) {
  for (var r2 = new Array(t2), n2 = 0; n2 < t2; ++n2)
    r2[n2] = e2[n2];
  return r2;
}
function Ns(e2, t2, r2, n2) {
  if ("function" == typeof e2.on)
    n2.once ? e2.once(t2, r2) : e2.on(t2, r2);
  else {
    if ("function" != typeof e2.addEventListener)
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
    e2.addEventListener(t2, function i2(o2) {
      n2.once && e2.removeEventListener(t2, i2), r2(o2);
    });
  }
}
Object.defineProperty(ms, "defaultMaxListeners", { enumerable: true, get: function() {
  return bs;
}, set: function(e2) {
  if ("number" != typeof e2 || e2 < 0 || gs(e2))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
  bs = e2;
} }), ms.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, ms.prototype.setMaxListeners = function(e2) {
  if ("number" != typeof e2 || e2 < 0 || gs(e2))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
  return this._maxListeners = e2, this;
}, ms.prototype.getMaxListeners = function() {
  return Es(this);
}, ms.prototype.emit = function(e2) {
  for (var t2 = [], r2 = 1; r2 < arguments.length; r2++)
    t2.push(arguments[r2]);
  var n2 = "error" === e2, i2 = this._events;
  if (void 0 !== i2)
    n2 = n2 && void 0 === i2.error;
  else if (!n2)
    return false;
  if (n2) {
    var o2;
    if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error)
      throw o2;
    var s2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
    throw s2.context = o2, s2;
  }
  var a2 = i2[e2];
  if (void 0 === a2)
    return false;
  if ("function" == typeof a2)
    ys(a2, this, t2);
  else {
    var u2 = a2.length, h2 = Ss(a2, u2);
    for (r2 = 0; r2 < u2; ++r2)
      ys(h2[r2], this, t2);
  }
  return true;
}, ms.prototype.on = ms.prototype.addListener = function(e2, t2) {
  return xs(this, e2, t2, false);
}, ms.prototype.prependListener = function(e2, t2) {
  return xs(this, e2, t2, true);
}, ms.prototype.once = function(e2, t2) {
  return vs(t2), this.on(e2, As(this, e2, t2)), this;
}, ms.prototype.prependOnceListener = function(e2, t2) {
  return vs(t2), this.prependListener(e2, As(this, e2, t2)), this;
}, ms.prototype.removeListener = function(e2, t2) {
  var r2, n2, i2, o2, s2;
  if (vs(t2), void 0 === (n2 = this._events))
    return this;
  if (void 0 === (r2 = n2[e2]))
    return this;
  if (r2 === t2 || r2.listener === t2)
    0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[e2], n2.removeListener && this.emit("removeListener", e2, r2.listener || t2));
  else if ("function" != typeof r2) {
    for (i2 = -1, o2 = r2.length - 1; o2 >= 0; o2--)
      if (r2[o2] === t2 || r2[o2].listener === t2) {
        s2 = r2[o2].listener, i2 = o2;
        break;
      }
    if (i2 < 0)
      return this;
    0 === i2 ? r2.shift() : function(e3, t3) {
      for (; t3 + 1 < e3.length; t3++)
        e3[t3] = e3[t3 + 1];
      e3.pop();
    }(r2, i2), 1 === r2.length && (n2[e2] = r2[0]), void 0 !== n2.removeListener && this.emit("removeListener", e2, s2 || t2);
  }
  return this;
}, ms.prototype.off = ms.prototype.removeListener, ms.prototype.removeAllListeners = function(e2) {
  var t2, r2, n2;
  if (void 0 === (r2 = this._events))
    return this;
  if (void 0 === r2.removeListener)
    return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r2[e2]), this;
  if (0 === arguments.length) {
    var i2, o2 = Object.keys(r2);
    for (n2 = 0; n2 < o2.length; ++n2)
      "removeListener" !== (i2 = o2[n2]) && this.removeAllListeners(i2);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t2 = r2[e2]))
    this.removeListener(e2, t2);
  else if (void 0 !== t2)
    for (n2 = t2.length - 1; n2 >= 0; n2--)
      this.removeListener(e2, t2[n2]);
  return this;
}, ms.prototype.listeners = function(e2) {
  return _s(this, e2, true);
}, ms.prototype.rawListeners = function(e2) {
  return _s(this, e2, false);
}, ms.listenerCount = function(e2, t2) {
  return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : Ts.call(e2, t2);
}, ms.prototype.listenerCount = Ts, ms.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Li(this._events) : [];
}, ws.once = function(e2, t2) {
  return new Promise(function(r2, n2) {
    function i2(r3) {
      e2.removeListener(t2, o2), n2(r3);
    }
    function o2() {
      "function" == typeof e2.removeListener && e2.removeListener("error", i2), r2([].slice.call(arguments));
    }
    Ns(e2, t2, o2, { once: true }), "error" !== t2 && function(e3, t3, r3) {
      "function" == typeof e3.on && Ns(e3, "error", t3, { once: true });
    }(e2, i2);
  });
};
var Is;
var Os;
var Us = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.AsyncEventEmitter = void 0, t2.AsyncEventEmitter = class extends ws.EventEmitter {
    emit(e3, ...t3) {
      var _a3;
      let [r2, n2] = t3;
      const i2 = this;
      let o2 = (_a3 = i2._events[e3]) != null ? _a3 : [];
      return void 0 === n2 && "function" == typeof r2 && (n2 = r2, r2 = void 0), "newListener" !== e3 && "removeListener" !== e3 || (r2 = { event: r2, fn: n2 }, n2 = void 0), o2 = Array.isArray(o2) ? o2 : [o2], async function(e4, t4, r3) {
        let n3;
        for await (const i3 of t4)
          try {
            i3.length < 2 ? i3.call(e4, r3) : await new Promise((t5, n4) => {
              i3.call(e4, r3, (e5) => {
                e5 ? n4(e5) : t5();
              });
            });
          } catch (e5) {
            n3 = e5;
          }
        if (n3)
          throw n3;
      }(i2, o2.slice(), r2).then(n2).catch(n2), i2.listenerCount(e3) > 0;
    }
    once(e3, t3) {
      const r2 = this;
      let n2;
      if ("function" != typeof t3)
        throw new TypeError("listener must be a function");
      return n2 = t3.length >= 2 ? function(i2, o2) {
        r2.removeListener(e3, n2), t3(i2, o2);
      } : function(i2) {
        r2.removeListener(e3, n2), t3(i2, n2);
      }, r2.on(e3, n2), r2;
    }
    first(e3, t3) {
      var _a3;
      let r2 = (_a3 = this._events[e3]) != null ? _a3 : [];
      if ("function" != typeof t3)
        throw new TypeError("listener must be a function");
      return Array.isArray(r2) || (this._events[e3] = r2 = [r2]), r2.unshift(t3), this;
    }
    before(e3, t3, r2) {
      return this.beforeOrAfter(e3, t3, r2);
    }
    after(e3, t3, r2) {
      return this.beforeOrAfter(e3, t3, r2, "after");
    }
    beforeOrAfter(e3, t3, r2, n2) {
      var _a3;
      let i2, o2, s2 = (_a3 = this._events[e3]) != null ? _a3 : [];
      const a2 = "after" === n2 ? 1 : 0;
      if ("function" != typeof r2)
        throw new TypeError("listener must be a function");
      if ("function" != typeof t3)
        throw new TypeError("target must be a function");
      for (Array.isArray(s2) || (this._events[e3] = s2 = [s2]), o2 = s2.length, i2 = s2.length; i2--; )
        if (s2[i2] === t3) {
          o2 = i2 + a2;
          break;
        }
      return s2.splice(o2, 0, r2), this;
    }
    on(e3, t3) {
      return super.on(e3, t3);
    }
    addListener(e3, t3) {
      return super.addListener(e3, t3);
    }
    prependListener(e3, t3) {
      return super.prependListener(e3, t3);
    }
    prependOnceListener(e3, t3) {
      return super.prependOnceListener(e3, t3);
    }
    removeAllListeners(e3) {
      return super.removeAllListeners(e3);
    }
    removeListener(e3, t3) {
      return super.removeListener(e3, t3);
    }
    eventNames() {
      return super.eventNames();
    }
    listeners(e3) {
      return super.listeners(e3);
    }
    listenerCount(e3) {
      return super.listenerCount(e3);
    }
    getMaxListeners() {
      return super.getMaxListeners();
    }
    setMaxListeners(e3) {
      return super.setMaxListeners(e3);
    }
  };
});
var Ls = ye(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Lock = void 0, t2.Lock = class {
    constructor() {
      this.permits = 1, this.promiseResolverQueue = [];
    }
    async acquire() {
      return this.permits > 0 ? (this.permits -= 1, Promise.resolve(true)) : new Promise((e3) => this.promiseResolverQueue.push(e3));
    }
    release() {
      if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
        console.warn("Lock.permits should never be > 0 when there is someone waiting.");
      else if (1 === this.permits && this.promiseResolverQueue.length > 0) {
        this.permits -= 1;
        const e3 = this.promiseResolverQueue.shift();
        e3 && e3(true);
      }
    }
  };
});
var ks = ye(function(e2, t2) {
  var r2 = pe && pe.__createBinding || (Object.create ? function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3);
    var i2 = Object.getOwnPropertyDescriptor(t3, r3);
    i2 && !("get" in i2 ? !t3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, n3, i2);
  } : function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), e3[n3] = t3[r3];
  }), n2 = pe && pe.__exportStar || function(e3, t3) {
    for (var n3 in e3)
      "default" === n3 || Object.prototype.hasOwnProperty.call(t3, n3) || r2(t3, e3, n3);
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.toAscii = t2.stripHexPrefix = t2.padToEven = t2.isHexString = t2.isHexPrefixed = t2.getKeys = t2.getBinarySize = t2.fromUtf8 = t2.fromAscii = t2.arrayContainsArray = t2.ssz = void 0, n2(Di, t2), n2(zi, t2), n2(Wi, t2), n2(Zi, t2), n2(Xi, t2), n2(Qi, t2), n2(qi, t2), t2.ssz = ds, n2(Yi, t2), n2(Us, t2), Object.defineProperty(t2, "arrayContainsArray", { enumerable: true, get: function() {
    return Ki.arrayContainsArray;
  } }), Object.defineProperty(t2, "fromAscii", { enumerable: true, get: function() {
    return Ki.fromAscii;
  } }), Object.defineProperty(t2, "fromUtf8", { enumerable: true, get: function() {
    return Ki.fromUtf8;
  } }), Object.defineProperty(t2, "getBinarySize", { enumerable: true, get: function() {
    return Ki.getBinarySize;
  } }), Object.defineProperty(t2, "getKeys", { enumerable: true, get: function() {
    return Ki.getKeys;
  } }), Object.defineProperty(t2, "isHexPrefixed", { enumerable: true, get: function() {
    return Ki.isHexPrefixed;
  } }), Object.defineProperty(t2, "isHexString", { enumerable: true, get: function() {
    return Ki.isHexString;
  } }), Object.defineProperty(t2, "padToEven", { enumerable: true, get: function() {
    return Ki.padToEven;
  } }), Object.defineProperty(t2, "stripHexPrefix", { enumerable: true, get: function() {
    return Ki.stripHexPrefix;
  } }), Object.defineProperty(t2, "toAscii", { enumerable: true, get: function() {
    return Ki.toAscii;
  } }), n2(Ls, t2);
});
var Ms = function(e2) {
  return "string" != typeof e2 ? e2 : function(e3) {
    if ("string" != typeof e3)
      throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof e3 + ", while checking isHexPrefixed.");
    return "0x" === e3.slice(0, 2);
  }(e2) ? e2.slice(2) : e2;
};
var Cs = function(e2, t2) {
  return !("string" != typeof e2 || !e2.match(/^0x[0-9A-Fa-f]*$/) || t2 && e2.length !== 2 + 2 * t2);
};
var Ps = ye(function(e2, t2) {
  function r2(e3, t3) {
    if ("" !== e3 && !/^[a-f0-9]+$/iu.test(e3))
      throw new Error(`Expected an unprefixed hex string. Received: ${e3}`);
    if (t3 < 0)
      throw new Error(`Expected a non-negative integer target length. Received: ${t3}`);
    return String.prototype.padStart.call(e3, t3, "0");
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.numberToBuffer = t2.normalize = t2.recoverPublicKey = t2.concatSig = t2.legacyToBuffer = t2.isNullish = t2.padWithZeroes = void 0, t2.padWithZeroes = r2, t2.isNullish = function(e3) {
    return null == e3;
  }, t2.legacyToBuffer = function(e3) {
    return "string" != typeof e3 || Cs(e3) ? (0, ks.toBuffer)(e3) : Buffer.from(e3);
  }, t2.concatSig = function(e3, t3, n2) {
    const i2 = (0, ks.fromSigned)(t3), o2 = (0, ks.fromSigned)(n2), s2 = (0, ks.bufferToInt)(e3), a2 = r2((0, ks.toUnsigned)(i2).toString("hex"), 64), u2 = r2((0, ks.toUnsigned)(o2).toString("hex"), 64), h2 = Ms(function(e4) {
      return "0x" + e4.toString(16);
    }(s2));
    return (0, ks.addHexPrefix)(a2.concat(u2, h2));
  }, t2.recoverPublicKey = function(e3, t3) {
    const r3 = (0, ks.fromRpcSig)(t3);
    return (0, ks.ecrecover)(e3, r3.v, r3.r, r3.s);
  }, t2.normalize = function(e3) {
    if (e3) {
      if ("number" == typeof e3) {
        if (e3 < 0)
          return "0x";
        const t3 = (0, ks.toBuffer)(e3);
        e3 = (0, ks.bufferToHex)(t3);
      }
      if ("string" != typeof e3) {
        let t3 = "eth-sig-util.normalize() requires hex string or integer input.";
        throw t3 += ` received ${typeof e3}: ${e3}`, new Error(t3);
      }
      return (0, ks.addHexPrefix)(e3.toLowerCase());
    }
  }, t2.numberToBuffer = function(e3) {
    const t3 = e3.toString(16);
    return Buffer.from((t3.length % 2 ? "0" : "") + t3, "hex");
  };
});
var Rs = ye(function(e2, t2) {
  function r2(e3, t3) {
    const r3 = (0, ks.hashPersonalMessage)((0, Ps.legacyToBuffer)(e3));
    return (0, Ps.recoverPublicKey)(r3, t3);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.extractPublicKey = t2.recoverPersonalSignature = t2.personalSign = void 0, t2.personalSign = function({ privateKey: e3, data: t3 }) {
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing privateKey parameter");
    const r3 = (0, Ps.legacyToBuffer)(t3), n2 = (0, ks.hashPersonalMessage)(r3), i2 = (0, ks.ecsign)(n2, e3);
    return (0, Ps.concatSig)((0, ks.toBuffer)(i2.v), i2.r, i2.s);
  }, t2.recoverPersonalSignature = function({ data: e3, signature: t3 }) {
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing signature parameter");
    const n2 = r2(e3, t3), i2 = (0, ks.publicToAddress)(n2);
    return (0, ks.bufferToHex)(i2);
  }, t2.extractPublicKey = function({ data: e3, signature: t3 }) {
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing signature parameter");
    return `0x${r2(e3, t3).toString("hex")}`;
  };
});
var Ds = ye(function(e2) {
  !function(e3, t2) {
    function r2(e4, t3) {
      if (!e4)
        throw new Error(t3 || "Assertion failed");
    }
    function n2(e4, t3) {
      e4.super_ = t3;
      var r3 = function() {
      };
      r3.prototype = t3.prototype, e4.prototype = new r3(), e4.prototype.constructor = e4;
    }
    function i2(e4, t3, r3) {
      if (i2.isBN(e4))
        return e4;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e4 && ("le" !== t3 && "be" !== t3 || (r3 = t3, t3 = 10), this._init(e4 || 0, t3 || 10, r3 || "be"));
    }
    var o2;
    "object" == typeof e3 ? e3.exports = i2 : t2.BN = i2, i2.BN = i2, i2.wordSize = 26;
    try {
      o2 = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : me.Buffer;
    } catch (e4) {
    }
    function s2(e4, t3) {
      var r3 = e4.charCodeAt(t3);
      return r3 >= 65 && r3 <= 70 ? r3 - 55 : r3 >= 97 && r3 <= 102 ? r3 - 87 : r3 - 48 & 15;
    }
    function a2(e4, t3, r3) {
      var n3 = s2(e4, r3);
      return r3 - 1 >= t3 && (n3 |= s2(e4, r3 - 1) << 4), n3;
    }
    function u2(e4, t3, r3, n3) {
      for (var i3 = 0, o3 = Math.min(e4.length, r3), s3 = t3; s3 < o3; s3++) {
        var a3 = e4.charCodeAt(s3) - 48;
        i3 *= n3, i3 += a3 >= 49 ? a3 - 49 + 10 : a3 >= 17 ? a3 - 17 + 10 : a3;
      }
      return i3;
    }
    i2.isBN = function(e4) {
      return e4 instanceof i2 || null !== e4 && "object" == typeof e4 && e4.constructor.wordSize === i2.wordSize && Array.isArray(e4.words);
    }, i2.max = function(e4, t3) {
      return e4.cmp(t3) > 0 ? e4 : t3;
    }, i2.min = function(e4, t3) {
      return e4.cmp(t3) < 0 ? e4 : t3;
    }, i2.prototype._init = function(e4, t3, n3) {
      if ("number" == typeof e4)
        return this._initNumber(e4, t3, n3);
      if ("object" == typeof e4)
        return this._initArray(e4, t3, n3);
      "hex" === t3 && (t3 = 16), r2(t3 === (0 | t3) && t3 >= 2 && t3 <= 36);
      var i3 = 0;
      "-" === (e4 = e4.toString().replace(/\s+/g, ""))[0] && (i3++, this.negative = 1), i3 < e4.length && (16 === t3 ? this._parseHex(e4, i3, n3) : (this._parseBase(e4, t3, i3), "le" === n3 && this._initArray(this.toArray(), t3, n3)));
    }, i2.prototype._initNumber = function(e4, t3, n3) {
      e4 < 0 && (this.negative = 1, e4 = -e4), e4 < 67108864 ? (this.words = [67108863 & e4], this.length = 1) : e4 < 4503599627370496 ? (this.words = [67108863 & e4, e4 / 67108864 & 67108863], this.length = 2) : (r2(e4 < 9007199254740992), this.words = [67108863 & e4, e4 / 67108864 & 67108863, 1], this.length = 3), "le" === n3 && this._initArray(this.toArray(), t3, n3);
    }, i2.prototype._initArray = function(e4, t3, n3) {
      if (r2("number" == typeof e4.length), e4.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(e4.length / 3), this.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++)
        this.words[i3] = 0;
      var o3, s3, a3 = 0;
      if ("be" === n3)
        for (i3 = e4.length - 1, o3 = 0; i3 >= 0; i3 -= 3)
          this.words[o3] |= (s3 = e4[i3] | e4[i3 - 1] << 8 | e4[i3 - 2] << 16) << a3 & 67108863, this.words[o3 + 1] = s3 >>> 26 - a3 & 67108863, (a3 += 24) >= 26 && (a3 -= 26, o3++);
      else if ("le" === n3)
        for (i3 = 0, o3 = 0; i3 < e4.length; i3 += 3)
          this.words[o3] |= (s3 = e4[i3] | e4[i3 + 1] << 8 | e4[i3 + 2] << 16) << a3 & 67108863, this.words[o3 + 1] = s3 >>> 26 - a3 & 67108863, (a3 += 24) >= 26 && (a3 -= 26, o3++);
      return this.strip();
    }, i2.prototype._parseHex = function(e4, t3, r3) {
      this.length = Math.ceil((e4.length - t3) / 6), this.words = new Array(this.length);
      for (var n3 = 0; n3 < this.length; n3++)
        this.words[n3] = 0;
      var i3, o3 = 0, s3 = 0;
      if ("be" === r3)
        for (n3 = e4.length - 1; n3 >= t3; n3 -= 2)
          i3 = a2(e4, t3, n3) << o3, this.words[s3] |= 67108863 & i3, o3 >= 18 ? (o3 -= 18, this.words[s3 += 1] |= i3 >>> 26) : o3 += 8;
      else
        for (n3 = (e4.length - t3) % 2 == 0 ? t3 + 1 : t3; n3 < e4.length; n3 += 2)
          i3 = a2(e4, t3, n3) << o3, this.words[s3] |= 67108863 & i3, o3 >= 18 ? (o3 -= 18, this.words[s3 += 1] |= i3 >>> 26) : o3 += 8;
      this.strip();
    }, i2.prototype._parseBase = function(e4, t3, r3) {
      this.words = [0], this.length = 1;
      for (var n3 = 0, i3 = 1; i3 <= 67108863; i3 *= t3)
        n3++;
      n3--, i3 = i3 / t3 | 0;
      for (var o3 = e4.length - r3, s3 = o3 % n3, a3 = Math.min(o3, o3 - s3) + r3, h3 = 0, f3 = r3; f3 < a3; f3 += n3)
        h3 = u2(e4, f3, f3 + n3, t3), this.imuln(i3), this.words[0] + h3 < 67108864 ? this.words[0] += h3 : this._iaddn(h3);
      if (0 !== s3) {
        var c3 = 1;
        for (h3 = u2(e4, f3, e4.length, t3), f3 = 0; f3 < s3; f3++)
          c3 *= t3;
        this.imuln(c3), this.words[0] + h3 < 67108864 ? this.words[0] += h3 : this._iaddn(h3);
      }
      this.strip();
    }, i2.prototype.copy = function(e4) {
      e4.words = new Array(this.length);
      for (var t3 = 0; t3 < this.length; t3++)
        e4.words[t3] = this.words[t3];
      e4.length = this.length, e4.negative = this.negative, e4.red = this.red;
    }, i2.prototype.clone = function() {
      var e4 = new i2(null);
      return this.copy(e4), e4;
    }, i2.prototype._expand = function(e4) {
      for (; this.length < e4; )
        this.words[this.length++] = 0;
      return this;
    }, i2.prototype.strip = function() {
      for (; this.length > 1 && 0 === this.words[this.length - 1]; )
        this.length--;
      return this._normSign();
    }, i2.prototype._normSign = function() {
      return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
    }, i2.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var h2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], f2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], c2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    function l2(e4, t3, r3) {
      r3.negative = t3.negative ^ e4.negative;
      var n3 = e4.length + t3.length | 0;
      r3.length = n3, n3 = n3 - 1 | 0;
      var i3 = 0 | e4.words[0], o3 = 0 | t3.words[0], s3 = i3 * o3, a3 = s3 / 67108864 | 0;
      r3.words[0] = 67108863 & s3;
      for (var u3 = 1; u3 < n3; u3++) {
        for (var h3 = a3 >>> 26, f3 = 67108863 & a3, c3 = Math.min(u3, t3.length - 1), l3 = Math.max(0, u3 - e4.length + 1); l3 <= c3; l3++)
          h3 += (s3 = (i3 = 0 | e4.words[u3 - l3 | 0]) * (o3 = 0 | t3.words[l3]) + f3) / 67108864 | 0, f3 = 67108863 & s3;
        r3.words[u3] = 0 | f3, a3 = 0 | h3;
      }
      return 0 !== a3 ? r3.words[u3] = 0 | a3 : r3.length--, r3.strip();
    }
    i2.prototype.toString = function(e4, t3) {
      var n3;
      if (t3 = 0 | t3 || 1, 16 === (e4 = e4 || 10) || "hex" === e4) {
        n3 = "";
        for (var i3 = 0, o3 = 0, s3 = 0; s3 < this.length; s3++) {
          var a3 = this.words[s3], u3 = (16777215 & (a3 << i3 | o3)).toString(16);
          n3 = 0 != (o3 = a3 >>> 24 - i3 & 16777215) || s3 !== this.length - 1 ? h2[6 - u3.length] + u3 + n3 : u3 + n3, (i3 += 2) >= 26 && (i3 -= 26, s3--);
        }
        for (0 !== o3 && (n3 = o3.toString(16) + n3); n3.length % t3 != 0; )
          n3 = "0" + n3;
        return 0 !== this.negative && (n3 = "-" + n3), n3;
      }
      if (e4 === (0 | e4) && e4 >= 2 && e4 <= 36) {
        var l3 = f2[e4], d3 = c2[e4];
        n3 = "";
        var p3 = this.clone();
        for (p3.negative = 0; !p3.isZero(); ) {
          var y3 = p3.modn(d3).toString(e4);
          n3 = (p3 = p3.idivn(d3)).isZero() ? y3 + n3 : h2[l3 - y3.length] + y3 + n3;
        }
        for (this.isZero() && (n3 = "0" + n3); n3.length % t3 != 0; )
          n3 = "0" + n3;
        return 0 !== this.negative && (n3 = "-" + n3), n3;
      }
      r2(false, "Base should be between 2 and 36");
    }, i2.prototype.toNumber = function() {
      var e4 = this.words[0];
      return 2 === this.length ? e4 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e4 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r2(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e4 : e4;
    }, i2.prototype.toJSON = function() {
      return this.toString(16);
    }, i2.prototype.toBuffer = function(e4, t3) {
      return r2(void 0 !== o2), this.toArrayLike(o2, e4, t3);
    }, i2.prototype.toArray = function(e4, t3) {
      return this.toArrayLike(Array, e4, t3);
    }, i2.prototype.toArrayLike = function(e4, t3, n3) {
      var i3 = this.byteLength(), o3 = n3 || Math.max(1, i3);
      r2(i3 <= o3, "byte array longer than desired length"), r2(o3 > 0, "Requested array length <= 0"), this.strip();
      var s3, a3, u3 = "le" === t3, h3 = new e4(o3), f3 = this.clone();
      if (u3) {
        for (a3 = 0; !f3.isZero(); a3++)
          s3 = f3.andln(255), f3.iushrn(8), h3[a3] = s3;
        for (; a3 < o3; a3++)
          h3[a3] = 0;
      } else {
        for (a3 = 0; a3 < o3 - i3; a3++)
          h3[a3] = 0;
        for (a3 = 0; !f3.isZero(); a3++)
          s3 = f3.andln(255), f3.iushrn(8), h3[o3 - a3 - 1] = s3;
      }
      return h3;
    }, i2.prototype._countBits = Math.clz32 ? function(e4) {
      return 32 - Math.clz32(e4);
    } : function(e4) {
      var t3 = e4, r3 = 0;
      return t3 >= 4096 && (r3 += 13, t3 >>>= 13), t3 >= 64 && (r3 += 7, t3 >>>= 7), t3 >= 8 && (r3 += 4, t3 >>>= 4), t3 >= 2 && (r3 += 2, t3 >>>= 2), r3 + t3;
    }, i2.prototype._zeroBits = function(e4) {
      if (0 === e4)
        return 26;
      var t3 = e4, r3 = 0;
      return 0 == (8191 & t3) && (r3 += 13, t3 >>>= 13), 0 == (127 & t3) && (r3 += 7, t3 >>>= 7), 0 == (15 & t3) && (r3 += 4, t3 >>>= 4), 0 == (3 & t3) && (r3 += 2, t3 >>>= 2), 0 == (1 & t3) && r3++, r3;
    }, i2.prototype.bitLength = function() {
      var e4 = this._countBits(this.words[this.length - 1]);
      return 26 * (this.length - 1) + e4;
    }, i2.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var e4 = 0, t3 = 0; t3 < this.length; t3++) {
        var r3 = this._zeroBits(this.words[t3]);
        if (e4 += r3, 26 !== r3)
          break;
      }
      return e4;
    }, i2.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i2.prototype.toTwos = function(e4) {
      return 0 !== this.negative ? this.abs().inotn(e4).iaddn(1) : this.clone();
    }, i2.prototype.fromTwos = function(e4) {
      return this.testn(e4 - 1) ? this.notn(e4).iaddn(1).ineg() : this.clone();
    }, i2.prototype.isNeg = function() {
      return 0 !== this.negative;
    }, i2.prototype.neg = function() {
      return this.clone().ineg();
    }, i2.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i2.prototype.iuor = function(e4) {
      for (; this.length < e4.length; )
        this.words[this.length++] = 0;
      for (var t3 = 0; t3 < e4.length; t3++)
        this.words[t3] = this.words[t3] | e4.words[t3];
      return this.strip();
    }, i2.prototype.ior = function(e4) {
      return r2(0 == (this.negative | e4.negative)), this.iuor(e4);
    }, i2.prototype.or = function(e4) {
      return this.length > e4.length ? this.clone().ior(e4) : e4.clone().ior(this);
    }, i2.prototype.uor = function(e4) {
      return this.length > e4.length ? this.clone().iuor(e4) : e4.clone().iuor(this);
    }, i2.prototype.iuand = function(e4) {
      var t3;
      t3 = this.length > e4.length ? e4 : this;
      for (var r3 = 0; r3 < t3.length; r3++)
        this.words[r3] = this.words[r3] & e4.words[r3];
      return this.length = t3.length, this.strip();
    }, i2.prototype.iand = function(e4) {
      return r2(0 == (this.negative | e4.negative)), this.iuand(e4);
    }, i2.prototype.and = function(e4) {
      return this.length > e4.length ? this.clone().iand(e4) : e4.clone().iand(this);
    }, i2.prototype.uand = function(e4) {
      return this.length > e4.length ? this.clone().iuand(e4) : e4.clone().iuand(this);
    }, i2.prototype.iuxor = function(e4) {
      var t3, r3;
      this.length > e4.length ? (t3 = this, r3 = e4) : (t3 = e4, r3 = this);
      for (var n3 = 0; n3 < r3.length; n3++)
        this.words[n3] = t3.words[n3] ^ r3.words[n3];
      if (this !== t3)
        for (; n3 < t3.length; n3++)
          this.words[n3] = t3.words[n3];
      return this.length = t3.length, this.strip();
    }, i2.prototype.ixor = function(e4) {
      return r2(0 == (this.negative | e4.negative)), this.iuxor(e4);
    }, i2.prototype.xor = function(e4) {
      return this.length > e4.length ? this.clone().ixor(e4) : e4.clone().ixor(this);
    }, i2.prototype.uxor = function(e4) {
      return this.length > e4.length ? this.clone().iuxor(e4) : e4.clone().iuxor(this);
    }, i2.prototype.inotn = function(e4) {
      r2("number" == typeof e4 && e4 >= 0);
      var t3 = 0 | Math.ceil(e4 / 26), n3 = e4 % 26;
      this._expand(t3), n3 > 0 && t3--;
      for (var i3 = 0; i3 < t3; i3++)
        this.words[i3] = 67108863 & ~this.words[i3];
      return n3 > 0 && (this.words[i3] = ~this.words[i3] & 67108863 >> 26 - n3), this.strip();
    }, i2.prototype.notn = function(e4) {
      return this.clone().inotn(e4);
    }, i2.prototype.setn = function(e4, t3) {
      r2("number" == typeof e4 && e4 >= 0);
      var n3 = e4 / 26 | 0, i3 = e4 % 26;
      return this._expand(n3 + 1), this.words[n3] = t3 ? this.words[n3] | 1 << i3 : this.words[n3] & ~(1 << i3), this.strip();
    }, i2.prototype.iadd = function(e4) {
      var t3, r3, n3;
      if (0 !== this.negative && 0 === e4.negative)
        return this.negative = 0, t3 = this.isub(e4), this.negative ^= 1, this._normSign();
      if (0 === this.negative && 0 !== e4.negative)
        return e4.negative = 0, t3 = this.isub(e4), e4.negative = 1, t3._normSign();
      this.length > e4.length ? (r3 = this, n3 = e4) : (r3 = e4, n3 = this);
      for (var i3 = 0, o3 = 0; o3 < n3.length; o3++)
        this.words[o3] = 67108863 & (t3 = (0 | r3.words[o3]) + (0 | n3.words[o3]) + i3), i3 = t3 >>> 26;
      for (; 0 !== i3 && o3 < r3.length; o3++)
        this.words[o3] = 67108863 & (t3 = (0 | r3.words[o3]) + i3), i3 = t3 >>> 26;
      if (this.length = r3.length, 0 !== i3)
        this.words[this.length] = i3, this.length++;
      else if (r3 !== this)
        for (; o3 < r3.length; o3++)
          this.words[o3] = r3.words[o3];
      return this;
    }, i2.prototype.add = function(e4) {
      var t3;
      return 0 !== e4.negative && 0 === this.negative ? (e4.negative = 0, t3 = this.sub(e4), e4.negative ^= 1, t3) : 0 === e4.negative && 0 !== this.negative ? (this.negative = 0, t3 = e4.sub(this), this.negative = 1, t3) : this.length > e4.length ? this.clone().iadd(e4) : e4.clone().iadd(this);
    }, i2.prototype.isub = function(e4) {
      if (0 !== e4.negative) {
        e4.negative = 0;
        var t3 = this.iadd(e4);
        return e4.negative = 1, t3._normSign();
      }
      if (0 !== this.negative)
        return this.negative = 0, this.iadd(e4), this.negative = 1, this._normSign();
      var r3, n3, i3 = this.cmp(e4);
      if (0 === i3)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      i3 > 0 ? (r3 = this, n3 = e4) : (r3 = e4, n3 = this);
      for (var o3 = 0, s3 = 0; s3 < n3.length; s3++)
        o3 = (t3 = (0 | r3.words[s3]) - (0 | n3.words[s3]) + o3) >> 26, this.words[s3] = 67108863 & t3;
      for (; 0 !== o3 && s3 < r3.length; s3++)
        o3 = (t3 = (0 | r3.words[s3]) + o3) >> 26, this.words[s3] = 67108863 & t3;
      if (0 === o3 && s3 < r3.length && r3 !== this)
        for (; s3 < r3.length; s3++)
          this.words[s3] = r3.words[s3];
      return this.length = Math.max(this.length, s3), r3 !== this && (this.negative = 1), this.strip();
    }, i2.prototype.sub = function(e4) {
      return this.clone().isub(e4);
    };
    var d2 = function(e4, t3, r3) {
      var n3, i3, o3, s3 = e4.words, a3 = t3.words, u3 = r3.words, h3 = 0, f3 = 0 | s3[0], c3 = 8191 & f3, l3 = f3 >>> 13, d3 = 0 | s3[1], p3 = 8191 & d3, y3 = d3 >>> 13, g3 = 0 | s3[2], m3 = 8191 & g3, w3 = g3 >>> 13, b3 = 0 | s3[3], v3 = 8191 & b3, E3 = b3 >>> 13, x3 = 0 | s3[4], B3 = 8191 & x3, A2 = x3 >>> 13, _2 = 0 | s3[5], T2 = 8191 & _2, S2 = _2 >>> 13, N2 = 0 | s3[6], I2 = 8191 & N2, O2 = N2 >>> 13, U2 = 0 | s3[7], L2 = 8191 & U2, k2 = U2 >>> 13, M2 = 0 | s3[8], C2 = 8191 & M2, P2 = M2 >>> 13, R2 = 0 | s3[9], D2 = 8191 & R2, z2 = R2 >>> 13, $2 = 0 | a3[0], V2 = 8191 & $2, j2 = $2 >>> 13, F2 = 0 | a3[1], H2 = 8191 & F2, K2 = F2 >>> 13, G2 = 0 | a3[2], q2 = 8191 & G2, J2 = G2 >>> 13, W2 = 0 | a3[3], Z2 = 8191 & W2, Y2 = W2 >>> 13, X2 = 0 | a3[4], Q2 = 8191 & X2, ee2 = X2 >>> 13, te2 = 0 | a3[5], re2 = 8191 & te2, ne2 = te2 >>> 13, ie2 = 0 | a3[6], oe2 = 8191 & ie2, se2 = ie2 >>> 13, ae2 = 0 | a3[7], ue2 = 8191 & ae2, he2 = ae2 >>> 13, fe2 = 0 | a3[8], ce2 = 8191 & fe2, le2 = fe2 >>> 13, de2 = 0 | a3[9], pe2 = 8191 & de2, ye2 = de2 >>> 13;
      r3.negative = e4.negative ^ t3.negative, r3.length = 19;
      var ge2 = (h3 + (n3 = Math.imul(c3, V2)) | 0) + ((8191 & (i3 = (i3 = Math.imul(c3, j2)) + Math.imul(l3, V2) | 0)) << 13) | 0;
      h3 = ((o3 = Math.imul(l3, j2)) + (i3 >>> 13) | 0) + (ge2 >>> 26) | 0, ge2 &= 67108863, n3 = Math.imul(p3, V2), i3 = (i3 = Math.imul(p3, j2)) + Math.imul(y3, V2) | 0, o3 = Math.imul(y3, j2);
      var me2 = (h3 + (n3 = n3 + Math.imul(c3, H2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, K2) | 0) + Math.imul(l3, H2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, K2) | 0) + (i3 >>> 13) | 0) + (me2 >>> 26) | 0, me2 &= 67108863, n3 = Math.imul(m3, V2), i3 = (i3 = Math.imul(m3, j2)) + Math.imul(w3, V2) | 0, o3 = Math.imul(w3, j2), n3 = n3 + Math.imul(p3, H2) | 0, i3 = (i3 = i3 + Math.imul(p3, K2) | 0) + Math.imul(y3, H2) | 0, o3 = o3 + Math.imul(y3, K2) | 0;
      var we2 = (h3 + (n3 = n3 + Math.imul(c3, q2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, J2) | 0) + Math.imul(l3, q2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, J2) | 0) + (i3 >>> 13) | 0) + (we2 >>> 26) | 0, we2 &= 67108863, n3 = Math.imul(v3, V2), i3 = (i3 = Math.imul(v3, j2)) + Math.imul(E3, V2) | 0, o3 = Math.imul(E3, j2), n3 = n3 + Math.imul(m3, H2) | 0, i3 = (i3 = i3 + Math.imul(m3, K2) | 0) + Math.imul(w3, H2) | 0, o3 = o3 + Math.imul(w3, K2) | 0, n3 = n3 + Math.imul(p3, q2) | 0, i3 = (i3 = i3 + Math.imul(p3, J2) | 0) + Math.imul(y3, q2) | 0, o3 = o3 + Math.imul(y3, J2) | 0;
      var be2 = (h3 + (n3 = n3 + Math.imul(c3, Z2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, Y2) | 0) + Math.imul(l3, Z2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, Y2) | 0) + (i3 >>> 13) | 0) + (be2 >>> 26) | 0, be2 &= 67108863, n3 = Math.imul(B3, V2), i3 = (i3 = Math.imul(B3, j2)) + Math.imul(A2, V2) | 0, o3 = Math.imul(A2, j2), n3 = n3 + Math.imul(v3, H2) | 0, i3 = (i3 = i3 + Math.imul(v3, K2) | 0) + Math.imul(E3, H2) | 0, o3 = o3 + Math.imul(E3, K2) | 0, n3 = n3 + Math.imul(m3, q2) | 0, i3 = (i3 = i3 + Math.imul(m3, J2) | 0) + Math.imul(w3, q2) | 0, o3 = o3 + Math.imul(w3, J2) | 0, n3 = n3 + Math.imul(p3, Z2) | 0, i3 = (i3 = i3 + Math.imul(p3, Y2) | 0) + Math.imul(y3, Z2) | 0, o3 = o3 + Math.imul(y3, Y2) | 0;
      var ve2 = (h3 + (n3 = n3 + Math.imul(c3, Q2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, ee2) | 0) + Math.imul(l3, Q2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, ee2) | 0) + (i3 >>> 13) | 0) + (ve2 >>> 26) | 0, ve2 &= 67108863, n3 = Math.imul(T2, V2), i3 = (i3 = Math.imul(T2, j2)) + Math.imul(S2, V2) | 0, o3 = Math.imul(S2, j2), n3 = n3 + Math.imul(B3, H2) | 0, i3 = (i3 = i3 + Math.imul(B3, K2) | 0) + Math.imul(A2, H2) | 0, o3 = o3 + Math.imul(A2, K2) | 0, n3 = n3 + Math.imul(v3, q2) | 0, i3 = (i3 = i3 + Math.imul(v3, J2) | 0) + Math.imul(E3, q2) | 0, o3 = o3 + Math.imul(E3, J2) | 0, n3 = n3 + Math.imul(m3, Z2) | 0, i3 = (i3 = i3 + Math.imul(m3, Y2) | 0) + Math.imul(w3, Z2) | 0, o3 = o3 + Math.imul(w3, Y2) | 0, n3 = n3 + Math.imul(p3, Q2) | 0, i3 = (i3 = i3 + Math.imul(p3, ee2) | 0) + Math.imul(y3, Q2) | 0, o3 = o3 + Math.imul(y3, ee2) | 0;
      var Ee2 = (h3 + (n3 = n3 + Math.imul(c3, re2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, ne2) | 0) + Math.imul(l3, re2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, ne2) | 0) + (i3 >>> 13) | 0) + (Ee2 >>> 26) | 0, Ee2 &= 67108863, n3 = Math.imul(I2, V2), i3 = (i3 = Math.imul(I2, j2)) + Math.imul(O2, V2) | 0, o3 = Math.imul(O2, j2), n3 = n3 + Math.imul(T2, H2) | 0, i3 = (i3 = i3 + Math.imul(T2, K2) | 0) + Math.imul(S2, H2) | 0, o3 = o3 + Math.imul(S2, K2) | 0, n3 = n3 + Math.imul(B3, q2) | 0, i3 = (i3 = i3 + Math.imul(B3, J2) | 0) + Math.imul(A2, q2) | 0, o3 = o3 + Math.imul(A2, J2) | 0, n3 = n3 + Math.imul(v3, Z2) | 0, i3 = (i3 = i3 + Math.imul(v3, Y2) | 0) + Math.imul(E3, Z2) | 0, o3 = o3 + Math.imul(E3, Y2) | 0, n3 = n3 + Math.imul(m3, Q2) | 0, i3 = (i3 = i3 + Math.imul(m3, ee2) | 0) + Math.imul(w3, Q2) | 0, o3 = o3 + Math.imul(w3, ee2) | 0, n3 = n3 + Math.imul(p3, re2) | 0, i3 = (i3 = i3 + Math.imul(p3, ne2) | 0) + Math.imul(y3, re2) | 0, o3 = o3 + Math.imul(y3, ne2) | 0;
      var xe2 = (h3 + (n3 = n3 + Math.imul(c3, oe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, se2) | 0) + Math.imul(l3, oe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, se2) | 0) + (i3 >>> 13) | 0) + (xe2 >>> 26) | 0, xe2 &= 67108863, n3 = Math.imul(L2, V2), i3 = (i3 = Math.imul(L2, j2)) + Math.imul(k2, V2) | 0, o3 = Math.imul(k2, j2), n3 = n3 + Math.imul(I2, H2) | 0, i3 = (i3 = i3 + Math.imul(I2, K2) | 0) + Math.imul(O2, H2) | 0, o3 = o3 + Math.imul(O2, K2) | 0, n3 = n3 + Math.imul(T2, q2) | 0, i3 = (i3 = i3 + Math.imul(T2, J2) | 0) + Math.imul(S2, q2) | 0, o3 = o3 + Math.imul(S2, J2) | 0, n3 = n3 + Math.imul(B3, Z2) | 0, i3 = (i3 = i3 + Math.imul(B3, Y2) | 0) + Math.imul(A2, Z2) | 0, o3 = o3 + Math.imul(A2, Y2) | 0, n3 = n3 + Math.imul(v3, Q2) | 0, i3 = (i3 = i3 + Math.imul(v3, ee2) | 0) + Math.imul(E3, Q2) | 0, o3 = o3 + Math.imul(E3, ee2) | 0, n3 = n3 + Math.imul(m3, re2) | 0, i3 = (i3 = i3 + Math.imul(m3, ne2) | 0) + Math.imul(w3, re2) | 0, o3 = o3 + Math.imul(w3, ne2) | 0, n3 = n3 + Math.imul(p3, oe2) | 0, i3 = (i3 = i3 + Math.imul(p3, se2) | 0) + Math.imul(y3, oe2) | 0, o3 = o3 + Math.imul(y3, se2) | 0;
      var Be2 = (h3 + (n3 = n3 + Math.imul(c3, ue2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, he2) | 0) + Math.imul(l3, ue2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, he2) | 0) + (i3 >>> 13) | 0) + (Be2 >>> 26) | 0, Be2 &= 67108863, n3 = Math.imul(C2, V2), i3 = (i3 = Math.imul(C2, j2)) + Math.imul(P2, V2) | 0, o3 = Math.imul(P2, j2), n3 = n3 + Math.imul(L2, H2) | 0, i3 = (i3 = i3 + Math.imul(L2, K2) | 0) + Math.imul(k2, H2) | 0, o3 = o3 + Math.imul(k2, K2) | 0, n3 = n3 + Math.imul(I2, q2) | 0, i3 = (i3 = i3 + Math.imul(I2, J2) | 0) + Math.imul(O2, q2) | 0, o3 = o3 + Math.imul(O2, J2) | 0, n3 = n3 + Math.imul(T2, Z2) | 0, i3 = (i3 = i3 + Math.imul(T2, Y2) | 0) + Math.imul(S2, Z2) | 0, o3 = o3 + Math.imul(S2, Y2) | 0, n3 = n3 + Math.imul(B3, Q2) | 0, i3 = (i3 = i3 + Math.imul(B3, ee2) | 0) + Math.imul(A2, Q2) | 0, o3 = o3 + Math.imul(A2, ee2) | 0, n3 = n3 + Math.imul(v3, re2) | 0, i3 = (i3 = i3 + Math.imul(v3, ne2) | 0) + Math.imul(E3, re2) | 0, o3 = o3 + Math.imul(E3, ne2) | 0, n3 = n3 + Math.imul(m3, oe2) | 0, i3 = (i3 = i3 + Math.imul(m3, se2) | 0) + Math.imul(w3, oe2) | 0, o3 = o3 + Math.imul(w3, se2) | 0, n3 = n3 + Math.imul(p3, ue2) | 0, i3 = (i3 = i3 + Math.imul(p3, he2) | 0) + Math.imul(y3, ue2) | 0, o3 = o3 + Math.imul(y3, he2) | 0;
      var Ae2 = (h3 + (n3 = n3 + Math.imul(c3, ce2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, le2) | 0) + Math.imul(l3, ce2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, le2) | 0) + (i3 >>> 13) | 0) + (Ae2 >>> 26) | 0, Ae2 &= 67108863, n3 = Math.imul(D2, V2), i3 = (i3 = Math.imul(D2, j2)) + Math.imul(z2, V2) | 0, o3 = Math.imul(z2, j2), n3 = n3 + Math.imul(C2, H2) | 0, i3 = (i3 = i3 + Math.imul(C2, K2) | 0) + Math.imul(P2, H2) | 0, o3 = o3 + Math.imul(P2, K2) | 0, n3 = n3 + Math.imul(L2, q2) | 0, i3 = (i3 = i3 + Math.imul(L2, J2) | 0) + Math.imul(k2, q2) | 0, o3 = o3 + Math.imul(k2, J2) | 0, n3 = n3 + Math.imul(I2, Z2) | 0, i3 = (i3 = i3 + Math.imul(I2, Y2) | 0) + Math.imul(O2, Z2) | 0, o3 = o3 + Math.imul(O2, Y2) | 0, n3 = n3 + Math.imul(T2, Q2) | 0, i3 = (i3 = i3 + Math.imul(T2, ee2) | 0) + Math.imul(S2, Q2) | 0, o3 = o3 + Math.imul(S2, ee2) | 0, n3 = n3 + Math.imul(B3, re2) | 0, i3 = (i3 = i3 + Math.imul(B3, ne2) | 0) + Math.imul(A2, re2) | 0, o3 = o3 + Math.imul(A2, ne2) | 0, n3 = n3 + Math.imul(v3, oe2) | 0, i3 = (i3 = i3 + Math.imul(v3, se2) | 0) + Math.imul(E3, oe2) | 0, o3 = o3 + Math.imul(E3, se2) | 0, n3 = n3 + Math.imul(m3, ue2) | 0, i3 = (i3 = i3 + Math.imul(m3, he2) | 0) + Math.imul(w3, ue2) | 0, o3 = o3 + Math.imul(w3, he2) | 0, n3 = n3 + Math.imul(p3, ce2) | 0, i3 = (i3 = i3 + Math.imul(p3, le2) | 0) + Math.imul(y3, ce2) | 0, o3 = o3 + Math.imul(y3, le2) | 0;
      var _e2 = (h3 + (n3 = n3 + Math.imul(c3, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(c3, ye2) | 0) + Math.imul(l3, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(l3, ye2) | 0) + (i3 >>> 13) | 0) + (_e2 >>> 26) | 0, _e2 &= 67108863, n3 = Math.imul(D2, H2), i3 = (i3 = Math.imul(D2, K2)) + Math.imul(z2, H2) | 0, o3 = Math.imul(z2, K2), n3 = n3 + Math.imul(C2, q2) | 0, i3 = (i3 = i3 + Math.imul(C2, J2) | 0) + Math.imul(P2, q2) | 0, o3 = o3 + Math.imul(P2, J2) | 0, n3 = n3 + Math.imul(L2, Z2) | 0, i3 = (i3 = i3 + Math.imul(L2, Y2) | 0) + Math.imul(k2, Z2) | 0, o3 = o3 + Math.imul(k2, Y2) | 0, n3 = n3 + Math.imul(I2, Q2) | 0, i3 = (i3 = i3 + Math.imul(I2, ee2) | 0) + Math.imul(O2, Q2) | 0, o3 = o3 + Math.imul(O2, ee2) | 0, n3 = n3 + Math.imul(T2, re2) | 0, i3 = (i3 = i3 + Math.imul(T2, ne2) | 0) + Math.imul(S2, re2) | 0, o3 = o3 + Math.imul(S2, ne2) | 0, n3 = n3 + Math.imul(B3, oe2) | 0, i3 = (i3 = i3 + Math.imul(B3, se2) | 0) + Math.imul(A2, oe2) | 0, o3 = o3 + Math.imul(A2, se2) | 0, n3 = n3 + Math.imul(v3, ue2) | 0, i3 = (i3 = i3 + Math.imul(v3, he2) | 0) + Math.imul(E3, ue2) | 0, o3 = o3 + Math.imul(E3, he2) | 0, n3 = n3 + Math.imul(m3, ce2) | 0, i3 = (i3 = i3 + Math.imul(m3, le2) | 0) + Math.imul(w3, ce2) | 0, o3 = o3 + Math.imul(w3, le2) | 0;
      var Te2 = (h3 + (n3 = n3 + Math.imul(p3, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(p3, ye2) | 0) + Math.imul(y3, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(y3, ye2) | 0) + (i3 >>> 13) | 0) + (Te2 >>> 26) | 0, Te2 &= 67108863, n3 = Math.imul(D2, q2), i3 = (i3 = Math.imul(D2, J2)) + Math.imul(z2, q2) | 0, o3 = Math.imul(z2, J2), n3 = n3 + Math.imul(C2, Z2) | 0, i3 = (i3 = i3 + Math.imul(C2, Y2) | 0) + Math.imul(P2, Z2) | 0, o3 = o3 + Math.imul(P2, Y2) | 0, n3 = n3 + Math.imul(L2, Q2) | 0, i3 = (i3 = i3 + Math.imul(L2, ee2) | 0) + Math.imul(k2, Q2) | 0, o3 = o3 + Math.imul(k2, ee2) | 0, n3 = n3 + Math.imul(I2, re2) | 0, i3 = (i3 = i3 + Math.imul(I2, ne2) | 0) + Math.imul(O2, re2) | 0, o3 = o3 + Math.imul(O2, ne2) | 0, n3 = n3 + Math.imul(T2, oe2) | 0, i3 = (i3 = i3 + Math.imul(T2, se2) | 0) + Math.imul(S2, oe2) | 0, o3 = o3 + Math.imul(S2, se2) | 0, n3 = n3 + Math.imul(B3, ue2) | 0, i3 = (i3 = i3 + Math.imul(B3, he2) | 0) + Math.imul(A2, ue2) | 0, o3 = o3 + Math.imul(A2, he2) | 0, n3 = n3 + Math.imul(v3, ce2) | 0, i3 = (i3 = i3 + Math.imul(v3, le2) | 0) + Math.imul(E3, ce2) | 0, o3 = o3 + Math.imul(E3, le2) | 0;
      var Se2 = (h3 + (n3 = n3 + Math.imul(m3, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(m3, ye2) | 0) + Math.imul(w3, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(w3, ye2) | 0) + (i3 >>> 13) | 0) + (Se2 >>> 26) | 0, Se2 &= 67108863, n3 = Math.imul(D2, Z2), i3 = (i3 = Math.imul(D2, Y2)) + Math.imul(z2, Z2) | 0, o3 = Math.imul(z2, Y2), n3 = n3 + Math.imul(C2, Q2) | 0, i3 = (i3 = i3 + Math.imul(C2, ee2) | 0) + Math.imul(P2, Q2) | 0, o3 = o3 + Math.imul(P2, ee2) | 0, n3 = n3 + Math.imul(L2, re2) | 0, i3 = (i3 = i3 + Math.imul(L2, ne2) | 0) + Math.imul(k2, re2) | 0, o3 = o3 + Math.imul(k2, ne2) | 0, n3 = n3 + Math.imul(I2, oe2) | 0, i3 = (i3 = i3 + Math.imul(I2, se2) | 0) + Math.imul(O2, oe2) | 0, o3 = o3 + Math.imul(O2, se2) | 0, n3 = n3 + Math.imul(T2, ue2) | 0, i3 = (i3 = i3 + Math.imul(T2, he2) | 0) + Math.imul(S2, ue2) | 0, o3 = o3 + Math.imul(S2, he2) | 0, n3 = n3 + Math.imul(B3, ce2) | 0, i3 = (i3 = i3 + Math.imul(B3, le2) | 0) + Math.imul(A2, ce2) | 0, o3 = o3 + Math.imul(A2, le2) | 0;
      var Ne2 = (h3 + (n3 = n3 + Math.imul(v3, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(v3, ye2) | 0) + Math.imul(E3, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(E3, ye2) | 0) + (i3 >>> 13) | 0) + (Ne2 >>> 26) | 0, Ne2 &= 67108863, n3 = Math.imul(D2, Q2), i3 = (i3 = Math.imul(D2, ee2)) + Math.imul(z2, Q2) | 0, o3 = Math.imul(z2, ee2), n3 = n3 + Math.imul(C2, re2) | 0, i3 = (i3 = i3 + Math.imul(C2, ne2) | 0) + Math.imul(P2, re2) | 0, o3 = o3 + Math.imul(P2, ne2) | 0, n3 = n3 + Math.imul(L2, oe2) | 0, i3 = (i3 = i3 + Math.imul(L2, se2) | 0) + Math.imul(k2, oe2) | 0, o3 = o3 + Math.imul(k2, se2) | 0, n3 = n3 + Math.imul(I2, ue2) | 0, i3 = (i3 = i3 + Math.imul(I2, he2) | 0) + Math.imul(O2, ue2) | 0, o3 = o3 + Math.imul(O2, he2) | 0, n3 = n3 + Math.imul(T2, ce2) | 0, i3 = (i3 = i3 + Math.imul(T2, le2) | 0) + Math.imul(S2, ce2) | 0, o3 = o3 + Math.imul(S2, le2) | 0;
      var Ie2 = (h3 + (n3 = n3 + Math.imul(B3, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(B3, ye2) | 0) + Math.imul(A2, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(A2, ye2) | 0) + (i3 >>> 13) | 0) + (Ie2 >>> 26) | 0, Ie2 &= 67108863, n3 = Math.imul(D2, re2), i3 = (i3 = Math.imul(D2, ne2)) + Math.imul(z2, re2) | 0, o3 = Math.imul(z2, ne2), n3 = n3 + Math.imul(C2, oe2) | 0, i3 = (i3 = i3 + Math.imul(C2, se2) | 0) + Math.imul(P2, oe2) | 0, o3 = o3 + Math.imul(P2, se2) | 0, n3 = n3 + Math.imul(L2, ue2) | 0, i3 = (i3 = i3 + Math.imul(L2, he2) | 0) + Math.imul(k2, ue2) | 0, o3 = o3 + Math.imul(k2, he2) | 0, n3 = n3 + Math.imul(I2, ce2) | 0, i3 = (i3 = i3 + Math.imul(I2, le2) | 0) + Math.imul(O2, ce2) | 0, o3 = o3 + Math.imul(O2, le2) | 0;
      var Oe2 = (h3 + (n3 = n3 + Math.imul(T2, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(T2, ye2) | 0) + Math.imul(S2, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(S2, ye2) | 0) + (i3 >>> 13) | 0) + (Oe2 >>> 26) | 0, Oe2 &= 67108863, n3 = Math.imul(D2, oe2), i3 = (i3 = Math.imul(D2, se2)) + Math.imul(z2, oe2) | 0, o3 = Math.imul(z2, se2), n3 = n3 + Math.imul(C2, ue2) | 0, i3 = (i3 = i3 + Math.imul(C2, he2) | 0) + Math.imul(P2, ue2) | 0, o3 = o3 + Math.imul(P2, he2) | 0, n3 = n3 + Math.imul(L2, ce2) | 0, i3 = (i3 = i3 + Math.imul(L2, le2) | 0) + Math.imul(k2, ce2) | 0, o3 = o3 + Math.imul(k2, le2) | 0;
      var Ue2 = (h3 + (n3 = n3 + Math.imul(I2, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(I2, ye2) | 0) + Math.imul(O2, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(O2, ye2) | 0) + (i3 >>> 13) | 0) + (Ue2 >>> 26) | 0, Ue2 &= 67108863, n3 = Math.imul(D2, ue2), i3 = (i3 = Math.imul(D2, he2)) + Math.imul(z2, ue2) | 0, o3 = Math.imul(z2, he2), n3 = n3 + Math.imul(C2, ce2) | 0, i3 = (i3 = i3 + Math.imul(C2, le2) | 0) + Math.imul(P2, ce2) | 0, o3 = o3 + Math.imul(P2, le2) | 0;
      var Le2 = (h3 + (n3 = n3 + Math.imul(L2, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(L2, ye2) | 0) + Math.imul(k2, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(k2, ye2) | 0) + (i3 >>> 13) | 0) + (Le2 >>> 26) | 0, Le2 &= 67108863, n3 = Math.imul(D2, ce2), i3 = (i3 = Math.imul(D2, le2)) + Math.imul(z2, ce2) | 0, o3 = Math.imul(z2, le2);
      var ke2 = (h3 + (n3 = n3 + Math.imul(C2, pe2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(C2, ye2) | 0) + Math.imul(P2, pe2) | 0)) << 13) | 0;
      h3 = ((o3 = o3 + Math.imul(P2, ye2) | 0) + (i3 >>> 13) | 0) + (ke2 >>> 26) | 0, ke2 &= 67108863;
      var Me2 = (h3 + (n3 = Math.imul(D2, pe2)) | 0) + ((8191 & (i3 = (i3 = Math.imul(D2, ye2)) + Math.imul(z2, pe2) | 0)) << 13) | 0;
      return h3 = ((o3 = Math.imul(z2, ye2)) + (i3 >>> 13) | 0) + (Me2 >>> 26) | 0, Me2 &= 67108863, u3[0] = ge2, u3[1] = me2, u3[2] = we2, u3[3] = be2, u3[4] = ve2, u3[5] = Ee2, u3[6] = xe2, u3[7] = Be2, u3[8] = Ae2, u3[9] = _e2, u3[10] = Te2, u3[11] = Se2, u3[12] = Ne2, u3[13] = Ie2, u3[14] = Oe2, u3[15] = Ue2, u3[16] = Le2, u3[17] = ke2, u3[18] = Me2, 0 !== h3 && (u3[19] = h3, r3.length++), r3;
    };
    function p2(e4, t3, r3) {
      return new y2().mulp(e4, t3, r3);
    }
    function y2(e4, t3) {
      this.x = e4, this.y = t3;
    }
    Math.imul || (d2 = l2), i2.prototype.mulTo = function(e4, t3) {
      var r3, n3 = this.length + e4.length;
      return r3 = 10 === this.length && 10 === e4.length ? d2(this, e4, t3) : n3 < 63 ? l2(this, e4, t3) : n3 < 1024 ? function(e5, t4, r4) {
        r4.negative = t4.negative ^ e5.negative, r4.length = e5.length + t4.length;
        for (var n4 = 0, i3 = 0, o3 = 0; o3 < r4.length - 1; o3++) {
          var s3 = i3;
          i3 = 0;
          for (var a3 = 67108863 & n4, u3 = Math.min(o3, t4.length - 1), h3 = Math.max(0, o3 - e5.length + 1); h3 <= u3; h3++) {
            var f3 = (0 | e5.words[o3 - h3]) * (0 | t4.words[h3]), c3 = 67108863 & f3;
            a3 = 67108863 & (c3 = c3 + a3 | 0), i3 += (s3 = (s3 = s3 + (f3 / 67108864 | 0) | 0) + (c3 >>> 26) | 0) >>> 26, s3 &= 67108863;
          }
          r4.words[o3] = a3, n4 = s3, s3 = i3;
        }
        return 0 !== n4 ? r4.words[o3] = n4 : r4.length--, r4.strip();
      }(this, e4, t3) : p2(this, e4, t3), r3;
    }, y2.prototype.makeRBT = function(e4) {
      for (var t3 = new Array(e4), r3 = i2.prototype._countBits(e4) - 1, n3 = 0; n3 < e4; n3++)
        t3[n3] = this.revBin(n3, r3, e4);
      return t3;
    }, y2.prototype.revBin = function(e4, t3, r3) {
      if (0 === e4 || e4 === r3 - 1)
        return e4;
      for (var n3 = 0, i3 = 0; i3 < t3; i3++)
        n3 |= (1 & e4) << t3 - i3 - 1, e4 >>= 1;
      return n3;
    }, y2.prototype.permute = function(e4, t3, r3, n3, i3, o3) {
      for (var s3 = 0; s3 < o3; s3++)
        n3[s3] = t3[e4[s3]], i3[s3] = r3[e4[s3]];
    }, y2.prototype.transform = function(e4, t3, r3, n3, i3, o3) {
      this.permute(o3, e4, t3, r3, n3, i3);
      for (var s3 = 1; s3 < i3; s3 <<= 1)
        for (var a3 = s3 << 1, u3 = Math.cos(2 * Math.PI / a3), h3 = Math.sin(2 * Math.PI / a3), f3 = 0; f3 < i3; f3 += a3)
          for (var c3 = u3, l3 = h3, d3 = 0; d3 < s3; d3++) {
            var p3 = r3[f3 + d3], y3 = n3[f3 + d3], g3 = r3[f3 + d3 + s3], m3 = n3[f3 + d3 + s3], w3 = c3 * g3 - l3 * m3;
            m3 = c3 * m3 + l3 * g3, r3[f3 + d3] = p3 + (g3 = w3), n3[f3 + d3] = y3 + m3, r3[f3 + d3 + s3] = p3 - g3, n3[f3 + d3 + s3] = y3 - m3, d3 !== a3 && (w3 = u3 * c3 - h3 * l3, l3 = u3 * l3 + h3 * c3, c3 = w3);
          }
    }, y2.prototype.guessLen13b = function(e4, t3) {
      var r3 = 1 | Math.max(t3, e4), n3 = 1 & r3, i3 = 0;
      for (r3 = r3 / 2 | 0; r3; r3 >>>= 1)
        i3++;
      return 1 << i3 + 1 + n3;
    }, y2.prototype.conjugate = function(e4, t3, r3) {
      if (!(r3 <= 1))
        for (var n3 = 0; n3 < r3 / 2; n3++) {
          var i3 = e4[n3];
          e4[n3] = e4[r3 - n3 - 1], e4[r3 - n3 - 1] = i3, i3 = t3[n3], t3[n3] = -t3[r3 - n3 - 1], t3[r3 - n3 - 1] = -i3;
        }
    }, y2.prototype.normalize13b = function(e4, t3) {
      for (var r3 = 0, n3 = 0; n3 < t3 / 2; n3++) {
        var i3 = 8192 * Math.round(e4[2 * n3 + 1] / t3) + Math.round(e4[2 * n3] / t3) + r3;
        e4[n3] = 67108863 & i3, r3 = i3 < 67108864 ? 0 : i3 / 67108864 | 0;
      }
      return e4;
    }, y2.prototype.convert13b = function(e4, t3, n3, i3) {
      for (var o3 = 0, s3 = 0; s3 < t3; s3++)
        n3[2 * s3] = 8191 & (o3 += 0 | e4[s3]), n3[2 * s3 + 1] = 8191 & (o3 >>>= 13), o3 >>>= 13;
      for (s3 = 2 * t3; s3 < i3; ++s3)
        n3[s3] = 0;
      r2(0 === o3), r2(0 == (-8192 & o3));
    }, y2.prototype.stub = function(e4) {
      for (var t3 = new Array(e4), r3 = 0; r3 < e4; r3++)
        t3[r3] = 0;
      return t3;
    }, y2.prototype.mulp = function(e4, t3, r3) {
      var n3 = 2 * this.guessLen13b(e4.length, t3.length), i3 = this.makeRBT(n3), o3 = this.stub(n3), s3 = new Array(n3), a3 = new Array(n3), u3 = new Array(n3), h3 = new Array(n3), f3 = new Array(n3), c3 = new Array(n3), l3 = r3.words;
      l3.length = n3, this.convert13b(e4.words, e4.length, s3, n3), this.convert13b(t3.words, t3.length, h3, n3), this.transform(s3, o3, a3, u3, n3, i3), this.transform(h3, o3, f3, c3, n3, i3);
      for (var d3 = 0; d3 < n3; d3++) {
        var p3 = a3[d3] * f3[d3] - u3[d3] * c3[d3];
        u3[d3] = a3[d3] * c3[d3] + u3[d3] * f3[d3], a3[d3] = p3;
      }
      return this.conjugate(a3, u3, n3), this.transform(a3, u3, l3, o3, n3, i3), this.conjugate(l3, o3, n3), this.normalize13b(l3, n3), r3.negative = e4.negative ^ t3.negative, r3.length = e4.length + t3.length, r3.strip();
    }, i2.prototype.mul = function(e4) {
      var t3 = new i2(null);
      return t3.words = new Array(this.length + e4.length), this.mulTo(e4, t3);
    }, i2.prototype.mulf = function(e4) {
      var t3 = new i2(null);
      return t3.words = new Array(this.length + e4.length), p2(this, e4, t3);
    }, i2.prototype.imul = function(e4) {
      return this.clone().mulTo(e4, this);
    }, i2.prototype.imuln = function(e4) {
      r2("number" == typeof e4), r2(e4 < 67108864);
      for (var t3 = 0, n3 = 0; n3 < this.length; n3++) {
        var i3 = (0 | this.words[n3]) * e4, o3 = (67108863 & i3) + (67108863 & t3);
        t3 >>= 26, t3 += i3 / 67108864 | 0, t3 += o3 >>> 26, this.words[n3] = 67108863 & o3;
      }
      return 0 !== t3 && (this.words[n3] = t3, this.length++), this;
    }, i2.prototype.muln = function(e4) {
      return this.clone().imuln(e4);
    }, i2.prototype.sqr = function() {
      return this.mul(this);
    }, i2.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i2.prototype.pow = function(e4) {
      var t3 = function(e5) {
        for (var t4 = new Array(e5.bitLength()), r4 = 0; r4 < t4.length; r4++) {
          var n4 = r4 % 26;
          t4[r4] = (e5.words[r4 / 26 | 0] & 1 << n4) >>> n4;
        }
        return t4;
      }(e4);
      if (0 === t3.length)
        return new i2(1);
      for (var r3 = this, n3 = 0; n3 < t3.length && 0 === t3[n3]; n3++, r3 = r3.sqr())
        ;
      if (++n3 < t3.length)
        for (var o3 = r3.sqr(); n3 < t3.length; n3++, o3 = o3.sqr())
          0 !== t3[n3] && (r3 = r3.mul(o3));
      return r3;
    }, i2.prototype.iushln = function(e4) {
      r2("number" == typeof e4 && e4 >= 0);
      var t3, n3 = e4 % 26, i3 = (e4 - n3) / 26, o3 = 67108863 >>> 26 - n3 << 26 - n3;
      if (0 !== n3) {
        var s3 = 0;
        for (t3 = 0; t3 < this.length; t3++) {
          var a3 = this.words[t3] & o3;
          this.words[t3] = (0 | this.words[t3]) - a3 << n3 | s3, s3 = a3 >>> 26 - n3;
        }
        s3 && (this.words[t3] = s3, this.length++);
      }
      if (0 !== i3) {
        for (t3 = this.length - 1; t3 >= 0; t3--)
          this.words[t3 + i3] = this.words[t3];
        for (t3 = 0; t3 < i3; t3++)
          this.words[t3] = 0;
        this.length += i3;
      }
      return this.strip();
    }, i2.prototype.ishln = function(e4) {
      return r2(0 === this.negative), this.iushln(e4);
    }, i2.prototype.iushrn = function(e4, t3, n3) {
      var i3;
      r2("number" == typeof e4 && e4 >= 0), i3 = t3 ? (t3 - t3 % 26) / 26 : 0;
      var o3 = e4 % 26, s3 = Math.min((e4 - o3) / 26, this.length), a3 = 67108863 ^ 67108863 >>> o3 << o3, u3 = n3;
      if (i3 -= s3, i3 = Math.max(0, i3), u3) {
        for (var h3 = 0; h3 < s3; h3++)
          u3.words[h3] = this.words[h3];
        u3.length = s3;
      }
      if (0 === s3)
        ;
      else if (this.length > s3)
        for (this.length -= s3, h3 = 0; h3 < this.length; h3++)
          this.words[h3] = this.words[h3 + s3];
      else
        this.words[0] = 0, this.length = 1;
      var f3 = 0;
      for (h3 = this.length - 1; h3 >= 0 && (0 !== f3 || h3 >= i3); h3--) {
        var c3 = 0 | this.words[h3];
        this.words[h3] = f3 << 26 - o3 | c3 >>> o3, f3 = c3 & a3;
      }
      return u3 && 0 !== f3 && (u3.words[u3.length++] = f3), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
    }, i2.prototype.ishrn = function(e4, t3, n3) {
      return r2(0 === this.negative), this.iushrn(e4, t3, n3);
    }, i2.prototype.shln = function(e4) {
      return this.clone().ishln(e4);
    }, i2.prototype.ushln = function(e4) {
      return this.clone().iushln(e4);
    }, i2.prototype.shrn = function(e4) {
      return this.clone().ishrn(e4);
    }, i2.prototype.ushrn = function(e4) {
      return this.clone().iushrn(e4);
    }, i2.prototype.testn = function(e4) {
      r2("number" == typeof e4 && e4 >= 0);
      var t3 = e4 % 26, n3 = (e4 - t3) / 26;
      return !(this.length <= n3 || !(this.words[n3] & 1 << t3));
    }, i2.prototype.imaskn = function(e4) {
      r2("number" == typeof e4 && e4 >= 0);
      var t3 = e4 % 26, n3 = (e4 - t3) / 26;
      return r2(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n3 ? this : (0 !== t3 && n3++, this.length = Math.min(n3, this.length), 0 !== t3 && (this.words[this.length - 1] &= 67108863 ^ 67108863 >>> t3 << t3), this.strip());
    }, i2.prototype.maskn = function(e4) {
      return this.clone().imaskn(e4);
    }, i2.prototype.iaddn = function(e4) {
      return r2("number" == typeof e4), r2(e4 < 67108864), e4 < 0 ? this.isubn(-e4) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < e4 ? (this.words[0] = e4 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e4), this.negative = 1, this) : this._iaddn(e4);
    }, i2.prototype._iaddn = function(e4) {
      this.words[0] += e4;
      for (var t3 = 0; t3 < this.length && this.words[t3] >= 67108864; t3++)
        this.words[t3] -= 67108864, t3 === this.length - 1 ? this.words[t3 + 1] = 1 : this.words[t3 + 1]++;
      return this.length = Math.max(this.length, t3 + 1), this;
    }, i2.prototype.isubn = function(e4) {
      if (r2("number" == typeof e4), r2(e4 < 67108864), e4 < 0)
        return this.iaddn(-e4);
      if (0 !== this.negative)
        return this.negative = 0, this.iaddn(e4), this.negative = 1, this;
      if (this.words[0] -= e4, 1 === this.length && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var t3 = 0; t3 < this.length && this.words[t3] < 0; t3++)
          this.words[t3] += 67108864, this.words[t3 + 1] -= 1;
      return this.strip();
    }, i2.prototype.addn = function(e4) {
      return this.clone().iaddn(e4);
    }, i2.prototype.subn = function(e4) {
      return this.clone().isubn(e4);
    }, i2.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i2.prototype.abs = function() {
      return this.clone().iabs();
    }, i2.prototype._ishlnsubmul = function(e4, t3, n3) {
      var i3, o3;
      this._expand(e4.length + n3);
      var s3 = 0;
      for (i3 = 0; i3 < e4.length; i3++) {
        o3 = (0 | this.words[i3 + n3]) + s3;
        var a3 = (0 | e4.words[i3]) * t3;
        s3 = ((o3 -= 67108863 & a3) >> 26) - (a3 / 67108864 | 0), this.words[i3 + n3] = 67108863 & o3;
      }
      for (; i3 < this.length - n3; i3++)
        s3 = (o3 = (0 | this.words[i3 + n3]) + s3) >> 26, this.words[i3 + n3] = 67108863 & o3;
      if (0 === s3)
        return this.strip();
      for (r2(-1 === s3), s3 = 0, i3 = 0; i3 < this.length; i3++)
        s3 = (o3 = -(0 | this.words[i3]) + s3) >> 26, this.words[i3] = 67108863 & o3;
      return this.negative = 1, this.strip();
    }, i2.prototype._wordDiv = function(e4, t3) {
      var r3, n3 = this.clone(), o3 = e4, s3 = 0 | o3.words[o3.length - 1];
      0 != (r3 = 26 - this._countBits(s3)) && (o3 = o3.ushln(r3), n3.iushln(r3), s3 = 0 | o3.words[o3.length - 1]);
      var a3, u3 = n3.length - o3.length;
      if ("mod" !== t3) {
        (a3 = new i2(null)).length = u3 + 1, a3.words = new Array(a3.length);
        for (var h3 = 0; h3 < a3.length; h3++)
          a3.words[h3] = 0;
      }
      var f3 = n3.clone()._ishlnsubmul(o3, 1, u3);
      0 === f3.negative && (n3 = f3, a3 && (a3.words[u3] = 1));
      for (var c3 = u3 - 1; c3 >= 0; c3--) {
        var l3 = 67108864 * (0 | n3.words[o3.length + c3]) + (0 | n3.words[o3.length + c3 - 1]);
        for (l3 = Math.min(l3 / s3 | 0, 67108863), n3._ishlnsubmul(o3, l3, c3); 0 !== n3.negative; )
          l3--, n3.negative = 0, n3._ishlnsubmul(o3, 1, c3), n3.isZero() || (n3.negative ^= 1);
        a3 && (a3.words[c3] = l3);
      }
      return a3 && a3.strip(), n3.strip(), "div" !== t3 && 0 !== r3 && n3.iushrn(r3), { div: a3 || null, mod: n3 };
    }, i2.prototype.divmod = function(e4, t3, n3) {
      return r2(!e4.isZero()), this.isZero() ? { div: new i2(0), mod: new i2(0) } : 0 !== this.negative && 0 === e4.negative ? (a3 = this.neg().divmod(e4, t3), "mod" !== t3 && (o3 = a3.div.neg()), "div" !== t3 && (s3 = a3.mod.neg(), n3 && 0 !== s3.negative && s3.iadd(e4)), { div: o3, mod: s3 }) : 0 === this.negative && 0 !== e4.negative ? (a3 = this.divmod(e4.neg(), t3), "mod" !== t3 && (o3 = a3.div.neg()), { div: o3, mod: a3.mod }) : 0 != (this.negative & e4.negative) ? (a3 = this.neg().divmod(e4.neg(), t3), "div" !== t3 && (s3 = a3.mod.neg(), n3 && 0 !== s3.negative && s3.isub(e4)), { div: a3.div, mod: s3 }) : e4.length > this.length || this.cmp(e4) < 0 ? { div: new i2(0), mod: this } : 1 === e4.length ? "div" === t3 ? { div: this.divn(e4.words[0]), mod: null } : "mod" === t3 ? { div: null, mod: new i2(this.modn(e4.words[0])) } : { div: this.divn(e4.words[0]), mod: new i2(this.modn(e4.words[0])) } : this._wordDiv(e4, t3);
      var o3, s3, a3;
    }, i2.prototype.div = function(e4) {
      return this.divmod(e4, "div", false).div;
    }, i2.prototype.mod = function(e4) {
      return this.divmod(e4, "mod", false).mod;
    }, i2.prototype.umod = function(e4) {
      return this.divmod(e4, "mod", true).mod;
    }, i2.prototype.divRound = function(e4) {
      var t3 = this.divmod(e4);
      if (t3.mod.isZero())
        return t3.div;
      var r3 = 0 !== t3.div.negative ? t3.mod.isub(e4) : t3.mod, n3 = e4.ushrn(1), i3 = e4.andln(1), o3 = r3.cmp(n3);
      return o3 < 0 || 1 === i3 && 0 === o3 ? t3.div : 0 !== t3.div.negative ? t3.div.isubn(1) : t3.div.iaddn(1);
    }, i2.prototype.modn = function(e4) {
      r2(e4 <= 67108863);
      for (var t3 = (1 << 26) % e4, n3 = 0, i3 = this.length - 1; i3 >= 0; i3--)
        n3 = (t3 * n3 + (0 | this.words[i3])) % e4;
      return n3;
    }, i2.prototype.idivn = function(e4) {
      r2(e4 <= 67108863);
      for (var t3 = 0, n3 = this.length - 1; n3 >= 0; n3--) {
        var i3 = (0 | this.words[n3]) + 67108864 * t3;
        this.words[n3] = i3 / e4 | 0, t3 = i3 % e4;
      }
      return this.strip();
    }, i2.prototype.divn = function(e4) {
      return this.clone().idivn(e4);
    }, i2.prototype.egcd = function(e4) {
      r2(0 === e4.negative), r2(!e4.isZero());
      var t3 = this, n3 = e4.clone();
      t3 = 0 !== t3.negative ? t3.umod(e4) : t3.clone();
      for (var o3 = new i2(1), s3 = new i2(0), a3 = new i2(0), u3 = new i2(1), h3 = 0; t3.isEven() && n3.isEven(); )
        t3.iushrn(1), n3.iushrn(1), ++h3;
      for (var f3 = n3.clone(), c3 = t3.clone(); !t3.isZero(); ) {
        for (var l3 = 0, d3 = 1; 0 == (t3.words[0] & d3) && l3 < 26; ++l3, d3 <<= 1)
          ;
        if (l3 > 0)
          for (t3.iushrn(l3); l3-- > 0; )
            (o3.isOdd() || s3.isOdd()) && (o3.iadd(f3), s3.isub(c3)), o3.iushrn(1), s3.iushrn(1);
        for (var p3 = 0, y3 = 1; 0 == (n3.words[0] & y3) && p3 < 26; ++p3, y3 <<= 1)
          ;
        if (p3 > 0)
          for (n3.iushrn(p3); p3-- > 0; )
            (a3.isOdd() || u3.isOdd()) && (a3.iadd(f3), u3.isub(c3)), a3.iushrn(1), u3.iushrn(1);
        t3.cmp(n3) >= 0 ? (t3.isub(n3), o3.isub(a3), s3.isub(u3)) : (n3.isub(t3), a3.isub(o3), u3.isub(s3));
      }
      return { a: a3, b: u3, gcd: n3.iushln(h3) };
    }, i2.prototype._invmp = function(e4) {
      r2(0 === e4.negative), r2(!e4.isZero());
      var t3 = this, n3 = e4.clone();
      t3 = 0 !== t3.negative ? t3.umod(e4) : t3.clone();
      for (var o3, s3 = new i2(1), a3 = new i2(0), u3 = n3.clone(); t3.cmpn(1) > 0 && n3.cmpn(1) > 0; ) {
        for (var h3 = 0, f3 = 1; 0 == (t3.words[0] & f3) && h3 < 26; ++h3, f3 <<= 1)
          ;
        if (h3 > 0)
          for (t3.iushrn(h3); h3-- > 0; )
            s3.isOdd() && s3.iadd(u3), s3.iushrn(1);
        for (var c3 = 0, l3 = 1; 0 == (n3.words[0] & l3) && c3 < 26; ++c3, l3 <<= 1)
          ;
        if (c3 > 0)
          for (n3.iushrn(c3); c3-- > 0; )
            a3.isOdd() && a3.iadd(u3), a3.iushrn(1);
        t3.cmp(n3) >= 0 ? (t3.isub(n3), s3.isub(a3)) : (n3.isub(t3), a3.isub(s3));
      }
      return (o3 = 0 === t3.cmpn(1) ? s3 : a3).cmpn(0) < 0 && o3.iadd(e4), o3;
    }, i2.prototype.gcd = function(e4) {
      if (this.isZero())
        return e4.abs();
      if (e4.isZero())
        return this.abs();
      var t3 = this.clone(), r3 = e4.clone();
      t3.negative = 0, r3.negative = 0;
      for (var n3 = 0; t3.isEven() && r3.isEven(); n3++)
        t3.iushrn(1), r3.iushrn(1);
      for (; ; ) {
        for (; t3.isEven(); )
          t3.iushrn(1);
        for (; r3.isEven(); )
          r3.iushrn(1);
        var i3 = t3.cmp(r3);
        if (i3 < 0) {
          var o3 = t3;
          t3 = r3, r3 = o3;
        } else if (0 === i3 || 0 === r3.cmpn(1))
          break;
        t3.isub(r3);
      }
      return r3.iushln(n3);
    }, i2.prototype.invm = function(e4) {
      return this.egcd(e4).a.umod(e4);
    }, i2.prototype.isEven = function() {
      return 0 == (1 & this.words[0]);
    }, i2.prototype.isOdd = function() {
      return 1 == (1 & this.words[0]);
    }, i2.prototype.andln = function(e4) {
      return this.words[0] & e4;
    }, i2.prototype.bincn = function(e4) {
      r2("number" == typeof e4);
      var t3 = e4 % 26, n3 = (e4 - t3) / 26, i3 = 1 << t3;
      if (this.length <= n3)
        return this._expand(n3 + 1), this.words[n3] |= i3, this;
      for (var o3 = i3, s3 = n3; 0 !== o3 && s3 < this.length; s3++) {
        var a3 = 0 | this.words[s3];
        o3 = (a3 += o3) >>> 26, this.words[s3] = a3 &= 67108863;
      }
      return 0 !== o3 && (this.words[s3] = o3, this.length++), this;
    }, i2.prototype.isZero = function() {
      return 1 === this.length && 0 === this.words[0];
    }, i2.prototype.cmpn = function(e4) {
      var t3, n3 = e4 < 0;
      if (0 !== this.negative && !n3)
        return -1;
      if (0 === this.negative && n3)
        return 1;
      if (this.strip(), this.length > 1)
        t3 = 1;
      else {
        n3 && (e4 = -e4), r2(e4 <= 67108863, "Number is too big");
        var i3 = 0 | this.words[0];
        t3 = i3 === e4 ? 0 : i3 < e4 ? -1 : 1;
      }
      return 0 !== this.negative ? 0 | -t3 : t3;
    }, i2.prototype.cmp = function(e4) {
      if (0 !== this.negative && 0 === e4.negative)
        return -1;
      if (0 === this.negative && 0 !== e4.negative)
        return 1;
      var t3 = this.ucmp(e4);
      return 0 !== this.negative ? 0 | -t3 : t3;
    }, i2.prototype.ucmp = function(e4) {
      if (this.length > e4.length)
        return 1;
      if (this.length < e4.length)
        return -1;
      for (var t3 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
        var n3 = 0 | this.words[r3], i3 = 0 | e4.words[r3];
        if (n3 !== i3) {
          n3 < i3 ? t3 = -1 : n3 > i3 && (t3 = 1);
          break;
        }
      }
      return t3;
    }, i2.prototype.gtn = function(e4) {
      return 1 === this.cmpn(e4);
    }, i2.prototype.gt = function(e4) {
      return 1 === this.cmp(e4);
    }, i2.prototype.gten = function(e4) {
      return this.cmpn(e4) >= 0;
    }, i2.prototype.gte = function(e4) {
      return this.cmp(e4) >= 0;
    }, i2.prototype.ltn = function(e4) {
      return -1 === this.cmpn(e4);
    }, i2.prototype.lt = function(e4) {
      return -1 === this.cmp(e4);
    }, i2.prototype.lten = function(e4) {
      return this.cmpn(e4) <= 0;
    }, i2.prototype.lte = function(e4) {
      return this.cmp(e4) <= 0;
    }, i2.prototype.eqn = function(e4) {
      return 0 === this.cmpn(e4);
    }, i2.prototype.eq = function(e4) {
      return 0 === this.cmp(e4);
    }, i2.red = function(e4) {
      return new x2(e4);
    }, i2.prototype.toRed = function(e4) {
      return r2(!this.red, "Already a number in reduction context"), r2(0 === this.negative, "red works only with positives"), e4.convertTo(this)._forceRed(e4);
    }, i2.prototype.fromRed = function() {
      return r2(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i2.prototype._forceRed = function(e4) {
      return this.red = e4, this;
    }, i2.prototype.forceRed = function(e4) {
      return r2(!this.red, "Already a number in reduction context"), this._forceRed(e4);
    }, i2.prototype.redAdd = function(e4) {
      return r2(this.red, "redAdd works only with red numbers"), this.red.add(this, e4);
    }, i2.prototype.redIAdd = function(e4) {
      return r2(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e4);
    }, i2.prototype.redSub = function(e4) {
      return r2(this.red, "redSub works only with red numbers"), this.red.sub(this, e4);
    }, i2.prototype.redISub = function(e4) {
      return r2(this.red, "redISub works only with red numbers"), this.red.isub(this, e4);
    }, i2.prototype.redShl = function(e4) {
      return r2(this.red, "redShl works only with red numbers"), this.red.shl(this, e4);
    }, i2.prototype.redMul = function(e4) {
      return r2(this.red, "redMul works only with red numbers"), this.red._verify2(this, e4), this.red.mul(this, e4);
    }, i2.prototype.redIMul = function(e4) {
      return r2(this.red, "redMul works only with red numbers"), this.red._verify2(this, e4), this.red.imul(this, e4);
    }, i2.prototype.redSqr = function() {
      return r2(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i2.prototype.redISqr = function() {
      return r2(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i2.prototype.redSqrt = function() {
      return r2(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i2.prototype.redInvm = function() {
      return r2(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i2.prototype.redNeg = function() {
      return r2(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i2.prototype.redPow = function(e4) {
      return r2(this.red && !e4.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e4);
    };
    var g2 = { k256: null, p224: null, p192: null, p25519: null };
    function m2(e4, t3) {
      this.name = e4, this.p = new i2(t3, 16), this.n = this.p.bitLength(), this.k = new i2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    function w2() {
      m2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    function b2() {
      m2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    function v2() {
      m2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    function E2() {
      m2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    function x2(e4) {
      if ("string" == typeof e4) {
        var t3 = i2._prime(e4);
        this.m = t3.p, this.prime = t3;
      } else
        r2(e4.gtn(1), "modulus must be greater than 1"), this.m = e4, this.prime = null;
    }
    function B2(e4) {
      x2.call(this, e4), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new i2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m2.prototype._tmp = function() {
      var e4 = new i2(null);
      return e4.words = new Array(Math.ceil(this.n / 13)), e4;
    }, m2.prototype.ireduce = function(e4) {
      var t3, r3 = e4;
      do {
        this.split(r3, this.tmp), t3 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
      } while (t3 > this.n);
      var n3 = t3 < this.n ? -1 : r3.ucmp(this.p);
      return 0 === n3 ? (r3.words[0] = 0, r3.length = 1) : n3 > 0 ? r3.isub(this.p) : void 0 !== r3.strip ? r3.strip() : r3._strip(), r3;
    }, m2.prototype.split = function(e4, t3) {
      e4.iushrn(this.n, 0, t3);
    }, m2.prototype.imulK = function(e4) {
      return e4.imul(this.k);
    }, n2(w2, m2), w2.prototype.split = function(e4, t3) {
      for (var r3 = 4194303, n3 = Math.min(e4.length, 9), i3 = 0; i3 < n3; i3++)
        t3.words[i3] = e4.words[i3];
      if (t3.length = n3, e4.length <= 9)
        return e4.words[0] = 0, void (e4.length = 1);
      var o3 = e4.words[9];
      for (t3.words[t3.length++] = o3 & r3, i3 = 10; i3 < e4.length; i3++) {
        var s3 = 0 | e4.words[i3];
        e4.words[i3 - 10] = (s3 & r3) << 4 | o3 >>> 22, o3 = s3;
      }
      e4.words[i3 - 10] = o3 >>>= 22, e4.length -= 0 === o3 && e4.length > 10 ? 10 : 9;
    }, w2.prototype.imulK = function(e4) {
      e4.words[e4.length] = 0, e4.words[e4.length + 1] = 0, e4.length += 2;
      for (var t3 = 0, r3 = 0; r3 < e4.length; r3++) {
        var n3 = 0 | e4.words[r3];
        e4.words[r3] = 67108863 & (t3 += 977 * n3), t3 = 64 * n3 + (t3 / 67108864 | 0);
      }
      return 0 === e4.words[e4.length - 1] && (e4.length--, 0 === e4.words[e4.length - 1] && e4.length--), e4;
    }, n2(b2, m2), n2(v2, m2), n2(E2, m2), E2.prototype.imulK = function(e4) {
      for (var t3 = 0, r3 = 0; r3 < e4.length; r3++) {
        var n3 = 19 * (0 | e4.words[r3]) + t3, i3 = 67108863 & n3;
        n3 >>>= 26, e4.words[r3] = i3, t3 = n3;
      }
      return 0 !== t3 && (e4.words[e4.length++] = t3), e4;
    }, i2._prime = function(e4) {
      if (g2[e4])
        return g2[e4];
      var t3;
      if ("k256" === e4)
        t3 = new w2();
      else if ("p224" === e4)
        t3 = new b2();
      else if ("p192" === e4)
        t3 = new v2();
      else {
        if ("p25519" !== e4)
          throw new Error("Unknown prime " + e4);
        t3 = new E2();
      }
      return g2[e4] = t3, t3;
    }, x2.prototype._verify1 = function(e4) {
      r2(0 === e4.negative, "red works only with positives"), r2(e4.red, "red works only with red numbers");
    }, x2.prototype._verify2 = function(e4, t3) {
      r2(0 == (e4.negative | t3.negative), "red works only with positives"), r2(e4.red && e4.red === t3.red, "red works only with red numbers");
    }, x2.prototype.imod = function(e4) {
      return this.prime ? this.prime.ireduce(e4)._forceRed(this) : e4.umod(this.m)._forceRed(this);
    }, x2.prototype.neg = function(e4) {
      return e4.isZero() ? e4.clone() : this.m.sub(e4)._forceRed(this);
    }, x2.prototype.add = function(e4, t3) {
      this._verify2(e4, t3);
      var r3 = e4.add(t3);
      return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
    }, x2.prototype.iadd = function(e4, t3) {
      this._verify2(e4, t3);
      var r3 = e4.iadd(t3);
      return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
    }, x2.prototype.sub = function(e4, t3) {
      this._verify2(e4, t3);
      var r3 = e4.sub(t3);
      return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
    }, x2.prototype.isub = function(e4, t3) {
      this._verify2(e4, t3);
      var r3 = e4.isub(t3);
      return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
    }, x2.prototype.shl = function(e4, t3) {
      return this._verify1(e4), this.imod(e4.ushln(t3));
    }, x2.prototype.imul = function(e4, t3) {
      return this._verify2(e4, t3), this.imod(e4.imul(t3));
    }, x2.prototype.mul = function(e4, t3) {
      return this._verify2(e4, t3), this.imod(e4.mul(t3));
    }, x2.prototype.isqr = function(e4) {
      return this.imul(e4, e4.clone());
    }, x2.prototype.sqr = function(e4) {
      return this.mul(e4, e4);
    }, x2.prototype.sqrt = function(e4) {
      if (e4.isZero())
        return e4.clone();
      var t3 = this.m.andln(3);
      if (r2(t3 % 2 == 1), 3 === t3) {
        var n3 = this.m.add(new i2(1)).iushrn(2);
        return this.pow(e4, n3);
      }
      for (var o3 = this.m.subn(1), s3 = 0; !o3.isZero() && 0 === o3.andln(1); )
        s3++, o3.iushrn(1);
      r2(!o3.isZero());
      var a3 = new i2(1).toRed(this), u3 = a3.redNeg(), h3 = this.m.subn(1).iushrn(1), f3 = this.m.bitLength();
      for (f3 = new i2(2 * f3 * f3).toRed(this); 0 !== this.pow(f3, h3).cmp(u3); )
        f3.redIAdd(u3);
      for (var c3 = this.pow(f3, o3), l3 = this.pow(e4, o3.addn(1).iushrn(1)), d3 = this.pow(e4, o3), p3 = s3; 0 !== d3.cmp(a3); ) {
        for (var y3 = d3, g3 = 0; 0 !== y3.cmp(a3); g3++)
          y3 = y3.redSqr();
        r2(g3 < p3);
        var m3 = this.pow(c3, new i2(1).iushln(p3 - g3 - 1));
        l3 = l3.redMul(m3), c3 = m3.redSqr(), d3 = d3.redMul(c3), p3 = g3;
      }
      return l3;
    }, x2.prototype.invm = function(e4) {
      var t3 = e4._invmp(this.m);
      return 0 !== t3.negative ? (t3.negative = 0, this.imod(t3).redNeg()) : this.imod(t3);
    }, x2.prototype.pow = function(e4, t3) {
      if (t3.isZero())
        return new i2(1).toRed(this);
      if (0 === t3.cmpn(1))
        return e4.clone();
      var r3 = new Array(16);
      r3[0] = new i2(1).toRed(this), r3[1] = e4;
      for (var n3 = 2; n3 < r3.length; n3++)
        r3[n3] = this.mul(r3[n3 - 1], e4);
      var o3 = r3[0], s3 = 0, a3 = 0, u3 = t3.bitLength() % 26;
      for (0 === u3 && (u3 = 26), n3 = t3.length - 1; n3 >= 0; n3--) {
        for (var h3 = t3.words[n3], f3 = u3 - 1; f3 >= 0; f3--) {
          var c3 = h3 >> f3 & 1;
          o3 !== r3[0] && (o3 = this.sqr(o3)), 0 !== c3 || 0 !== s3 ? (s3 <<= 1, s3 |= c3, (4 == ++a3 || 0 === n3 && 0 === f3) && (o3 = this.mul(o3, r3[s3]), a3 = 0, s3 = 0)) : a3 = 0;
        }
        u3 = 26;
      }
      return o3;
    }, x2.prototype.convertTo = function(e4) {
      var t3 = e4.umod(this.m);
      return t3 === e4 ? t3.clone() : t3;
    }, x2.prototype.convertFrom = function(e4) {
      var t3 = e4.clone();
      return t3.red = null, t3;
    }, i2.mont = function(e4) {
      return new B2(e4);
    }, n2(B2, x2), B2.prototype.convertTo = function(e4) {
      return this.imod(e4.ushln(this.shift));
    }, B2.prototype.convertFrom = function(e4) {
      var t3 = this.imod(e4.mul(this.rinv));
      return t3.red = null, t3;
    }, B2.prototype.imul = function(e4, t3) {
      if (e4.isZero() || t3.isZero())
        return e4.words[0] = 0, e4.length = 1, e4;
      var r3 = e4.imul(t3), n3 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i3 = r3.isub(n3).iushrn(this.shift), o3 = i3;
      return i3.cmp(this.m) >= 0 ? o3 = i3.isub(this.m) : i3.cmpn(0) < 0 && (o3 = i3.iadd(this.m)), o3._forceRed(this);
    }, B2.prototype.mul = function(e4, t3) {
      if (e4.isZero() || t3.isZero())
        return new i2(0)._forceRed(this);
      var r3 = e4.mul(t3), n3 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), o3 = r3.isub(n3).iushrn(this.shift), s3 = o3;
      return o3.cmp(this.m) >= 0 ? s3 = o3.isub(this.m) : o3.cmpn(0) < 0 && (s3 = o3.iadd(this.m)), s3._forceRed(this);
    }, B2.prototype.invm = function(e4) {
      return this.imod(e4._invmp(this.m).mul(this.r2))._forceRed(this);
    };
  }(e2, pe);
});
var zs = ye(function(e2, t2) {
  var r2 = pe && pe.__importDefault || function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.rawEncode = t2.parseNumber = t2.solidityPack = void 0;
  const n2 = r2(Ds);
  function i2(e3) {
    return e3.lastIndexOf("]") === e3.length - 1;
  }
  function o2(e3) {
    const t3 = e3.match(/(.*)\[(.*?)\]$/u);
    return t3 ? "" === t3[2] ? "dynamic" : parseInt(t3[2], 10) : null;
  }
  function s2(e3) {
    return parseInt(/^\D+(\d+)$/u.exec(e3)[1], 10);
  }
  function a2(e3) {
    const t3 = typeof e3;
    if ("string" === t3)
      return (0, ks.isHexPrefixed)(e3) ? new n2.default(Ms(e3), 16) : new n2.default(e3, 10);
    if ("number" === t3)
      return new n2.default(e3);
    if (e3.toArray)
      return e3;
    throw new Error("Argument is not a number");
  }
  function u2(e3, t3, r3) {
    let n3, h3;
    if (i2(e3)) {
      const r4 = e3.replace(/\[.*?\]/u, "");
      if (!i2(r4)) {
        const r5 = o2(e3);
        if ("dynamic" !== r5 && 0 !== r5 && t3.length > r5)
          throw new Error(`Elements exceed array size: ${r5}`);
      }
      const n4 = t3.map(function(e4) {
        return u2(r4, e4, 256);
      });
      return Buffer.concat(n4);
    }
    if ("bytes" === e3)
      return t3;
    if ("string" === e3)
      return Buffer.from(t3, "utf8");
    if ("bool" === e3) {
      r3 = r3 || 8;
      const e4 = Array(r3 / 4).join("0");
      return Buffer.from(t3 ? `${e4}1` : `${e4}0`, "hex");
    }
    if ("address" === e3) {
      let e4 = 20;
      return r3 && (e4 = r3 / 8), (0, ks.setLengthLeft)((0, ks.toBuffer)(t3), e4);
    }
    if (e3.startsWith("bytes")) {
      if (n3 = s2(e3), n3 < 1 || n3 > 32)
        throw new Error(`Invalid bytes<N> width: ${n3}`);
      return "number" == typeof t3 && (t3 = (0, Ps.normalize)(t3)), (0, ks.setLengthRight)((0, ks.toBuffer)(t3), n3);
    }
    if (e3.startsWith("uint")) {
      if (n3 = s2(e3), n3 % 8 || n3 < 8 || n3 > 256)
        throw new Error(`Invalid uint<N> width: ${n3}`);
      if (h3 = a2(t3), h3.bitLength() > n3)
        throw new Error(`Supplied uint exceeds width: ${n3} vs ${h3.bitLength()}`);
      return r3 = r3 || n3, h3.toArrayLike(Buffer, "be", r3 / 8);
    }
    if (e3.startsWith("int")) {
      if (n3 = s2(e3), n3 % 8 || n3 < 8 || n3 > 256)
        throw new Error(`Invalid int<N> width: ${n3}`);
      if (h3 = a2(t3), h3.bitLength() > n3)
        throw new Error(`Supplied int exceeds width: ${n3} vs ${h3.bitLength()}`);
      return r3 = r3 || n3, h3.toTwos(n3).toArrayLike(Buffer, "be", r3 / 8);
    }
    throw new Error(`Unsupported or invalid type: ${e3}`);
  }
  function h2(e3) {
    return e3.startsWith("int[") ? `int256${e3.slice(3)}` : "int" === e3 ? "int256" : e3.startsWith("uint[") ? `uint256${e3.slice(4)}` : "uint" === e3 ? "uint256" : e3.startsWith("fixed[") ? `fixed128x128${e3.slice(5)}` : "fixed" === e3 ? "fixed128x128" : e3.startsWith("ufixed[") ? `ufixed128x128${e3.slice(6)}` : "ufixed" === e3 ? "ufixed128x128" : e3;
  }
  function f2(e3, t3) {
    let r3, u3, h3, c3;
    if ("address" === e3)
      return f2("uint160", a2(t3));
    if ("bool" === e3)
      return f2("uint8", t3 ? 1 : 0);
    if ("string" === e3)
      return f2("bytes", Buffer.from(t3, "utf8"));
    if (i2(e3)) {
      if (void 0 === t3.length)
        throw new Error("Not an array?");
      if (r3 = o2(e3), "dynamic" !== r3 && 0 !== r3 && t3.length > r3)
        throw new Error(`Elements exceed array size: ${r3}`);
      for (c3 in h3 = [], e3 = e3.slice(0, e3.lastIndexOf("[")), "string" == typeof t3 && (t3 = JSON.parse(t3)), t3)
        Object.prototype.hasOwnProperty.call(t3, c3) && h3.push(f2(e3, t3[c3]));
      if ("dynamic" === r3) {
        const e4 = f2("uint256", t3.length);
        h3.unshift(e4);
      }
      return Buffer.concat(h3);
    }
    if ("bytes" === e3)
      return t3 = Buffer.from(t3), h3 = Buffer.concat([f2("uint256", t3.length), t3]), t3.length % 32 != 0 && (h3 = Buffer.concat([h3, (0, ks.zeros)(32 - t3.length % 32)])), h3;
    if (e3.startsWith("bytes")) {
      if (r3 = s2(e3), r3 < 1 || r3 > 32)
        throw new Error(`Invalid bytes<N> width: ${r3}`);
      return "number" == typeof t3 && (t3 = (0, Ps.normalize)(t3)), (0, ks.setLengthRight)((0, ks.toBuffer)(t3), 32);
    }
    if (e3.startsWith("uint")) {
      if (r3 = s2(e3), r3 % 8 || r3 < 8 || r3 > 256)
        throw new Error(`Invalid uint<N> width: ${r3}`);
      if (u3 = a2(t3), u3.bitLength() > r3)
        throw new Error(`Supplied uint exceeds width: ${r3} vs ${u3.bitLength()}`);
      if (u3 < 0)
        throw new Error("Supplied uint is negative");
      return u3.toArrayLike(Buffer, "be", 32);
    }
    if (e3.startsWith("int")) {
      if (r3 = s2(e3), r3 % 8 || r3 < 8 || r3 > 256)
        throw new Error(`Invalid int<N> width: ${r3}`);
      if (u3 = a2(t3), u3.bitLength() > r3)
        throw new Error(`Supplied int exceeds width: ${r3} vs ${u3.bitLength()}`);
      return u3.toTwos(256).toArrayLike(Buffer, "be", 32);
    }
    if (e3.startsWith("ufixed")) {
      if (r3 = l2(e3), u3 = a2(t3), u3 < 0)
        throw new Error("Supplied ufixed is negative");
      return f2("uint256", u3.mul(new n2.default(2).pow(new n2.default(r3[1]))));
    }
    if (e3.startsWith("fixed"))
      return r3 = l2(e3), f2("int256", a2(t3).mul(new n2.default(2).pow(new n2.default(r3[1]))));
    throw new Error(`Unsupported or invalid type: ${e3}`);
  }
  function c2(e3) {
    return "string" === e3 || "bytes" === e3 || "dynamic" === o2(e3);
  }
  function l2(e3) {
    const t3 = /^\D+(\d+)x(\d+)$/u.exec(e3);
    return [parseInt(t3[1], 10), parseInt(t3[2], 10)];
  }
  t2.solidityPack = function(e3, t3) {
    if (e3.length !== t3.length)
      throw new Error("Number of types are not matching the values");
    const r3 = [];
    for (let n3 = 0; n3 < e3.length; n3++) {
      const i3 = h2(e3[n3]);
      r3.push(u2(i3, t3[n3], null));
    }
    return Buffer.concat(r3);
  }, t2.parseNumber = a2, t2.rawEncode = function(e3, t3) {
    const r3 = [], n3 = [];
    let s3 = 0;
    e3.forEach(function(e4) {
      if (i2(e4)) {
        const t4 = o2(e4);
        s3 += "dynamic" !== t4 ? 32 * t4 : 32;
      } else
        s3 += 32;
    });
    for (let i3 = 0; i3 < e3.length; i3++) {
      const o3 = h2(e3[i3]), a3 = f2(o3, t3[i3]);
      c2(o3) ? (r3.push(f2("uint256", s3)), n3.push(a3), s3 += a3.length) : r3.push(a3);
    }
    return Buffer.concat(r3.concat(n3));
  };
});
var $s = ye(function(e2, t2) {
  var r2;
  function n2(e3, t3) {
    if (!Object.keys(r2).includes(e3))
      throw new Error(`Invalid version: '${e3}'`);
    if (t3 && !t3.includes(e3))
      throw new Error(`SignTypedDataVersion not allowed: '${e3}'. Allowed versions are: ${t3.join(", ")}`);
  }
  function i2(e3, t3, s3, a3, u3) {
    if (n2(u3, [r2.V3, r2.V4]), void 0 !== e3[s3])
      return ["bytes32", u3 === r2.V4 && null == a3 ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, ks.arrToBufArr)((0, Ji.keccak256)(o2(s3, a3, e3, u3)))];
    if (void 0 === a3)
      throw new Error(`missing value for field ${t3} of type ${s3}`);
    if ("bytes" === s3)
      return a3 = "number" == typeof a3 ? (0, Ps.numberToBuffer)(a3) : Cs(a3) ? Buffer.from((a3.length % 2 ? "0" : "") + a3.slice(2), "hex") : Buffer.from(a3, "utf8"), ["bytes32", (0, ks.arrToBufArr)((0, Ji.keccak256)(a3))];
    if ("string" === s3)
      return a3 = "number" == typeof a3 ? (0, Ps.numberToBuffer)(a3) : Buffer.from(null != a3 ? a3 : "", "utf8"), ["bytes32", (0, ks.arrToBufArr)((0, Ji.keccak256)(a3))];
    if (s3.lastIndexOf("]") === s3.length - 1) {
      if (u3 === r2.V3)
        throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
      const n3 = s3.slice(0, s3.lastIndexOf("[")), o3 = a3.map((r3) => i2(e3, t3, n3, r3, u3));
      return ["bytes32", (0, ks.arrToBufArr)((0, Ji.keccak256)((0, zs.rawEncode)(o3.map(([e4]) => e4), o3.map(([, e4]) => e4))))];
    }
    return [s3, a3];
  }
  function o2(e3, t3, o3, s3) {
    n2(s3, [r2.V3, r2.V4]);
    const a3 = ["bytes32"], u3 = [h2(e3, o3)];
    for (const n3 of o3[e3]) {
      if (s3 === r2.V3 && void 0 === t3[n3.name])
        continue;
      const [e4, h3] = i2(o3, n3.name, n3.type, t3[n3.name], s3);
      a3.push(e4), u3.push(h3);
    }
    return (0, zs.rawEncode)(a3, u3);
  }
  function s2(e3, t3) {
    let r3 = "";
    const n3 = a2(e3, t3);
    n3.delete(e3);
    const i3 = [e3, ...Array.from(n3).sort()];
    for (const e4 of i3) {
      if (!t3[e4])
        throw new Error(`No type definition specified: ${e4}`);
      r3 += `${e4}(${t3[e4].map(({ name: e5, type: t4 }) => `${t4} ${e5}`).join(",")})`;
    }
    return r3;
  }
  function a2(e3, t3, r3 = /* @__PURE__ */ new Set()) {
    if ([e3] = e3.match(/^\w*/u), r3.has(e3) || void 0 === t3[e3])
      return r3;
    r3.add(e3);
    for (const n3 of t3[e3])
      a2(n3.type, t3, r3);
    return r3;
  }
  function u2(e3, t3, i3, s3) {
    return n2(s3, [r2.V3, r2.V4]), (0, ks.arrToBufArr)((0, Ji.keccak256)(o2(e3, t3, i3, s3)));
  }
  function h2(e3, t3) {
    const r3 = Buffer.from(s2(e3, t3), "utf-8");
    return (0, ks.arrToBufArr)((0, Ji.keccak256)(r3));
  }
  function f2(e3) {
    const r3 = {};
    for (const n3 in t2.TYPED_MESSAGE_SCHEMA.properties)
      e3[n3] && (r3[n3] = e3[n3]);
    return "types" in r3 && (r3.types = Object.assign({ EIP712Domain: [] }, r3.types)), r3;
  }
  function c2(e3) {
    const t3 = new Error("Expect argument to be non-empty array");
    if ("object" != typeof e3 || !("length" in e3) || !e3.length)
      throw t3;
    const r3 = e3.map(function(e4) {
      return "bytes" !== e4.type ? e4.value : (0, Ps.legacyToBuffer)(e4.value);
    }), n3 = e3.map(function(e4) {
      return e4.type;
    }), i3 = e3.map(function(e4) {
      if (!e4.name)
        throw t3;
      return `${e4.type} ${e4.name}`;
    });
    return (0, ks.arrToBufArr)((0, Ji.keccak256)((0, zs.solidityPack)(["bytes32", "bytes32"], [(0, Ji.keccak256)((0, zs.solidityPack)(new Array(e3.length).fill("string"), i3)), (0, Ji.keccak256)((0, zs.solidityPack)(n3, r3))])));
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.recoverTypedSignature = t2.signTypedData = t2.typedSignatureHash = t2.TypedDataUtils = t2.TYPED_MESSAGE_SCHEMA = t2.SignTypedDataVersion = void 0, function(e3) {
    e3.V1 = "V1", e3.V3 = "V3", e3.V4 = "V4";
  }(r2 = t2.SignTypedDataVersion || (t2.SignTypedDataVersion = {})), t2.TYPED_MESSAGE_SCHEMA = { type: "object", properties: { types: { type: "object", additionalProperties: { type: "array", items: { type: "object", properties: { name: { type: "string" }, type: { type: "string" } }, required: ["name", "type"] } } }, primaryType: { type: "string" }, domain: { type: "object" }, message: { type: "object" } }, required: ["types", "primaryType", "domain", "message"] }, t2.TypedDataUtils = { encodeData: o2, encodeType: s2, findTypeDependencies: a2, hashStruct: u2, hashType: h2, sanitizeData: f2, eip712Hash: function(e3, t3) {
    n2(t3, [r2.V3, r2.V4]);
    const i3 = f2(e3), o3 = [Buffer.from("1901", "hex")];
    return o3.push(u2("EIP712Domain", i3.domain, i3.types, t3)), "EIP712Domain" !== i3.primaryType && o3.push(u2(i3.primaryType, i3.message, i3.types, t3)), (0, ks.arrToBufArr)((0, Ji.keccak256)(Buffer.concat(o3)));
  } }, t2.typedSignatureHash = function(e3) {
    const t3 = c2(e3);
    return (0, ks.bufferToHex)(t3);
  }, t2.signTypedData = function({ privateKey: e3, data: i3, version: o3 }) {
    if (n2(o3), (0, Ps.isNullish)(i3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing private key parameter");
    const s3 = o3 === r2.V1 ? c2(i3) : t2.TypedDataUtils.eip712Hash(i3, o3), a3 = (0, ks.ecsign)(s3, e3);
    return (0, Ps.concatSig)((0, ks.toBuffer)(a3.v), a3.r, a3.s);
  }, t2.recoverTypedSignature = function({ data: e3, signature: i3, version: o3 }) {
    if (n2(o3), (0, Ps.isNullish)(e3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(i3))
      throw new Error("Missing signature parameter");
    const s3 = o3 === r2.V1 ? c2(e3) : t2.TypedDataUtils.eip712Hash(e3, o3), a3 = (0, Ps.recoverPublicKey)(s3, i3), u3 = (0, ks.publicToAddress)(a3);
    return (0, ks.bufferToHex)(u3);
  };
});
var Vs = ye(function(e2) {
  !function(t2, r2) {
    e2.exports ? e2.exports = r2() : (t2.nacl || (t2.nacl = {}), t2.nacl.util = r2());
  }(pe, function() {
    var e3 = {};
    function t2(e4) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(e4))
        throw new TypeError("invalid encoding");
    }
    return e3.decodeUTF8 = function(e4) {
      if ("string" != typeof e4)
        throw new TypeError("expected string");
      var t3, r2 = unescape(encodeURIComponent(e4)), n2 = new Uint8Array(r2.length);
      for (t3 = 0; t3 < r2.length; t3++)
        n2[t3] = r2.charCodeAt(t3);
      return n2;
    }, e3.encodeUTF8 = function(e4) {
      var t3, r2 = [];
      for (t3 = 0; t3 < e4.length; t3++)
        r2.push(String.fromCharCode(e4[t3]));
      return decodeURIComponent(escape(r2.join("")));
    }, "undefined" == typeof atob ? void 0 !== Buffer.from ? (e3.encodeBase64 = function(e4) {
      return Buffer.from(e4).toString("base64");
    }, e3.decodeBase64 = function(e4) {
      return t2(e4), new Uint8Array(Array.prototype.slice.call(Buffer.from(e4, "base64"), 0));
    }) : (e3.encodeBase64 = function(e4) {
      return new Buffer(e4).toString("base64");
    }, e3.decodeBase64 = function(e4) {
      return t2(e4), new Uint8Array(Array.prototype.slice.call(new Buffer(e4, "base64"), 0));
    }) : (e3.encodeBase64 = function(e4) {
      var t3, r2 = [], n2 = e4.length;
      for (t3 = 0; t3 < n2; t3++)
        r2.push(String.fromCharCode(e4[t3]));
      return btoa(r2.join(""));
    }, e3.decodeBase64 = function(e4) {
      t2(e4);
      var r2, n2 = atob(e4), i2 = new Uint8Array(n2.length);
      for (r2 = 0; r2 < n2.length; r2++)
        i2[r2] = n2.charCodeAt(r2);
      return i2;
    }), e3;
  });
});
var js = ye(function(e2, t2) {
  var r2 = pe && pe.__createBinding || (Object.create ? function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3);
    var i3 = Object.getOwnPropertyDescriptor(t3, r3);
    i3 && !("get" in i3 ? !t3.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, n3, i3);
  } : function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), e3[n3] = t3[r3];
  }), n2 = pe && pe.__setModuleDefault || (Object.create ? function(e3, t3) {
    Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
  } : function(e3, t3) {
    e3.default = t3;
  }), i2 = pe && pe.__importStar || function(e3) {
    if (e3 && e3.__esModule)
      return e3;
    var t3 = {};
    if (null != e3)
      for (var i3 in e3)
        "default" !== i3 && Object.prototype.hasOwnProperty.call(e3, i3) && r2(t3, e3, i3);
    return n2(t3, e3), t3;
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getEncryptionPublicKey = t2.decryptSafely = t2.decrypt = t2.encryptSafely = t2.encrypt = void 0;
  const o2 = i2(we), s2 = i2(Vs);
  function a2({ publicKey: e3, data: t3, version: r3 }) {
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing publicKey parameter");
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(r3))
      throw new Error("Missing version parameter");
    if ("x25519-xsalsa20-poly1305" === r3) {
      if ("string" != typeof t3)
        throw new Error("Message data must be given as a string");
      const r4 = o2.box.keyPair();
      let n3;
      try {
        n3 = s2.decodeBase64(e3);
      } catch (e4) {
        throw new Error("Bad public key");
      }
      const i3 = s2.decodeUTF8(t3), a3 = o2.randomBytes(o2.box.nonceLength), u3 = o2.box(i3, a3, n3, r4.secretKey);
      return { version: "x25519-xsalsa20-poly1305", nonce: s2.encodeBase64(a3), ephemPublicKey: s2.encodeBase64(r4.publicKey), ciphertext: s2.encodeBase64(u3) };
    }
    throw new Error("Encryption type/version not supported");
  }
  function u2({ encryptedData: e3, privateKey: t3 }) {
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing encryptedData parameter");
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing privateKey parameter");
    if ("x25519-xsalsa20-poly1305" === e3.version) {
      const r3 = h2(t3), n3 = o2.box.keyPair.fromSecretKey(r3).secretKey, i3 = s2.decodeBase64(e3.nonce), a3 = s2.decodeBase64(e3.ciphertext), u3 = s2.decodeBase64(e3.ephemPublicKey), f2 = o2.box.open(a3, i3, u3, n3);
      let c2;
      try {
        c2 = s2.encodeUTF8(f2);
      } catch (e4) {
        throw new Error("Decryption failed.");
      }
      if (c2)
        return c2;
      throw new Error("Decryption failed.");
    }
    throw new Error("Encryption type/version not supported.");
  }
  function h2(e3) {
    const t3 = Buffer.from(e3, "hex").toString("base64");
    return s2.decodeBase64(t3);
  }
  t2.encrypt = a2, t2.encryptSafely = function({ publicKey: e3, data: t3, version: r3 }) {
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing publicKey parameter");
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing data parameter");
    if ((0, Ps.isNullish)(r3))
      throw new Error("Missing version parameter");
    if ("object" == typeof t3 && "toJSON" in t3)
      throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
    const n3 = { data: t3, padding: "" }, i3 = Buffer.byteLength(JSON.stringify(n3), "utf-8") % 2048;
    let o3 = 0;
    return i3 > 0 && (o3 = 2048 - i3 - 16), n3.padding = "0".repeat(o3), a2({ publicKey: e3, data: JSON.stringify(n3), version: r3 });
  }, t2.decrypt = u2, t2.decryptSafely = function({ encryptedData: e3, privateKey: t3 }) {
    if ((0, Ps.isNullish)(e3))
      throw new Error("Missing encryptedData parameter");
    if ((0, Ps.isNullish)(t3))
      throw new Error("Missing privateKey parameter");
    return JSON.parse(u2({ encryptedData: e3, privateKey: t3 })).data;
  }, t2.getEncryptionPublicKey = function(e3) {
    const t3 = h2(e3), r3 = o2.box.keyPair.fromSecretKey(t3).publicKey;
    return s2.encodeBase64(r3);
  };
});
var Fs = ye(function(e2, t2) {
  var r2 = pe && pe.__createBinding || (Object.create ? function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3);
    var i2 = Object.getOwnPropertyDescriptor(t3, r3);
    i2 && !("get" in i2 ? !t3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, n3, i2);
  } : function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), e3[n3] = t3[r3];
  }), n2 = pe && pe.__exportStar || function(e3, t3) {
    for (var n3 in e3)
      "default" === n3 || Object.prototype.hasOwnProperty.call(t3, n3) || r2(t3, e3, n3);
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.normalize = t2.concatSig = void 0, n2(Rs, t2), n2($s, t2), n2(js, t2), Object.defineProperty(t2, "concatSig", { enumerable: true, get: function() {
    return Ps.concatSig;
  } }), Object.defineProperty(t2, "normalize", { enumerable: true, get: function() {
    return Ps.normalize;
  } });
});
var Hs = class {
  constructor(e2) {
    this.window = void 0, this.addr = void 0, this.publicKey = void 0, this.window = e2, this.addr = "", this.publicKey = void 0;
  }
  async connect() {
    if (0 == this.addr.length) {
      const e2 = await this.window.ethereum.request({ method: "eth_requestAccounts" });
      this.addr = e2[0], await this.generateAddr();
    }
  }
  getAddress() {
    return this.publicKey.toAddress();
  }
  getEvmAddress() {
    return this.addr;
  }
  getType() {
    return "MetaMask";
  }
  async generateAddr() {
    const e2 = { types: { EIP712Domain: [], Message: [{ name: "action", type: "string" }] }, domain: {}, primaryType: "Message", message: { action: "generate db3 addr" } }, t2 = JSON.stringify(e2), r2 = this.addr, n2 = await this.window.ethereum.request({ method: "eth_signTypedData_v3", params: [r2, t2] }), i2 = Fs.TypedDataUtils.eip712Hash(e2, Fs.SignTypedDataVersion.V3), { v: o2, r: s2, s: a2 } = ks.fromRpcSig(n2), u2 = this.calculateSigRecovery(o2), h2 = new Uint8Array(64);
    h2.set(s2, 0), h2.set(a2, 32);
    const f2 = pr(i2, h2, Number(u2), true);
    return this.publicKey = new Nr(f2), this.publicKey.toAddress();
  }
  async sign(e2) {
    const t2 = JSON.stringify(e2), r2 = this.addr, n2 = await this.window.ethereum.request({ method: "eth_signTypedData_v3", params: [r2, t2] }), i2 = Fs.TypedDataUtils.eip712Hash(e2, Fs.SignTypedDataVersion.V3), { v: o2, r: s2, s: a2 } = ks.fromRpcSig(n2), u2 = this.calculateSigRecovery(o2), h2 = new Uint8Array(64);
    h2.set(s2, 0), h2.set(a2, 32);
    const f2 = pr(i2, h2, Number(u2), true), c2 = new Uint8Array(99);
    return c2[0] = 1, c2.set(h2, 1), c2.set([Number(u2)], 65), c2.set(f2, 66), c2;
  }
  calculateSigRecovery(e2, t2) {
    return e2 === BigInt(0) || e2 === BigInt(1) ? e2 : void 0 === t2 ? e2 - BigInt(27) : e2 - (t2 * BigInt(2) + BigInt(35));
  }
};
!function(e2) {
  e2[e2.SettlementChain = 0] = "SettlementChain", e2[e2.StorageShardChain = 10] = "StorageShardChain", e2[e2.DvmComputingChain = 20] = "DvmComputingChain";
}(Is || (Is = {})), function(e2) {
  e2[e2.MainNet = 0] = "MainNet", e2[e2.TestNet = 10] = "TestNet", e2[e2.DevNet = 20] = "DevNet";
}(Os || (Os = {}));
var Ks = new class extends Y {
  constructor() {
    super("db3_base_proto.BroadcastMeta", [{ no: 1, name: "nonce", kind: "scalar", T: 4 }, { no: 2, name: "chain_id", kind: "enum", T: () => ["db3_base_proto.ChainId", Os] }, { no: 3, name: "chain_role", kind: "enum", T: () => ["db3_base_proto.ChainRole", Is] }]);
  }
}();
var Gs;
var qs;
!function(e2) {
  e2[e2.CreateDB = 0] = "CreateDB", e2[e2.AddCollection = 1] = "AddCollection", e2[e2.AddDocument = 2] = "AddDocument", e2[e2.DeleteDocument = 3] = "DeleteDocument", e2[e2.UpdateDocument = 4] = "UpdateDocument";
}(Gs || (Gs = {})), function(e2) {
  e2[e2.QuerySessionPayload = 0] = "QuerySessionPayload", e2[e2.DatabasePayload = 1] = "DatabasePayload", e2[e2.MintCreditsPayload = 2] = "MintCreditsPayload", e2[e2.TypedDataPayload = 3] = "TypedDataPayload";
}(qs || (qs = {}));
var Js = new class extends Y {
  constructor() {
    super("db3_mutation_proto.DatabaseMutation", [{ no: 1, name: "meta", kind: "message", T: () => Ks }, { no: 2, name: "action", kind: "enum", T: () => ["db3_mutation_proto.DatabaseAction", Gs] }, { no: 3, name: "db_address", kind: "scalar", T: 12 }, { no: 4, name: "collection_mutations", kind: "message", repeat: 1, T: () => Ws }, { no: 5, name: "document_mutations", kind: "message", repeat: 1, T: () => Zs }]);
  }
}();
var Ws = new class extends Y {
  constructor() {
    super("db3_mutation_proto.CollectionMutation", [{ no: 1, name: "index", kind: "message", repeat: 1, T: () => se }, { no: 2, name: "collection_name", kind: "scalar", T: 9 }]);
  }
}();
var Zs = new class extends Y {
  constructor() {
    super("db3_mutation_proto.DocumentMutation", [{ no: 1, name: "collection_name", kind: "scalar", T: 9 }, { no: 2, name: "documents", kind: "scalar", repeat: 2, T: 12 }, { no: 3, name: "ids", kind: "scalar", repeat: 2, T: 9 }, { no: 4, name: "masks", kind: "message", repeat: 1, T: () => Ys }]);
  }
}();
var Ys = new class extends Y {
  constructor() {
    super("db3_mutation_proto.DocumentMask", [{ no: 1, name: "fields", kind: "scalar", repeat: 2, T: 9 }]);
  }
}();
new class extends Y {
  constructor() {
    super("db3_mutation_proto.MintCreditsMutation", [{ no: 1, name: "chain_id", kind: "scalar", T: 13 }, { no: 2, name: "block_id", kind: "scalar", T: 4 }, { no: 3, name: "tx_id", kind: "scalar", T: 12 }, { no: 5, name: "to", kind: "scalar", T: 12 }, { no: 6, name: "amount", kind: "scalar", T: 4 }, { no: 7, name: "meta", kind: "message", T: () => Ks }]);
  }
}();
var Xs = new class extends Y {
  constructor() {
    super("db3_mutation_proto.WriteRequest", [{ no: 1, name: "signature", kind: "scalar", T: 12 }, { no: 2, name: "payload", kind: "scalar", T: 12 }, { no: 4, name: "payload_type", kind: "enum", T: () => ["db3_mutation_proto.PayloadType", qs] }]);
  }
}();
var Qs = class extends Error {
  constructor(e2, t2 = "UNKNOWN", r2) {
    super(e2), this.name = "RpcError", Object.setPrototypeOf(this, new.target.prototype), this.code = t2, this.meta = null != r2 ? r2 : {};
  }
  toString() {
    const e2 = [this.name + ": " + this.message];
    this.code && (e2.push(""), e2.push("Code: " + this.code)), this.serviceName && this.methodName && e2.push("Method: " + this.serviceName + "/" + this.methodName);
    let t2 = Object.entries(this.meta);
    if (t2.length) {
      e2.push(""), e2.push("Meta:");
      for (let [r2, n2] of t2)
        e2.push(`  ${r2}: ${n2}`);
    }
    return e2.join("\n");
  }
};
function ea(e2, t2) {
  if (!e2)
    return;
  let r2 = t2;
  for (let [t3, n2] of Object.entries(e2))
    r2[t3] = n2 instanceof Date ? new Date(n2.getTime()) : Array.isArray(n2) ? n2.concat() : n2;
}
var ta;
var ra;
var na;
!function(e2) {
  e2[e2.PENDING = 0] = "PENDING", e2[e2.REJECTED = 1] = "REJECTED", e2[e2.RESOLVED = 2] = "RESOLVED";
}(ta || (ta = {}));
var ia = class {
  constructor(e2 = true) {
    this._state = ta.PENDING, this._promise = new Promise((e3, t2) => {
      this._resolve = e3, this._reject = t2;
    }), e2 && this._promise.catch((e3) => {
    });
  }
  get state() {
    return this._state;
  }
  get promise() {
    return this._promise;
  }
  resolve(e2) {
    if (this.state !== ta.PENDING)
      throw new Error(`cannot resolve ${ta[this.state].toLowerCase()}`);
    this._resolve(e2), this._state = ta.RESOLVED;
  }
  reject(e2) {
    if (this.state !== ta.PENDING)
      throw new Error(`cannot reject ${ta[this.state].toLowerCase()}`);
    this._reject(e2), this._state = ta.REJECTED;
  }
  resolvePending(e2) {
    this._state === ta.PENDING && this.resolve(e2);
  }
  rejectPending(e2) {
    this._state === ta.PENDING && this.reject(e2);
  }
};
var oa = class {
  constructor() {
    this._lis = { nxt: [], msg: [], err: [], cmp: [] }, this._closed = false;
  }
  onNext(e2) {
    return this.addLis(e2, this._lis.nxt);
  }
  onMessage(e2) {
    return this.addLis(e2, this._lis.msg);
  }
  onError(e2) {
    return this.addLis(e2, this._lis.err);
  }
  onComplete(e2) {
    return this.addLis(e2, this._lis.cmp);
  }
  addLis(e2, t2) {
    return t2.push(e2), () => {
      let r2 = t2.indexOf(e2);
      r2 >= 0 && t2.splice(r2, 1);
    };
  }
  clearLis() {
    for (let e2 of Object.values(this._lis))
      e2.splice(0, e2.length);
  }
  get closed() {
    return false !== this._closed;
  }
  notifyNext(e2, t2, r2) {
    B((e2 ? 1 : 0) + (t2 ? 1 : 0) + (r2 ? 1 : 0) <= 1, "only one emission at a time"), e2 && this.notifyMessage(e2), t2 && this.notifyError(t2), r2 && this.notifyComplete();
  }
  notifyMessage(e2) {
    B(!this.closed, "stream is closed"), this.pushIt({ value: e2, done: false }), this._lis.msg.forEach((t2) => t2(e2)), this._lis.nxt.forEach((t2) => t2(e2, void 0, false));
  }
  notifyError(e2) {
    B(!this.closed, "stream is closed"), this._closed = e2, this.pushIt(e2), this._lis.err.forEach((t2) => t2(e2)), this._lis.nxt.forEach((t2) => t2(void 0, e2, false)), this.clearLis();
  }
  notifyComplete() {
    B(!this.closed, "stream is closed"), this._closed = true, this.pushIt({ value: null, done: true }), this._lis.cmp.forEach((e2) => e2()), this._lis.nxt.forEach((e2) => e2(void 0, void 0, true)), this.clearLis();
  }
  [Symbol.asyncIterator]() {
    return this._itState || (this._itState = { q: [] }), true === this._closed ? this.pushIt({ value: null, done: true }) : false !== this._closed && this.pushIt(this._closed), { next: () => {
      let e2 = this._itState;
      B(e2, "bad state"), B(!e2.p, "iterator contract broken");
      let t2 = e2.q.shift();
      return t2 ? "value" in t2 ? Promise.resolve(t2) : Promise.reject(t2) : (e2.p = new ia(), e2.p.promise);
    } };
  }
  pushIt(e2) {
    let t2 = this._itState;
    if (t2)
      if (t2.p) {
        const r2 = t2.p;
        B(r2.state == ta.PENDING, "iterator contract broken"), "value" in e2 ? r2.resolve(e2) : r2.reject(e2), delete t2.p;
      } else
        t2.q.push(e2);
  }
};
var sa = class {
  constructor(e2, t2, r2, n2, i2, o2, s2) {
    this.method = e2, this.requestHeaders = t2, this.request = r2, this.headers = n2, this.response = i2, this.status = o2, this.trailers = s2;
  }
  then(e2, t2) {
    return this.promiseFinished().then((t3) => e2 ? Promise.resolve(e2(t3)) : t3, (e3) => t2 ? Promise.resolve(t2(e3)) : Promise.reject(e3));
  }
  promiseFinished() {
    return e2 = this, r2 = function* () {
      let [e3, t3, r3, n2] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return { method: this.method, requestHeaders: this.requestHeaders, request: this.request, headers: e3, response: t3, status: r3, trailers: n2 };
    }, new ((t2 = void 0) || (t2 = Promise))(function(n2, i2) {
      function o2(e3) {
        try {
          a2(r2.next(e3));
        } catch (e4) {
          i2(e4);
        }
      }
      function s2(e3) {
        try {
          a2(r2.throw(e3));
        } catch (e4) {
          i2(e4);
        }
      }
      function a2(e3) {
        var r3;
        e3.done ? n2(e3.value) : (r3 = e3.value, r3 instanceof t2 ? r3 : new t2(function(e4) {
          e4(r3);
        })).then(o2, s2);
      }
      a2((r2 = r2.apply(e2, [])).next());
    });
    var e2, t2, r2;
  }
};
var aa = class {
  constructor(e2, t2, r2, n2, i2, o2, s2) {
    this.method = e2, this.requestHeaders = t2, this.request = r2, this.headers = n2, this.responses = i2, this.status = o2, this.trailers = s2;
  }
  then(e2, t2) {
    return this.promiseFinished().then((t3) => e2 ? Promise.resolve(e2(t3)) : t3, (e3) => t2 ? Promise.resolve(t2(e3)) : Promise.reject(e3));
  }
  promiseFinished() {
    return e2 = this, r2 = function* () {
      let [e3, t3, r3] = yield Promise.all([this.headers, this.status, this.trailers]);
      return { method: this.method, requestHeaders: this.requestHeaders, request: this.request, headers: e3, status: t3, trailers: r3 };
    }, new ((t2 = void 0) || (t2 = Promise))(function(n2, i2) {
      function o2(e3) {
        try {
          a2(r2.next(e3));
        } catch (e4) {
          i2(e4);
        }
      }
      function s2(e3) {
        try {
          a2(r2.throw(e3));
        } catch (e4) {
          i2(e4);
        }
      }
      function a2(e3) {
        var r3;
        e3.done ? n2(e3.value) : (r3 = e3.value, r3 instanceof t2 ? r3 : new t2(function(e4) {
          e4(r3);
        })).then(o2, s2);
      }
      a2((r2 = r2.apply(e2, [])).next());
    });
    var e2, t2, r2;
  }
};
function ua(e2, t2, r2, n2, i2) {
  var o2, s2, a2, u2;
  if ("unary" == e2) {
    let e3 = (e4, r3, n3) => t2.unary(e4, r3, n3);
    for (const t3 of (null !== (o2 = n2.interceptors) && void 0 !== o2 ? o2 : []).filter((e4) => e4.interceptUnary).reverse()) {
      const r3 = e3;
      e3 = (e4, n3, i3) => t3.interceptUnary(r3, e4, n3, i3);
    }
    return e3(r2, i2, n2);
  }
  if ("serverStreaming" == e2) {
    let e3 = (e4, r3, n3) => t2.serverStreaming(e4, r3, n3);
    for (const t3 of (null !== (s2 = n2.interceptors) && void 0 !== s2 ? s2 : []).filter((e4) => e4.interceptServerStreaming).reverse()) {
      const r3 = e3;
      e3 = (e4, n3, i3) => t3.interceptServerStreaming(r3, e4, n3, i3);
    }
    return e3(r2, i2, n2);
  }
  if ("clientStreaming" == e2) {
    let e3 = (e4, r3) => t2.clientStreaming(e4, r3);
    for (const t3 of (null !== (a2 = n2.interceptors) && void 0 !== a2 ? a2 : []).filter((e4) => e4.interceptClientStreaming).reverse()) {
      const r3 = e3;
      e3 = (e4, n3) => t3.interceptClientStreaming(r3, e4, n3);
    }
    return e3(r2, n2);
  }
  if ("duplex" == e2) {
    let e3 = (e4, r3) => t2.duplex(e4, r3);
    for (const t3 of (null !== (u2 = n2.interceptors) && void 0 !== u2 ? u2 : []).filter((e4) => e4.interceptDuplex).reverse()) {
      const r3 = e3;
      e3 = (e4, n3) => t3.interceptDuplex(r3, e4, n3);
    }
    return e3(r2, n2);
  }
  !function(e3, t3) {
    throw new Error("Unexpected object: " + e3);
  }(e2);
}
function ha(e2, t2, r2, n2, i2) {
  if (n2)
    for (let [t3, r3] of Object.entries(n2))
      if ("string" == typeof r3)
        e2.append(t3, r3);
      else
        for (let n3 of r3)
          e2.append(t3, n3);
  if (e2.set("Content-Type", "text" === t2 ? "application/grpc-web-text" : "application/grpc-web+proto"), "text" == t2 && e2.set("Accept", "application/grpc-web-text"), e2.set("X-Grpc-Web", "1"), i2 && e2.set("X-User-Agent", i2), "number" == typeof r2) {
    if (r2 <= 0)
      throw new Qs(`timeout ${r2} ms exceeded`, ra[ra.DEADLINE_EXCEEDED]);
    e2.set("grpc-timeout", `${r2}m`);
  } else if (r2) {
    const t3 = r2.getTime(), n3 = Date.now();
    if (t3 <= n3)
      throw new Qs(`deadline ${r2} exceeded`, ra[ra.DEADLINE_EXCEEDED]);
    e2.set("grpc-timeout", t3 - n3 + "m");
  }
  return e2;
}
function fa(e2, t2) {
  let r2 = new Uint8Array(5 + e2.length);
  r2[0] = na.DATA;
  for (let t3 = e2.length, n2 = 4; n2 > 0; n2--)
    r2[n2] = t3 % 256, t3 >>>= 8;
  return r2.set(e2, 5), "binary" === t2 ? r2 : i(r2);
}
function ca(e2, t2, r2) {
  if (1 === arguments.length) {
    let t3, r3 = e2;
    try {
      t3 = r3.type;
    } catch (e3) {
    }
    switch (t3) {
      case "error":
      case "opaque":
      case "opaqueredirect":
        throw new Qs(`fetch response type ${r3.type}`, ra[ra.UNKNOWN]);
    }
    return ca(wa(r3.headers), r3.status, r3.statusText);
  }
  let n2 = e2, i2 = t2 >= 200 && t2 < 300, o2 = ma(n2), [s2, a2] = ga(n2);
  return void 0 !== s2 && s2 !== ra.OK || i2 || (s2 = ba(t2), a2 = r2), [s2, a2, o2];
}
function la(e2) {
  let t2 = function(e3) {
    let t3 = {};
    for (let r3 of String.fromCharCode.apply(String, e3).trim().split("\r\n")) {
      if ("" == r3)
        continue;
      let [e4, ...n3] = r3.split(":");
      const i3 = n3.join(":").trim();
      e4 = e4.trim();
      let o2 = t3[e4];
      "string" == typeof o2 ? t3[e4] = [o2, i3] : Array.isArray(o2) ? o2.push(i3) : t3[e4] = i3;
    }
    return t3;
  }(e2), [r2, n2] = ga(t2), i2 = ma(t2);
  return [null != r2 ? r2 : ra.OK, n2, i2];
}
function da(e2, t2, r2) {
  return i2 = this, s2 = function* () {
    let i3, o3 = "", s3 = new Uint8Array(0), a2 = function(e3) {
      switch (e3) {
        case "application/grpc-web-text":
        case "application/grpc-web-text+proto":
          return "text";
        case "application/grpc-web":
        case "application/grpc-web+proto":
          return "binary";
        case void 0:
        case null:
          throw new Qs("missing response content type", ra[ra.INTERNAL]);
        default:
          throw new Qs("unexpected response content type: " + e3, ra[ra.INTERNAL]);
      }
    }(t2);
    if (pa(e2)) {
      let t3 = e2.getReader();
      i3 = { next: () => t3.read() };
    } else
      i3 = e2[Symbol.asyncIterator]();
    for (; ; ) {
      let e3 = yield i3.next();
      if (void 0 !== e3.value) {
        if ("text" === a2) {
          for (let t4 = 0; t4 < e3.value.length; t4++)
            o3 += String.fromCharCode(e3.value[t4]);
          let t3 = o3.length - o3.length % 4;
          if (0 === t3)
            continue;
          s3 = ya(s3, n(o3.substring(0, t3))), o3 = o3.substring(t3);
        } else
          s3 = ya(s3, e3.value);
        for (; s3.length >= 5 && s3[0] === na.DATA; ) {
          let e4 = 0;
          for (let t3 = 1; t3 < 5; t3++)
            e4 = (e4 << 8) + s3[t3];
          if (!(s3.length - 5 >= e4))
            break;
          r2(na.DATA, s3.subarray(5, 5 + e4)), s3 = s3.subarray(5 + e4);
        }
      }
      if (e3.done) {
        if (0 === s3.length)
          break;
        if (s3[0] !== na.TRAILER || s3.length < 5)
          throw new Qs("premature EOF", ra[ra.DATA_LOSS]);
        r2(na.TRAILER, s3.subarray(5));
        break;
      }
    }
  }, new ((o2 = void 0) || (o2 = Promise))(function(e3, t3) {
    function r3(e4) {
      try {
        a2(s2.next(e4));
      } catch (e5) {
        t3(e5);
      }
    }
    function n2(e4) {
      try {
        a2(s2.throw(e4));
      } catch (e5) {
        t3(e5);
      }
    }
    function a2(t4) {
      var i3;
      t4.done ? e3(t4.value) : (i3 = t4.value, i3 instanceof o2 ? i3 : new o2(function(e4) {
        e4(i3);
      })).then(r3, n2);
    }
    a2((s2 = s2.apply(i2, [])).next());
  });
  var i2, o2, s2;
}
!function(e2) {
  e2[e2.OK = 0] = "OK", e2[e2.CANCELLED = 1] = "CANCELLED", e2[e2.UNKNOWN = 2] = "UNKNOWN", e2[e2.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", e2[e2.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", e2[e2.NOT_FOUND = 5] = "NOT_FOUND", e2[e2.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", e2[e2.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", e2[e2.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", e2[e2.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", e2[e2.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", e2[e2.ABORTED = 10] = "ABORTED", e2[e2.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", e2[e2.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", e2[e2.INTERNAL = 13] = "INTERNAL", e2[e2.UNAVAILABLE = 14] = "UNAVAILABLE", e2[e2.DATA_LOSS = 15] = "DATA_LOSS";
}(ra || (ra = {})), function(e2) {
  e2[e2.DATA = 0] = "DATA", e2[e2.TRAILER = 128] = "TRAILER";
}(na || (na = {}));
var pa = (e2) => "function" == typeof e2.getReader;
function ya(e2, t2) {
  let r2 = new Uint8Array(e2.length + t2.length);
  return r2.set(e2), r2.set(t2, e2.length), r2;
}
function ga(e2) {
  let t2, r2, n2 = e2["grpc-message"];
  if (void 0 !== n2) {
    if (Array.isArray(n2))
      return [ra.INTERNAL, "invalid grpc-web message"];
    r2 = n2;
  }
  let i2 = e2["grpc-status"];
  if (void 0 !== i2) {
    if (Array.isArray(i2))
      return [ra.INTERNAL, "invalid grpc-web status"];
    if (t2 = parseInt(i2, 10), void 0 === ra[t2])
      return [ra.INTERNAL, "invalid grpc-web status"];
  }
  return [t2, r2];
}
function ma(e2) {
  let t2 = {};
  for (let [r2, n2] of Object.entries(e2))
    switch (r2) {
      case "grpc-message":
      case "grpc-status":
      case "content-type":
        break;
      default:
        t2[r2] = n2;
    }
  return t2;
}
function wa(e2) {
  let t2 = {};
  return e2.forEach((e3, r2) => {
    let n2 = t2[r2];
    "string" == typeof n2 ? t2[r2] = [n2, e3] : Array.isArray(n2) ? n2.push(e3) : t2[r2] = e3;
  }), t2;
}
function ba(e2) {
  switch (e2) {
    case 200:
      return ra.OK;
    case 400:
      return ra.INVALID_ARGUMENT;
    case 401:
      return ra.UNAUTHENTICATED;
    case 403:
      return ra.PERMISSION_DENIED;
    case 404:
      return ra.NOT_FOUND;
    case 409:
      return ra.ABORTED;
    case 412:
      return ra.FAILED_PRECONDITION;
    case 429:
      return ra.RESOURCE_EXHAUSTED;
    case 499:
      return ra.CANCELLED;
    case 500:
    default:
      return ra.UNKNOWN;
    case 501:
      return ra.UNIMPLEMENTED;
    case 503:
      return ra.UNAVAILABLE;
    case 504:
      return ra.DEADLINE_EXCEEDED;
  }
}
var va = class {
  constructor(e2) {
    this.defaultOptions = e2;
  }
  mergeOptions(e2) {
    return function(e3, t2) {
      if (!t2)
        return e3;
      let r2 = {};
      ea(e3, r2), ea(t2, r2);
      for (let i2 of Object.keys(t2)) {
        let o2 = t2[i2];
        switch (i2) {
          case "jsonOptions":
            r2.jsonOptions = U(e3.jsonOptions, r2.jsonOptions);
            break;
          case "binaryOptions":
            r2.binaryOptions = (n2 = r2.binaryOptions, Object.assign(Object.assign({}, e3.binaryOptions), n2));
            break;
          case "meta":
            r2.meta = {}, ea(e3.meta, r2.meta), ea(t2.meta, r2.meta);
            break;
          case "interceptors":
            r2.interceptors = e3.interceptors ? e3.interceptors.concat(o2) : o2.concat();
        }
      }
      var n2;
      return r2;
    }(this.defaultOptions, e2);
  }
  makeUrl(e2, t2) {
    let r2 = t2.baseUrl;
    return r2.endsWith("/") && (r2 = r2.substring(0, r2.length - 1)), `${r2}/${e2.service.typeName}/${e2.name}`;
  }
  clientStreaming(e2) {
    const t2 = new Qs("Client streaming is not supported by grpc-web", ra[ra.UNIMPLEMENTED]);
    throw t2.methodName = e2.name, t2.serviceName = e2.service.typeName, t2;
  }
  duplex(e2) {
    const t2 = new Qs("Duplex streaming is not supported by grpc-web", ra[ra.UNIMPLEMENTED]);
    throw t2.methodName = e2.name, t2.serviceName = e2.service.typeName, t2;
  }
  serverStreaming(e2, t2, r2) {
    var n2, i2, o2, s2;
    let a2, u2, h2 = r2, f2 = null !== (n2 = h2.format) && void 0 !== n2 ? n2 : "text", c2 = null !== (i2 = h2.fetchInit) && void 0 !== i2 ? i2 : {}, l2 = this.makeUrl(e2, h2), d2 = e2.I.toBinary(t2, h2.binaryOptions), p2 = new ia(), y2 = new oa(), g2 = true, m2 = new ia(), w2 = new ia();
    return globalThis.fetch(l2, Object.assign(Object.assign({}, c2), { method: "POST", headers: ha(new globalThis.Headers(), f2, h2.timeout, h2.meta), body: fa(d2, f2), signal: null !== (o2 = r2.abort) && void 0 !== o2 ? o2 : null })).then((e3) => {
      let [t3, r3, n3] = ca(e3);
      if (p2.resolve(n3), null != t3 && t3 !== ra.OK)
        throw new Qs(null != r3 ? r3 : ra[t3], ra[t3], n3);
      return null != t3 && (a2 = { code: ra[t3], detail: null != r3 ? r3 : ra[t3] }), e3;
    }).then((t3) => {
      if (!t3.body)
        throw new Qs("missing response body", ra[ra.INTERNAL]);
      return da(t3.body, t3.headers.get("content-type"), (t4, r3) => {
        switch (t4) {
          case na.DATA:
            y2.notifyMessage(e2.O.fromBinary(r3, h2.binaryOptions)), g2 = false;
            break;
          case na.TRAILER:
            let t5, n3;
            [t5, n3, u2] = la(r3), a2 = { code: ra[t5], detail: null != n3 ? n3 : ra[t5] };
        }
      });
    }).then(() => {
      if (!u2 && !g2)
        throw new Qs("missing trailers", ra[ra.DATA_LOSS]);
      if (!a2)
        throw new Qs("missing status", ra[ra.INTERNAL]);
      if ("OK" !== a2.code)
        throw new Qs(a2.detail, a2.code, u2);
      y2.notifyComplete(), m2.resolve(a2), w2.resolve(u2 || {});
    }).catch((t3) => {
      let r3;
      r3 = t3 instanceof Qs ? t3 : t3 instanceof Error && "AbortError" === t3.name ? new Qs(t3.message, ra[ra.CANCELLED]) : new Qs(t3 instanceof Error ? t3.message : "" + t3, ra[ra.INTERNAL]), r3.methodName = e2.name, r3.serviceName = e2.service.typeName, p2.rejectPending(r3), y2.notifyError(r3), m2.rejectPending(r3), w2.rejectPending(r3);
    }), new aa(e2, null !== (s2 = h2.meta) && void 0 !== s2 ? s2 : {}, t2, p2.promise, y2, m2.promise, w2.promise);
  }
  unary(e2, t2, r2) {
    var n2, i2, o2, s2;
    let a2, u2, h2, f2 = r2, c2 = null !== (n2 = f2.format) && void 0 !== n2 ? n2 : "text", l2 = null !== (i2 = f2.fetchInit) && void 0 !== i2 ? i2 : {}, d2 = this.makeUrl(e2, f2), p2 = e2.I.toBinary(t2, f2.binaryOptions), y2 = new ia(), g2 = new ia(), m2 = new ia(), w2 = new ia();
    return globalThis.fetch(d2, Object.assign(Object.assign({}, l2), { method: "POST", headers: ha(new globalThis.Headers(), c2, f2.timeout, f2.meta), body: fa(p2, c2), signal: null !== (o2 = r2.abort) && void 0 !== o2 ? o2 : null })).then((e3) => {
      let [t3, r3, n3] = ca(e3);
      if (y2.resolve(n3), null != t3 && t3 !== ra.OK)
        throw new Qs(null != r3 ? r3 : ra[t3], ra[t3], n3);
      return null != t3 && (u2 = { code: ra[t3], detail: null != r3 ? r3 : ra[t3] }), e3;
    }).then((t3) => {
      if (!t3.body)
        throw new Qs("missing response body", ra[ra.INTERNAL]);
      return da(t3.body, t3.headers.get("content-type"), (t4, r3) => {
        switch (t4) {
          case na.DATA:
            if (a2)
              throw new Qs("unary call received 2nd message", ra[ra.DATA_LOSS]);
            a2 = e2.O.fromBinary(r3, f2.binaryOptions);
            break;
          case na.TRAILER:
            let t5, n3;
            [t5, n3, h2] = la(r3), u2 = { code: ra[t5], detail: null != n3 ? n3 : ra[t5] };
        }
      });
    }).then(() => {
      if (!h2 && a2)
        throw new Qs("missing trailers", ra[ra.DATA_LOSS]);
      if (!u2)
        throw new Qs("missing status", ra[ra.INTERNAL]);
      if (!a2 && "OK" === u2.code)
        throw new Qs("expected error status", ra[ra.DATA_LOSS]);
      if (!a2)
        throw new Qs(u2.detail, u2.code, h2);
      if (g2.resolve(a2), "OK" !== u2.code)
        throw new Qs(u2.detail, u2.code, h2);
      m2.resolve(u2), w2.resolve(h2 || {});
    }).catch((t3) => {
      let r3;
      r3 = t3 instanceof Qs ? t3 : t3 instanceof Error && "AbortError" === t3.name ? new Qs(t3.message, ra[ra.CANCELLED]) : new Qs(t3 instanceof Error ? t3.message : "" + t3, ra[ra.INTERNAL]), r3.methodName = e2.name, r3.serviceName = e2.service.typeName, y2.rejectPending(r3), g2.rejectPending(r3), m2.rejectPending(r3), w2.rejectPending(r3);
    }), new sa(e2, null !== (s2 = f2.meta) && void 0 !== s2 ? s2 : {}, t2, y2.promise, g2.promise, m2.promise, w2.promise);
  }
};
var Ea;
var xa;
var Ba;
!function(e2) {
  e2[e2.Deliveried = 0] = "Deliveried", e2[e2.OutOfGas = 1] = "OutOfGas", e2[e2.Invalid = 2] = "Invalid";
}(Ea || (Ea = {})), function(e2) {
  e2[e2.Database = 0] = "Database", e2[e2.Account = 1] = "Account";
}(xa || (xa = {})), function(e2) {
  e2[e2.Block = 0] = "Block", e2[e2.Mutation = 1] = "Mutation", e2[e2.Query = 2] = "Query";
}(Ba || (Ba = {}));
var Aa = new class extends Y {
  constructor() {
    super("db3_event_proto.BlockEvent", [{ no: 1, name: "height", kind: "scalar", T: 4 }, { no: 2, name: "block_hash", kind: "scalar", T: 12 }, { no: 3, name: "app_hash", kind: "scalar", T: 12 }, { no: 4, name: "chain_id", kind: "scalar", T: 9 }, { no: 5, name: "gas", kind: "scalar", T: 4 }]);
  }
}();
var _a = new class extends Y {
  constructor() {
    super("db3_event_proto.MutationEvent", [{ no: 1, name: "sender", kind: "scalar", T: 12 }, { no: 2, name: "status", kind: "enum", T: () => ["db3_event_proto.MutationEvent.MutationEventStatus", Ea] }, { no: 3, name: "to", kind: "scalar", T: 12 }, { no: 4, name: "gas", kind: "scalar", T: 4 }]);
  }
}();
var Ta = new class extends Y {
  constructor() {
    super("db3_event_proto.EventMessage", [{ no: 1, name: "type", kind: "enum", T: () => ["db3_event_proto.EventType", Ba] }, { no: 2, name: "mutation_event", kind: "message", oneof: "event", T: () => _a }, { no: 3, name: "block_event", kind: "message", oneof: "event", T: () => Aa }]);
  }
}();
var Sa = new class extends Y {
  constructor() {
    super("db3_event_proto.MutationEventFilter", [{ no: 1, name: "sender", kind: "scalar", T: 12 }]);
  }
}();
var Na = new class extends Y {
  constructor() {
    super("db3_event_proto.BlockEventFilter", []);
  }
}();
var Ia = new class extends Y {
  constructor() {
    super("db3_event_proto.EventFilter", [{ no: 1, name: "mfilter", kind: "message", oneof: "filter", T: () => Sa }, { no: 2, name: "bfilter", kind: "message", oneof: "filter", T: () => Na }]);
  }
}();
var Oa = new class extends Y {
  constructor() {
    super("db3_event_proto.Subscribution", [{ no: 1, name: "topics", kind: "enum", repeat: 1, T: () => ["db3_event_proto.EventType", Ba] }, { no: 2, name: "filters", kind: "message", repeat: 1, T: () => Ia }]);
  }
}();
var Ua = new class extends Y {
  constructor() {
    super("db3_session_proto.QuerySessionInfo", [{ no: 1, name: "id", kind: "scalar", T: 5 }, { no: 2, name: "start_time", kind: "scalar", T: 3 }, { no: 3, name: "query_count", kind: "scalar", T: 5 }, { no: 4, name: "meta", kind: "message", T: () => Ks }]);
  }
}();
var La = new class extends Y {
  constructor() {
    super("db3_session_proto.OpenSessionPayload", [{ no: 1, name: "header", kind: "scalar", T: 9 }, { no: 2, name: "start_time", kind: "scalar", T: 3 }]);
  }
}();
var ka;
new class extends Y {
  constructor() {
    super("db3_session_proto.QuerySession", [{ no: 1, name: "meta", kind: "message", T: () => Ks }, { no: 2, name: "payload", kind: "scalar", T: 12 }, { no: 3, name: "client_signature", kind: "scalar", T: 12 }, { no: 4, name: "payload_type", kind: "enum", T: () => ["db3_mutation_proto.PayloadType", qs] }]);
  }
}(), function(e2) {
  e2[e2.BillForMutation = 0] = "BillForMutation", e2[e2.BillForQuery = 1] = "BillForQuery", e2[e2.BillForMint = 2] = "BillForMint";
}(ka || (ka = {}));
var Ma = new class extends Y {
  constructor() {
    super("db3_bill_proto.Bill", [{ no: 1, name: "gas_fee", kind: "scalar", T: 4 }, { no: 2, name: "block_id", kind: "scalar", T: 4 }, { no: 4, name: "bill_type", kind: "enum", T: () => ["db3_bill_proto.BillType", ka] }, { no: 5, name: "time", kind: "scalar", T: 4 }, { no: 6, name: "tx_id", kind: "scalar", T: 12 }, { no: 8, name: "owner", kind: "scalar", T: 12 }, { no: 9, name: "to", kind: "scalar", T: 12 }]);
  }
}();
new class extends Y {
  constructor() {
    super("db3_bill_proto.BillQueryRequest", [{ no: 1, name: "block_height", kind: "scalar", T: 4 }]);
  }
}();
var Ca = new class extends Y {
  constructor() {
    super("db3_node_proto.NetworkStatus", [{ no: 1, name: "total_database_count", kind: "scalar", T: 4 }, { no: 2, name: "total_collection_count", kind: "scalar", T: 4 }, { no: 3, name: "total_document_count", kind: "scalar", T: 4 }, { no: 4, name: "total_account_count", kind: "scalar", T: 4 }, { no: 5, name: "total_mutation_count", kind: "scalar", T: 4 }, { no: 6, name: "total_session_count", kind: "scalar", T: 4 }, { no: 7, name: "total_storage_in_bytes", kind: "scalar", T: 4 }]);
  }
}();
var Pa = new class extends Y {
  constructor() {
    super("db3_node_proto.QueryBillKey", [{ no: 1, name: "height", kind: "scalar", T: 4 }, { no: 2, name: "session_token", kind: "scalar", T: 9 }]);
  }
}();
var Ra = new class extends Y {
  constructor() {
    super("db3_node_proto.QueryBillRequest", [{ no: 1, name: "query_bill_key", kind: "message", T: () => Pa }]);
  }
}();
var Da = new class extends Y {
  constructor() {
    super("db3_node_proto.QueryBillResponse", [{ no: 1, name: "bills", kind: "message", repeat: 1, T: () => Ma }]);
  }
}();
var za = new class extends Y {
  constructor() {
    super("db3_node_proto.SessionIdentifier", [{ no: 1, name: "session_token", kind: "scalar", T: 9 }]);
  }
}();
var $a = new class extends Y {
  constructor() {
    super("db3_node_proto.GetAccountRequest", [{ no: 1, name: "addr", kind: "scalar", T: 12 }]);
  }
}();
var Va = new class extends Y {
  constructor() {
    super("db3_node_proto.GetAccountResponse", [{ no: 1, name: "account", kind: "message", T: () => X }]);
  }
}();
var ja = new class extends Y {
  constructor() {
    super("db3_node_proto.GetSessionInfoRequest", [{ no: 1, name: "session_identifier", kind: "message", T: () => za }]);
  }
}();
var Fa = new class extends Y {
  constructor() {
    super("db3_node_proto.OpenSessionRequest", [{ no: 1, name: "payload", kind: "scalar", T: 12 }, { no: 2, name: "signature", kind: "scalar", T: 12 }, { no: 3, name: "payload_type", kind: "enum", T: () => ["db3_mutation_proto.PayloadType", qs] }]);
  }
}();
var Ha = new class extends Y {
  constructor() {
    super("db3_node_proto.OpenSessionResponse", [{ no: 1, name: "query_session_info", kind: "message", T: () => Ua }, { no: 2, name: "session_timeout_second", kind: "scalar", T: 3 }, { no: 3, name: "max_query_limit", kind: "scalar", T: 5 }, { no: 4, name: "session_token", kind: "scalar", T: 9 }]);
  }
}();
var Ka = new class extends Y {
  constructor() {
    super("db3_node_proto.CloseSessionRequest", [{ no: 1, name: "payload", kind: "scalar", T: 12 }, { no: 2, name: "signature", kind: "scalar", T: 12 }, { no: 3, name: "session_token", kind: "scalar", T: 9 }, { no: 4, name: "payload_type", kind: "enum", T: () => ["db3_mutation_proto.PayloadType", qs] }]);
  }
}();
var Ga = new class extends Y {
  constructor() {
    super("db3_node_proto.CloseSessionResponse", [{ no: 1, name: "query_session_info", kind: "message", T: () => Ua }, { no: 2, name: "hash", kind: "scalar", T: 12 }]);
  }
}();
var qa = new class extends Y {
  constructor() {
    super("db3_node_proto.GetSessionInfoResponse", [{ no: 1, name: "session_status", kind: "scalar", T: 5 }, { no: 2, name: "session_info", kind: "message", T: () => Ua }]);
  }
}();
var Ja = new class extends Y {
  constructor() {
    super("db3_node_proto.BroadcastRequest", [{ no: 1, name: "body", kind: "scalar", T: 12 }]);
  }
}();
var Wa = new class extends Y {
  constructor() {
    super("db3_node_proto.BroadcastResponse", [{ no: 2, name: "hash", kind: "scalar", T: 12 }]);
  }
}();
var Za = new class extends Y {
  constructor() {
    super("db3_node_proto.ShowDatabaseRequest", [{ no: 1, name: "session_token", kind: "scalar", T: 9 }, { no: 2, name: "address", kind: "scalar", T: 9 }]);
  }
}();
var Ya = new class extends Y {
  constructor() {
    super("db3_node_proto.ShowDatabaseResponse", [{ no: 1, name: "db", kind: "message", T: () => ne }]);
  }
}();
var Xa = new class extends Y {
  constructor() {
    super("db3_node_proto.RunQueryRequest", [{ no: 1, name: "session_token", kind: "scalar", T: 9 }, { no: 2, name: "address", kind: "scalar", T: 9 }, { no: 3, name: "query", kind: "message", T: () => ue }]);
  }
}();
var Qa = new class extends Y {
  constructor() {
    super("db3_node_proto.GetDocumentRequest", [{ no: 1, name: "session_token", kind: "scalar", T: 9 }, { no: 2, name: "id", kind: "scalar", T: 9 }]);
  }
}();
var eu = new class extends Y {
  constructor() {
    super("db3_node_proto.GetDocumentResponse", [{ no: 1, name: "document", kind: "message", T: () => oe }]);
  }
}();
var tu = new class extends Y {
  constructor() {
    super("db3_node_proto.RunQueryResponse", [{ no: 2, name: "documents", kind: "message", repeat: 1, T: () => oe }]);
  }
}();
var ru = new class extends Y {
  constructor() {
    super("db3_node_proto.ShowNetworkStatusRequest", []);
  }
}();
var nu = new class extends Y {
  constructor() {
    super("db3_node_proto.SubscribeRequest", [{ no: 1, name: "session_token", kind: "scalar", T: 9 }, { no: 2, name: "sub", kind: "message", T: () => Oa }]);
  }
}();
var iu = new class {
  constructor(e2, t2, r2) {
    this.typeName = e2, this.methods = t2.map((e3) => function(e4, t3) {
      var r3, n2, i2;
      let o2 = e4;
      return o2.service = t3, o2.localName = null !== (r3 = o2.localName) && void 0 !== r3 ? r3 : k(o2.name), o2.serverStreaming = !!o2.serverStreaming, o2.clientStreaming = !!o2.clientStreaming, o2.options = null !== (n2 = o2.options) && void 0 !== n2 ? n2 : {}, o2.idempotency = null !== (i2 = o2.idempotency) && void 0 !== i2 ? i2 : void 0, o2;
    }(e3, this)), this.options = null != r2 ? r2 : {};
  }
}("db3_node_proto.StorageNode", [{ name: "QueryBill", options: {}, I: Ra, O: Da }, { name: "OpenQuerySession", options: {}, I: Fa, O: Ha }, { name: "CloseQuerySession", options: {}, I: Ka, O: Ga }, { name: "GetAccount", options: {}, I: $a, O: Va }, { name: "GetSessionInfo", options: {}, I: ja, O: qa }, { name: "Broadcast", options: {}, I: Ja, O: Wa }, { name: "ShowDatabase", options: {}, I: Za, O: Ya }, { name: "RunQuery", options: {}, I: Xa, O: tu }, { name: "GetDocument", options: {}, I: Qa, O: eu }, { name: "ShowNetworkStatus", options: {}, I: ru, O: Ca }, { name: "Subscribe", serverStreaming: true, options: {}, I: nu, O: Ta }]);
var ou = class {
  constructor(e2) {
    this._transport = void 0, this.typeName = iu.typeName, this.methods = iu.methods, this.options = iu.options, this._transport = e2;
  }
  queryBill(e2, t2) {
    const r2 = this.methods[0], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  openQuerySession(e2, t2) {
    const r2 = this.methods[1], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  closeQuerySession(e2, t2) {
    const r2 = this.methods[2], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  getAccount(e2, t2) {
    const r2 = this.methods[3], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  getSessionInfo(e2, t2) {
    const r2 = this.methods[4], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  broadcast(e2, t2) {
    const r2 = this.methods[5], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  showDatabase(e2, t2) {
    const r2 = this.methods[6], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  runQuery(e2, t2) {
    const r2 = this.methods[7], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  getDocument(e2, t2) {
    const r2 = this.methods[8], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  showNetworkStatus(e2, t2) {
    const r2 = this.methods[9], n2 = this._transport.mergeOptions(t2);
    return ua("unary", this._transport, r2, n2, e2);
  }
  subscribe(e2, t2) {
    const r2 = this.methods[10], n2 = this._transport.mergeOptions(t2);
    return ua("serverStreaming", this._transport, r2, n2, e2);
  }
};
var su = ye(function(e2, t2) {
  !function(e3) {
    var t3, r2 = "undefined", n2 = r2 !== typeof Buffer && Buffer, i2 = r2 !== typeof Uint8Array && Uint8Array, o2 = r2 !== typeof ArrayBuffer && ArrayBuffer, s2 = [0, 0, 0, 0, 0, 0, 0, 0], a2 = Array.isArray || function(e4) {
      return !!e4 && "[object Array]" == Object.prototype.toString.call(e4);
    }, u2 = 4294967296;
    function h2(a3, h3, v2) {
      var E2 = h3 ? 0 : 4, x2 = h3 ? 4 : 0, B2 = h3 ? 0 : 3, A2 = h3 ? 1 : 2, _2 = h3 ? 2 : 1, T2 = h3 ? 3 : 0, S2 = h3 ? g2 : w2, N2 = h3 ? m2 : b2, I2 = L2.prototype, O2 = "is" + a3, U2 = "_" + O2;
      return I2.buffer = void 0, I2.offset = 0, I2[U2] = true, I2.toNumber = k2, I2.toString = function(e4) {
        var t4 = this.buffer, r3 = this.offset, n3 = C2(t4, r3 + E2), i3 = C2(t4, r3 + x2), o3 = "", s3 = !v2 && 2147483648 & n3;
        for (s3 && (n3 = ~n3, i3 = u2 - i3), e4 = e4 || 10; ; ) {
          var a4 = n3 % e4 * u2 + i3;
          if (n3 = Math.floor(n3 / e4), i3 = Math.floor(a4 / e4), o3 = (a4 % e4).toString(e4) + o3, !n3 && !i3)
            break;
        }
        return s3 && (o3 = "-" + o3), o3;
      }, I2.toJSON = k2, I2.toArray = f2, n2 && (I2.toBuffer = c2), i2 && (I2.toArrayBuffer = l2), L2[O2] = function(e4) {
        return !(!e4 || !e4[U2]);
      }, e3[a3] = L2, L2;
      function L2(e4, a4, h4, f3) {
        return this instanceof L2 ? function(e5, a5, h5, f4, c3) {
          if (i2 && o2 && (a5 instanceof o2 && (a5 = new i2(a5)), f4 instanceof o2 && (f4 = new i2(f4))), a5 || h5 || f4 || t3) {
            if (!d2(a5, h5)) {
              var l3 = t3 || Array;
              c3 = h5, f4 = a5, h5 = 0, a5 = t3 === n2 ? n2.alloc(8) : new l3(8);
            }
            e5.buffer = a5, e5.offset = h5 |= 0, r2 !== typeof f4 && ("string" == typeof f4 ? function(e6, t4, r3, n3) {
              var i3 = 0, o3 = r3.length, s3 = 0, a6 = 0;
              "-" === r3[0] && i3++;
              for (var h6 = i3; i3 < o3; ) {
                var f5 = parseInt(r3[i3++], n3);
                if (!(f5 >= 0))
                  break;
                a6 = a6 * n3 + f5, s3 = s3 * n3 + Math.floor(a6 / u2), a6 %= u2;
              }
              h6 && (s3 = ~s3, a6 ? a6 = u2 - a6 : s3++), M2(e6, t4 + E2, s3), M2(e6, t4 + x2, a6);
            }(a5, h5, f4, c3 || 10) : d2(f4, c3) ? p2(a5, h5, f4, c3) : "number" == typeof c3 ? (M2(a5, h5 + E2, f4), M2(a5, h5 + x2, c3)) : f4 > 0 ? S2(a5, h5, f4) : f4 < 0 ? N2(a5, h5, f4) : p2(a5, h5, s2, 0));
          } else
            e5.buffer = y2(s2, 0);
        }(this, e4, a4, h4, f3) : new L2(e4, a4, h4, f3);
      }
      function k2() {
        var e4 = this.buffer, t4 = this.offset, r3 = C2(e4, t4 + E2), n3 = C2(e4, t4 + x2);
        return v2 || (r3 |= 0), r3 ? r3 * u2 + n3 : n3;
      }
      function M2(e4, t4, r3) {
        e4[t4 + T2] = 255 & r3, e4[t4 + _2] = 255 & (r3 >>= 8), e4[t4 + A2] = 255 & (r3 >>= 8), e4[t4 + B2] = 255 & (r3 >>= 8);
      }
      function C2(e4, t4) {
        return 16777216 * e4[t4 + B2] + (e4[t4 + A2] << 16) + (e4[t4 + _2] << 8) + e4[t4 + T2];
      }
    }
    function f2(e4) {
      var r3 = this.buffer, n3 = this.offset;
      return t3 = null, false !== e4 && a2(r3) ? 8 === r3.length ? r3 : r3.slice(n3, n3 + 8) : y2(r3, n3);
    }
    function c2(e4) {
      var r3 = this.buffer, i3 = this.offset;
      return t3 = n2, false !== e4 && n2.isBuffer(r3) ? 8 === r3.length ? r3 : r3.slice(i3, i3 + 8) : n2.from(l2.call(this, e4));
    }
    function l2(e4) {
      var r3 = this.buffer, n3 = this.offset, s3 = r3.buffer;
      if (t3 = i2, false !== e4 && !r3.offset && s3 instanceof o2)
        return 8 === s3.byteLength ? s3 : s3.slice(n3, n3 + 8);
      var a3 = new i2(8);
      return p2(a3, 0, r3, n3), a3.buffer;
    }
    function d2(e4, t4) {
      var r3 = e4 && e4.length;
      return t4 |= 0, r3 && t4 + 8 <= r3 && "string" != typeof e4[t4];
    }
    function p2(e4, t4, r3, n3) {
      t4 |= 0, n3 |= 0;
      for (var i3 = 0; i3 < 8; i3++)
        e4[t4++] = 255 & r3[n3++];
    }
    function y2(e4, t4) {
      return Array.prototype.slice.call(e4, t4, t4 + 8);
    }
    function g2(e4, t4, r3) {
      for (var n3 = t4 + 8; n3 > t4; )
        e4[--n3] = 255 & r3, r3 /= 256;
    }
    function m2(e4, t4, r3) {
      var n3 = t4 + 8;
      for (r3++; n3 > t4; )
        e4[--n3] = 255 & -r3 ^ 255, r3 /= 256;
    }
    function w2(e4, t4, r3) {
      for (var n3 = t4 + 8; t4 < n3; )
        e4[t4++] = 255 & r3, r3 /= 256;
    }
    function b2(e4, t4, r3) {
      var n3 = t4 + 8;
      for (r3++; t4 < n3; )
        e4[t4++] = 255 & -r3 ^ 255, r3 /= 256;
    }
    h2("Uint64BE", true, true), h2("Int64BE", true, false), h2("Uint64LE", false, true), h2("Int64LE", false, false);
  }("string" != typeof t2.nodeName ? t2 : pe || {});
});
var au = class {
  constructor(e2) {
    this.data = void 0;
    const t2 = e2.length;
    if (32 != t2)
      throw new Error(`Wrong data size. Expected 32 bytes, got ${t2}.`);
    this.data = e2;
  }
  static from(e2) {
    return new au(e2);
  }
  getB64() {
    return lt(this.data);
  }
};
var uu = class {
  constructor(e2, t2) {
    this.addr = void 0;
    const r2 = ut(e2), n2 = new su.Uint64BE(t2);
    let i2 = new Uint8Array(28);
    i2.set(n2.toArray(), 0), i2.set(r2, 8), this.addr = "0x" + ve.sha3_256(i2).slice(0, 40);
  }
  getHexAddr() {
    return this.addr;
  }
};
var hu = class {
  constructor(e2, t2) {
    this.client = void 0, this.wallet = void 0, this.useTypedFormat = void 0;
    const r2 = new va({ baseUrl: e2, interceptors: [], meta: {} });
    this.client = new ou(r2), this.wallet = t2, this.useTypedFormat = "MetaMask" === t2.getType();
  }
  async sendMutation(e2, t2) {
    if (this.useTypedFormat) {
      const r2 = await this.wrapTypedWriteRequest(e2, t2), n2 = { body: Xs.toBinary(r2) }, { response: i2 } = await this.client.broadcast(n2);
      return new au(i2.hash);
    }
    {
      const r2 = await this.wrapProtoWriteRequest(e2, t2), n2 = { body: Xs.toBinary(r2) }, { response: i2 } = await this.client.broadcast(n2);
      return new au(i2.hash);
    }
  }
  async wrapProtoWriteRequest(e2, t2) {
    return { payload: e2, signature: await this.wallet.sign(e2), payloadType: t2 };
  }
  async wrapTypedWriteRequest(e2, t2) {
    const r2 = { types: { EIP712Domain: [], Message: [{ name: "payload", type: "bytes" }, { name: "payloadType", type: "string" }] }, domain: {}, primaryType: "Message", message: { payload: "0x" + ht(e2), payloadType: t2.toString() } }, n2 = await this.wallet.sign(r2), i2 = JSON.stringify(r2);
    return { payload: new TextEncoder().encode(i2), signature: n2, payloadType: qs.TypedDataPayload };
  }
  async openSession() {
    let e2;
    e2 = "undefined" == typeof window ? new Date().getTime() + "_Header_" + Math.floor(1e3 * Math.random()) : window.crypto.getRandomValues(new Uint8Array(32));
    const t2 = { header: e2.toString(), startTime: Math.floor(Date.now() / 1e3) };
    if (this.useTypedFormat) {
      const e3 = await this.wrapTypedSession(t2), { response: r2 } = await this.client.openQuerySession(e3);
      return r2;
    }
    {
      const e3 = await this.wrapProtoSession(t2), { response: r2 } = await this.client.openQuerySession(e3);
      return r2;
    }
  }
  async wrapProtoSession(e2) {
    const t2 = La.toBinary(e2);
    return { payload: t2, signature: await this.wallet.sign(t2), payloadType: qs.QuerySessionPayload };
  }
  async wrapTypedSession(e2) {
    const t2 = { types: { EIP712Domain: [], Message: [{ name: "payload", type: "bytes" }, { name: "payloadType", type: "string" }] }, domain: {}, primaryType: "Message", message: { payload: "0x" + ht(La.toBinary(e2)), payloadType: qs.QuerySessionPayload.toString() } }, r2 = JSON.stringify(t2);
    return { payload: new TextEncoder().encode(r2), signature: await this.wallet.sign(t2), payloadType: qs.TypedDataPayload };
  }
  async wrapProtoCloseSession(e2, t2) {
    const r2 = Ua.toBinary(payload);
    return { payload: r2, signature: await this.wallet.sign(r2), payloadType: qs.QuerySessionPayload, sessionToke: e2 };
  }
  async wrapTypedCloseSession(e2, t2) {
    const r2 = { types: { EIP712Domain: [], Message: [{ name: "payload", type: "bytes" }, { name: "payloadType", type: "string" }] }, domain: {}, primaryType: "Message", message: { payload: "0x" + ht(Ua.toBinary(t2)), payloadType: qs.QuerySessionPayload.toString() } }, n2 = JSON.stringify(r2);
    return { payload: new TextEncoder().encode(n2), signature: await this.wallet.sign(r2), payloadType: qs.TypedDataPayload, sessionToke: e2 };
  }
  async closeSession(e2, t2) {
    let r2;
    r2 = await this.wrapTypedCloseSession(e2, t2);
    const { response: n2 } = await this.client.closeQuerySession(r2);
    return n2;
  }
  async getAccount(e2) {
    const t2 = { addr: e2 }, { response: r2 } = await this.client.getAccount(t2);
    return r2;
  }
  async getState() {
    const { response: e2 } = await this.client.showNetworkStatus({});
    return e2;
  }
  async getDatabase(e2, t2) {
    const r2 = { sessionToken: t2, address: e2 }, { response: n2 } = await this.client.showDatabase(r2);
    return n2;
  }
  getNonce() {
    return new Date().getTime();
  }
  async runQuery(e2, t2, r2) {
    const n2 = { sessionToken: e2, address: t2, query: r2 }, { response: i2 } = await this.client.runQuery(n2);
    return i2;
  }
  async getDocument(e2, t2) {
    const r2 = { sessionToken: e2, id: t2 }, { response: n2 } = await this.client.getDoument(r2);
    return n2;
  }
};
var fu = ye(function(e2) {
  var t2, r2;
  t2 = pe, r2 = function() {
    var e3 = function() {
    }, t3 = "undefined", r3 = typeof window !== t3 && typeof window.navigator !== t3 && /Trident\/|MSIE /.test(window.navigator.userAgent), n2 = ["trace", "debug", "info", "warn", "error"];
    function i2(e4, t4) {
      var r4 = e4[t4];
      if ("function" == typeof r4.bind)
        return r4.bind(e4);
      try {
        return Function.prototype.bind.call(r4, e4);
      } catch (t5) {
        return function() {
          return Function.prototype.apply.apply(r4, [e4, arguments]);
        };
      }
    }
    function o2() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function s2(n3) {
      return "debug" === n3 && (n3 = "log"), typeof console !== t3 && ("trace" === n3 && r3 ? o2 : void 0 !== console[n3] ? i2(console, n3) : void 0 !== console.log ? i2(console, "log") : e3);
    }
    function a2(t4, r4) {
      for (var i3 = 0; i3 < n2.length; i3++) {
        var o3 = n2[i3];
        this[o3] = i3 < t4 ? e3 : this.methodFactory(o3, t4, r4);
      }
      this.log = this.debug;
    }
    function u2(e4, r4, n3) {
      return function() {
        typeof console !== t3 && (a2.call(this, r4, n3), this[e4].apply(this, arguments));
      };
    }
    function h2(e4, t4, r4) {
      return s2(e4) || u2.apply(this, arguments);
    }
    function f2(e4, r4, i3) {
      var o3, s3 = this;
      r4 = null == r4 ? "WARN" : r4;
      var u3 = "loglevel";
      function f3() {
        var e5;
        if (typeof window !== t3 && u3) {
          try {
            e5 = window.localStorage[u3];
          } catch (e6) {
          }
          if (typeof e5 === t3)
            try {
              var r5 = window.document.cookie, n3 = r5.indexOf(encodeURIComponent(u3) + "=");
              -1 !== n3 && (e5 = /^([^;]+)/.exec(r5.slice(n3))[1]);
            } catch (e6) {
            }
          return void 0 === s3.levels[e5] && (e5 = void 0), e5;
        }
      }
      "string" == typeof e4 ? u3 += ":" + e4 : "symbol" == typeof e4 && (u3 = void 0), s3.name = e4, s3.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }, s3.methodFactory = i3 || h2, s3.getLevel = function() {
        return o3;
      }, s3.setLevel = function(r5, i4) {
        if ("string" == typeof r5 && void 0 !== s3.levels[r5.toUpperCase()] && (r5 = s3.levels[r5.toUpperCase()]), !("number" == typeof r5 && r5 >= 0 && r5 <= s3.levels.SILENT))
          throw "log.setLevel() called with invalid level: " + r5;
        if (o3 = r5, false !== i4 && function(e5) {
          var r6 = (n2[e5] || "silent").toUpperCase();
          if (typeof window !== t3 && u3) {
            try {
              return void (window.localStorage[u3] = r6);
            } catch (e6) {
            }
            try {
              window.document.cookie = encodeURIComponent(u3) + "=" + r6 + ";";
            } catch (e6) {
            }
          }
        }(r5), a2.call(s3, r5, e4), typeof console === t3 && r5 < s3.levels.SILENT)
          return "No console available for logging";
      }, s3.setDefaultLevel = function(e5) {
        r4 = e5, f3() || s3.setLevel(e5, false);
      }, s3.resetLevel = function() {
        s3.setLevel(r4, false), function() {
          if (typeof window !== t3 && u3) {
            try {
              return void window.localStorage.removeItem(u3);
            } catch (e5) {
            }
            try {
              window.document.cookie = encodeURIComponent(u3) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch (e5) {
            }
          }
        }();
      }, s3.enableAll = function(e5) {
        s3.setLevel(s3.levels.TRACE, e5);
      }, s3.disableAll = function(e5) {
        s3.setLevel(s3.levels.SILENT, e5);
      };
      var c3 = f3();
      null == c3 && (c3 = r4), s3.setLevel(c3, false);
    }
    var c2 = new f2(), l2 = {};
    c2.getLogger = function(e4) {
      if ("symbol" != typeof e4 && "string" != typeof e4 || "" === e4)
        throw new TypeError("You must supply a name when creating a logger.");
      var t4 = l2[e4];
      return t4 || (t4 = l2[e4] = new f2(e4, c2.getLevel(), c2.methodFactory)), t4;
    };
    var d2 = typeof window !== t3 ? window.log : void 0;
    return c2.noConflict = function() {
      return typeof window !== t3 && window.log === c2 && (window.log = d2), c2;
    }, c2.getLoggers = function() {
      return l2;
    }, c2.default = c2, c2;
  }, e2.exports ? e2.exports = r2() : t2.log = r2();
});
var cu = 2147483647;
var lu = -2147483648;
var du = Math.pow(2, 63) - 1;
var pu = -Math.pow(2, 63);
var yu = Math.pow(2, 53);
var gu = -Math.pow(2, 53);
var mu = 16;
var wu = Object.freeze({ double: 1, string: 2, object: 3, array: 4, binData: 5, undefined: 6, objectId: 7, bool: 8, date: 9, null: 10, regex: 11, dbPointer: 12, javascript: 13, symbol: 14, javascriptWithScope: 15, int: 16, timestamp: 17, long: 18, decimal: 19, minKey: -1, maxKey: 127 });
var bu = class extends Error {
  get bsonError() {
    return true;
  }
  get name() {
    return "BSONError";
  }
  constructor(e2) {
    super(e2);
  }
  static isBSONError(e2) {
    return null != e2 && "object" == typeof e2 && "bsonError" in e2 && true === e2.bsonError && "name" in e2 && "message" in e2 && "stack" in e2;
  }
};
var vu = class extends bu {
  get name() {
    return "BSONVersionError";
  }
  constructor() {
    super("Unsupported BSON version, bson types must be from bson 5.0 or later");
  }
};
var Eu = class extends bu {
  get name() {
    return "BSONRuntimeError";
  }
  constructor(e2) {
    super(e2);
  }
};
var xu = { toLocalBufferType(e2) {
  var _a3;
  if (Buffer.isBuffer(e2))
    return e2;
  if (ArrayBuffer.isView(e2))
    return Buffer.from(e2.buffer, e2.byteOffset, e2.byteLength);
  const t2 = (_a3 = e2 == null ? void 0 : e2[Symbol.toStringTag]) != null ? _a3 : Object.prototype.toString.call(e2);
  if ("ArrayBuffer" === t2 || "SharedArrayBuffer" === t2 || "[object ArrayBuffer]" === t2 || "[object SharedArrayBuffer]" === t2)
    return Buffer.from(e2);
  throw new bu(`Cannot create Buffer from ${String(e2)}`);
}, allocate: (e2) => Buffer.alloc(e2), equals: (e2, t2) => xu.toLocalBufferType(e2).equals(t2), fromNumberArray: (e2) => Buffer.from(e2), fromBase64: (e2) => Buffer.from(e2, "base64"), toBase64: (e2) => xu.toLocalBufferType(e2).toString("base64"), fromISO88591: (e2) => Buffer.from(e2, "binary"), toISO88591: (e2) => xu.toLocalBufferType(e2).toString("binary"), fromHex: (e2) => Buffer.from(e2, "hex"), toHex: (e2) => xu.toLocalBufferType(e2).toString("hex"), fromUTF8: (e2) => Buffer.from(e2, "utf8"), toUTF8: (e2) => xu.toLocalBufferType(e2).toString("utf8"), utf8ByteLength: (e2) => Buffer.byteLength(e2, "utf8"), encodeUTF8Into: (e2, t2, r2) => xu.toLocalBufferType(e2).write(t2, r2, void 0, "utf8"), randomBytes: function(e2) {
  return xu.fromNumberArray(Array.from({ length: e2 }, () => Math.floor(256 * Math.random())));
} };
function Bu(e2) {
  if (e2 < 0)
    throw new RangeError(`The argument 'byteLength' is invalid. Received ${e2}`);
  return Tu.fromNumberArray(Array.from({ length: e2 }, () => Math.floor(256 * Math.random())));
}
var Au = (() => {
  var _a3;
  const { crypto: e2 } = globalThis;
  if (null != e2 && "function" == typeof e2.getRandomValues)
    return (t2) => e2.getRandomValues(Tu.allocate(t2));
  if (function() {
    const { navigator: e3 } = globalThis;
    return "object" == typeof e3 && "ReactNative" === e3.product;
  }()) {
    const { console: e3 } = globalThis;
    (_a3 = e3 == null ? void 0 : e3.warn) == null ? void 0 : _a3.call(e3, "BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
  }
  return Bu;
})();
var _u = /(\d|[a-f])/i;
var Tu = { toLocalBufferType(e2) {
  var _a3;
  const t2 = (_a3 = e2 == null ? void 0 : e2[Symbol.toStringTag]) != null ? _a3 : Object.prototype.toString.call(e2);
  if ("Uint8Array" === t2)
    return e2;
  if (ArrayBuffer.isView(e2))
    return new Uint8Array(e2.buffer.slice(e2.byteOffset, e2.byteOffset + e2.byteLength));
  if ("ArrayBuffer" === t2 || "SharedArrayBuffer" === t2 || "[object ArrayBuffer]" === t2 || "[object SharedArrayBuffer]" === t2)
    return new Uint8Array(e2);
  throw new bu(`Cannot make a Uint8Array from ${String(e2)}`);
}, allocate(e2) {
  if ("number" != typeof e2)
    throw new TypeError(`The "size" argument must be of type number. Received ${String(e2)}`);
  return new Uint8Array(e2);
}, equals(e2, t2) {
  if (e2.byteLength !== t2.byteLength)
    return false;
  for (let r2 = 0; r2 < e2.byteLength; r2++)
    if (e2[r2] !== t2[r2])
      return false;
  return true;
}, fromNumberArray: (e2) => Uint8Array.from(e2), fromBase64: (e2) => Uint8Array.from(atob(e2), (e3) => e3.charCodeAt(0)), toBase64: (e2) => btoa(Tu.toISO88591(e2)), fromISO88591: (e2) => Uint8Array.from(e2, (e3) => 255 & e3.charCodeAt(0)), toISO88591: (e2) => Array.from(Uint16Array.from(e2), (e3) => String.fromCharCode(e3)).join(""), fromHex(e2) {
  const t2 = e2.length % 2 == 0 ? e2 : e2.slice(0, e2.length - 1), r2 = [];
  for (let e3 = 0; e3 < t2.length; e3 += 2) {
    const n2 = t2[e3], i2 = t2[e3 + 1];
    if (!_u.test(n2))
      break;
    if (!_u.test(i2))
      break;
    const o2 = Number.parseInt(`${n2}${i2}`, 16);
    r2.push(o2);
  }
  return Uint8Array.from(r2);
}, toHex: (e2) => Array.from(e2, (e3) => e3.toString(16).padStart(2, "0")).join(""), fromUTF8: (e2) => new TextEncoder().encode(e2), toUTF8: (e2) => new TextDecoder("utf8", { fatal: false }).decode(e2), utf8ByteLength: (e2) => Tu.fromUTF8(e2).byteLength, encodeUTF8Into(e2, t2, r2) {
  const n2 = Tu.fromUTF8(t2);
  return e2.set(n2, r2), n2.byteLength;
}, randomBytes: Au };
var _a2;
var Su = "function" == typeof Buffer && true !== ((_a2 = Buffer.prototype) == null ? void 0 : _a2._isBuffer) ? xu : Tu;
var Nu = class extends DataView {
  static fromUint8Array(e2) {
    return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
  }
};
var Iu = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;
var Ou = (e2) => "string" == typeof e2 && Iu.test(e2);
var Uu = (e2) => {
  if (!Ou(e2))
    throw new bu('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".');
  const t2 = e2.replace(/-/g, "");
  return Su.fromHex(t2);
};
function Lu(e2, t2 = true) {
  return t2 ? [Su.toHex(e2.subarray(0, 4)), Su.toHex(e2.subarray(4, 6)), Su.toHex(e2.subarray(6, 8)), Su.toHex(e2.subarray(8, 10)), Su.toHex(e2.subarray(10, 16))].join("-") : Su.toHex(e2);
}
function ku(e2) {
  return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(e2));
}
function Mu(e2) {
  return "[object Uint8Array]" === Object.prototype.toString.call(e2);
}
function Cu(e2) {
  return "[object RegExp]" === Object.prototype.toString.call(e2);
}
function Pu(e2) {
  return "[object Date]" === Object.prototype.toString.call(e2);
}
var Ru = class {
  get [Symbol.for("@@mdb.bson.version")]() {
    return 5;
  }
};
var Du = class extends Ru {
  get _bsontype() {
    return "Binary";
  }
  constructor(e2, t2) {
    if (super(), !(null == e2 || "string" == typeof e2 || ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer || Array.isArray(e2)))
      throw new bu("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>");
    this.sub_type = t2 != null ? t2 : Du.BSON_BINARY_SUBTYPE_DEFAULT, null == e2 ? (this.buffer = Su.allocate(Du.BUFFER_SIZE), this.position = 0) : (this.buffer = "string" == typeof e2 ? Su.fromISO88591(e2) : Array.isArray(e2) ? Su.fromNumberArray(e2) : Su.toLocalBufferType(e2), this.position = this.buffer.byteLength);
  }
  put(e2) {
    if ("string" == typeof e2 && 1 !== e2.length)
      throw new bu("only accepts single character String");
    if ("number" != typeof e2 && 1 !== e2.length)
      throw new bu("only accepts single character Uint8Array or Array");
    let t2;
    if (t2 = "string" == typeof e2 ? e2.charCodeAt(0) : "number" == typeof e2 ? e2 : e2[0], t2 < 0 || t2 > 255)
      throw new bu("only accepts number in a valid unsigned byte range 0-255");
    if (this.buffer.byteLength > this.position)
      this.buffer[this.position++] = t2;
    else {
      const e3 = Su.allocate(Du.BUFFER_SIZE + this.buffer.length);
      e3.set(this.buffer, 0), this.buffer = e3, this.buffer[this.position++] = t2;
    }
  }
  write(e2, t2) {
    if (this.buffer.byteLength < (t2 = "number" == typeof t2 ? t2 : this.position) + e2.length) {
      const t3 = Su.allocate(this.buffer.byteLength + e2.length);
      t3.set(this.buffer, 0), this.buffer = t3;
    }
    if (ArrayBuffer.isView(e2))
      this.buffer.set(Su.toLocalBufferType(e2), t2), this.position = t2 + e2.byteLength > this.position ? t2 + e2.length : this.position;
    else if ("string" == typeof e2) {
      const r2 = Su.fromISO88591(e2);
      this.buffer.set(r2, t2), this.position = t2 + e2.length > this.position ? t2 + e2.length : this.position;
    }
  }
  read(e2, t2) {
    return this.buffer.slice(e2, e2 + (t2 = t2 && t2 > 0 ? t2 : this.position));
  }
  value(e2) {
    return (e2 = !!e2) && this.buffer.length === this.position ? this.buffer : e2 ? this.buffer.slice(0, this.position) : Su.toISO88591(this.buffer.subarray(0, this.position));
  }
  length() {
    return this.position;
  }
  toJSON() {
    return Su.toBase64(this.buffer);
  }
  toString(e2) {
    return "hex" === e2 ? Su.toHex(this.buffer) : "base64" === e2 ? Su.toBase64(this.buffer) : Su.toUTF8(this.buffer);
  }
  toExtendedJSON(e2) {
    e2 = e2 || {};
    const t2 = Su.toBase64(this.buffer), r2 = Number(this.sub_type).toString(16);
    return e2.legacy ? { $binary: t2, $type: 1 === r2.length ? "0" + r2 : r2 } : { $binary: { base64: t2, subType: 1 === r2.length ? "0" + r2 : r2 } };
  }
  toUUID() {
    if (this.sub_type === Du.SUBTYPE_UUID)
      return new zu(this.buffer.slice(0, this.position));
    throw new bu(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Du.SUBTYPE_UUID}" is currently supported.`);
  }
  static fromExtendedJSON(e2, t2) {
    let r2, n2;
    if (t2 = t2 || {}, "$binary" in e2 ? t2.legacy && "string" == typeof e2.$binary && "$type" in e2 ? (n2 = e2.$type ? parseInt(e2.$type, 16) : 0, r2 = Su.fromBase64(e2.$binary)) : "string" != typeof e2.$binary && (n2 = e2.$binary.subType ? parseInt(e2.$binary.subType, 16) : 0, r2 = Su.fromBase64(e2.$binary.base64)) : "$uuid" in e2 && (n2 = 4, r2 = Uu(e2.$uuid)), !r2)
      throw new bu(`Unexpected Binary Extended JSON format ${JSON.stringify(e2)}`);
    return 4 === n2 ? new zu(r2) : new Du(r2, n2);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new Binary(Buffer.from("${Su.toHex(this.buffer)}", "hex"), ${this.sub_type})`;
  }
};
Du.BSON_BINARY_SUBTYPE_DEFAULT = 0, Du.BUFFER_SIZE = 256, Du.SUBTYPE_DEFAULT = 0, Du.SUBTYPE_FUNCTION = 1, Du.SUBTYPE_BYTE_ARRAY = 2, Du.SUBTYPE_UUID_OLD = 3, Du.SUBTYPE_UUID = 4, Du.SUBTYPE_MD5 = 5, Du.SUBTYPE_ENCRYPTED = 6, Du.SUBTYPE_COLUMN = 7, Du.SUBTYPE_USER_DEFINED = 128;
var zu = class extends Du {
  constructor(e2) {
    let t2, r2;
    if (null == e2)
      t2 = zu.generate();
    else if (e2 instanceof zu)
      t2 = Su.toLocalBufferType(new Uint8Array(e2.buffer)), r2 = e2.__id;
    else if (ArrayBuffer.isView(e2) && 16 === e2.byteLength)
      t2 = Su.toLocalBufferType(e2);
    else {
      if ("string" != typeof e2)
        throw new bu("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      t2 = Uu(e2);
    }
    super(t2, 4), this.__id = r2;
  }
  get id() {
    return this.buffer;
  }
  set id(e2) {
    this.buffer = e2, zu.cacheHexString && (this.__id = Lu(e2));
  }
  toHexString(e2 = true) {
    if (zu.cacheHexString && this.__id)
      return this.__id;
    const t2 = Lu(this.id, e2);
    return zu.cacheHexString && (this.__id = t2), t2;
  }
  toString(e2) {
    return "hex" === e2 ? Su.toHex(this.id) : "base64" === e2 ? Su.toBase64(this.id) : this.toHexString();
  }
  toJSON() {
    return this.toHexString();
  }
  equals(e2) {
    if (!e2)
      return false;
    if (e2 instanceof zu)
      return Su.equals(e2.id, this.id);
    try {
      return Su.equals(new zu(e2).id, this.id);
    } catch {
      return false;
    }
  }
  toBinary() {
    return new Du(this.id, Du.SUBTYPE_UUID);
  }
  static generate() {
    const e2 = Su.randomBytes(16);
    return e2[6] = 15 & e2[6] | 64, e2[8] = 63 & e2[8] | 128, e2;
  }
  static isValid(e2) {
    return !!e2 && (e2 instanceof zu || ("string" == typeof e2 ? Ou(e2) : !!Mu(e2) && 16 === e2.byteLength && 64 == (240 & e2[6]) && 128 == (128 & e2[8])));
  }
  static createFromHexString(e2) {
    const t2 = Uu(e2);
    return new zu(t2);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new UUID("${this.toHexString()}")`;
  }
};
var $u = class extends Ru {
  get _bsontype() {
    return "Code";
  }
  constructor(e2, t2) {
    super(), this.code = e2.toString(), this.scope = t2 != null ? t2 : null;
  }
  toJSON() {
    return null != this.scope ? { code: this.code, scope: this.scope } : { code: this.code };
  }
  toExtendedJSON() {
    return this.scope ? { $code: this.code, $scope: this.scope } : { $code: this.code };
  }
  static fromExtendedJSON(e2) {
    return new $u(e2.$code, e2.$scope);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    const e2 = this.toJSON();
    return `new Code("${String(e2.code)}"${null != e2.scope ? `, ${JSON.stringify(e2.scope)}` : ""})`;
  }
};
function Vu(e2) {
  return null != e2 && "object" == typeof e2 && "$id" in e2 && null != e2.$id && "$ref" in e2 && "string" == typeof e2.$ref && (!("$db" in e2) || "$db" in e2 && "string" == typeof e2.$db);
}
var ju = class extends Ru {
  get _bsontype() {
    return "DBRef";
  }
  constructor(e2, t2, r2, n2) {
    super();
    const i2 = e2.split(".");
    2 === i2.length && (r2 = i2.shift(), e2 = i2.shift()), this.collection = e2, this.oid = t2, this.db = r2, this.fields = n2 || {};
  }
  get namespace() {
    return this.collection;
  }
  set namespace(e2) {
    this.collection = e2;
  }
  toJSON() {
    const e2 = Object.assign({ $ref: this.collection, $id: this.oid }, this.fields);
    return null != this.db && (e2.$db = this.db), e2;
  }
  toExtendedJSON(e2) {
    let t2 = { $ref: this.collection, $id: this.oid };
    return (e2 = e2 || {}).legacy || (this.db && (t2.$db = this.db), t2 = Object.assign(t2, this.fields)), t2;
  }
  static fromExtendedJSON(e2) {
    const t2 = Object.assign({}, e2);
    return delete t2.$ref, delete t2.$id, delete t2.$db, new ju(e2.$ref, e2.$id, e2.$db, t2);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    const e2 = void 0 === this.oid || void 0 === this.oid.toString ? this.oid : this.oid.toString();
    return `new DBRef("${this.namespace}", new ObjectId("${String(e2)}")${this.db ? `, "${this.db}"` : ""})`;
  }
};
var Fu;
try {
  Fu = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
var Hu = 4294967296;
var Ku = 18446744073709552e3;
var Gu = Ku / 2;
var qu = {};
var Ju = {};
var Wu = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
var Zu = class extends Ru {
  get _bsontype() {
    return "Long";
  }
  get __isLong__() {
    return true;
  }
  constructor(e2 = 0, t2, r2) {
    super(), "bigint" == typeof e2 ? Object.assign(this, Zu.fromBigInt(e2, !!t2)) : "string" == typeof e2 ? Object.assign(this, Zu.fromString(e2, !!t2)) : (this.low = 0 | e2, this.high = 0 | t2, this.unsigned = !!r2);
  }
  static fromBits(e2, t2, r2) {
    return new Zu(e2, t2, r2);
  }
  static fromInt(e2, t2) {
    let r2, n2, i2;
    return t2 ? (i2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = Ju[e2], n2) ? n2 : (r2 = Zu.fromBits(e2, (0 | e2) < 0 ? -1 : 0, true), i2 && (Ju[e2] = r2), r2) : (i2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = qu[e2], n2) ? n2 : (r2 = Zu.fromBits(e2, e2 < 0 ? -1 : 0, false), i2 && (qu[e2] = r2), r2);
  }
  static fromNumber(e2, t2) {
    if (isNaN(e2))
      return t2 ? Zu.UZERO : Zu.ZERO;
    if (t2) {
      if (e2 < 0)
        return Zu.UZERO;
      if (e2 >= Ku)
        return Zu.MAX_UNSIGNED_VALUE;
    } else {
      if (e2 <= -Gu)
        return Zu.MIN_VALUE;
      if (e2 + 1 >= Gu)
        return Zu.MAX_VALUE;
    }
    return e2 < 0 ? Zu.fromNumber(-e2, t2).neg() : Zu.fromBits(e2 % Hu | 0, e2 / Hu | 0, t2);
  }
  static fromBigInt(e2, t2) {
    return Zu.fromString(e2.toString(), t2);
  }
  static fromString(e2, t2, r2) {
    if (0 === e2.length)
      throw new bu("empty string");
    if ("NaN" === e2 || "Infinity" === e2 || "+Infinity" === e2 || "-Infinity" === e2)
      return Zu.ZERO;
    if ("number" == typeof t2 ? (r2 = t2, t2 = false) : t2 = !!t2, (r2 = r2 || 10) < 2 || 36 < r2)
      throw new bu("radix");
    let n2;
    if ((n2 = e2.indexOf("-")) > 0)
      throw new bu("interior hyphen");
    if (0 === n2)
      return Zu.fromString(e2.substring(1), t2, r2).neg();
    const i2 = Zu.fromNumber(Math.pow(r2, 8));
    let o2 = Zu.ZERO;
    for (let t3 = 0; t3 < e2.length; t3 += 8) {
      const n3 = Math.min(8, e2.length - t3), s2 = parseInt(e2.substring(t3, t3 + n3), r2);
      if (n3 < 8) {
        const e3 = Zu.fromNumber(Math.pow(r2, n3));
        o2 = o2.mul(e3).add(Zu.fromNumber(s2));
      } else
        o2 = o2.mul(i2), o2 = o2.add(Zu.fromNumber(s2));
    }
    return o2.unsigned = t2, o2;
  }
  static fromBytes(e2, t2, r2) {
    return r2 ? Zu.fromBytesLE(e2, t2) : Zu.fromBytesBE(e2, t2);
  }
  static fromBytesLE(e2, t2) {
    return new Zu(e2[0] | e2[1] << 8 | e2[2] << 16 | e2[3] << 24, e2[4] | e2[5] << 8 | e2[6] << 16 | e2[7] << 24, t2);
  }
  static fromBytesBE(e2, t2) {
    return new Zu(e2[4] << 24 | e2[5] << 16 | e2[6] << 8 | e2[7], e2[0] << 24 | e2[1] << 16 | e2[2] << 8 | e2[3], t2);
  }
  static isLong(e2) {
    return null != e2 && "object" == typeof e2 && "__isLong__" in e2 && true === e2.__isLong__;
  }
  static fromValue(e2, t2) {
    return "number" == typeof e2 ? Zu.fromNumber(e2, t2) : "string" == typeof e2 ? Zu.fromString(e2, t2) : Zu.fromBits(e2.low, e2.high, "boolean" == typeof t2 ? t2 : e2.unsigned);
  }
  add(e2) {
    Zu.isLong(e2) || (e2 = Zu.fromValue(e2));
    let t2 = 0, r2 = 0, n2 = 0, i2 = 0;
    return i2 += (65535 & this.low) + (65535 & e2.low), n2 += i2 >>> 16, i2 &= 65535, n2 += (this.low >>> 16) + (e2.low >>> 16), r2 += n2 >>> 16, n2 &= 65535, r2 += (65535 & this.high) + (65535 & e2.high), t2 += r2 >>> 16, r2 &= 65535, t2 += (this.high >>> 16) + (e2.high >>> 16), t2 &= 65535, Zu.fromBits(n2 << 16 | i2, t2 << 16 | r2, this.unsigned);
  }
  and(e2) {
    return Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), Zu.fromBits(this.low & e2.low, this.high & e2.high, this.unsigned);
  }
  compare(e2) {
    if (Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), this.eq(e2))
      return 0;
    const t2 = this.isNegative(), r2 = e2.isNegative();
    return t2 && !r2 ? -1 : !t2 && r2 ? 1 : this.unsigned ? e2.high >>> 0 > this.high >>> 0 || e2.high === this.high && e2.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e2).isNegative() ? -1 : 1;
  }
  comp(e2) {
    return this.compare(e2);
  }
  divide(e2) {
    if (Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), e2.isZero())
      throw new bu("division by zero");
    if (Fu) {
      if (!this.unsigned && -2147483648 === this.high && -1 === e2.low && -1 === e2.high)
        return this;
      const t3 = (this.unsigned ? Fu.div_u : Fu.div_s)(this.low, this.high, e2.low, e2.high);
      return Zu.fromBits(t3, Fu.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? Zu.UZERO : Zu.ZERO;
    let t2, r2, n2;
    if (this.unsigned) {
      if (e2.unsigned || (e2 = e2.toUnsigned()), e2.gt(this))
        return Zu.UZERO;
      if (e2.gt(this.shru(1)))
        return Zu.UONE;
      n2 = Zu.UZERO;
    } else {
      if (this.eq(Zu.MIN_VALUE))
        return e2.eq(Zu.ONE) || e2.eq(Zu.NEG_ONE) ? Zu.MIN_VALUE : e2.eq(Zu.MIN_VALUE) ? Zu.ONE : (t2 = this.shr(1).div(e2).shl(1), t2.eq(Zu.ZERO) ? e2.isNegative() ? Zu.ONE : Zu.NEG_ONE : (r2 = this.sub(e2.mul(t2)), n2 = t2.add(r2.div(e2)), n2));
      if (e2.eq(Zu.MIN_VALUE))
        return this.unsigned ? Zu.UZERO : Zu.ZERO;
      if (this.isNegative())
        return e2.isNegative() ? this.neg().div(e2.neg()) : this.neg().div(e2).neg();
      if (e2.isNegative())
        return this.div(e2.neg()).neg();
      n2 = Zu.ZERO;
    }
    for (r2 = this; r2.gte(e2); ) {
      t2 = Math.max(1, Math.floor(r2.toNumber() / e2.toNumber()));
      const i2 = Math.ceil(Math.log(t2) / Math.LN2), o2 = i2 <= 48 ? 1 : Math.pow(2, i2 - 48);
      let s2 = Zu.fromNumber(t2), a2 = s2.mul(e2);
      for (; a2.isNegative() || a2.gt(r2); )
        t2 -= o2, s2 = Zu.fromNumber(t2, this.unsigned), a2 = s2.mul(e2);
      s2.isZero() && (s2 = Zu.ONE), n2 = n2.add(s2), r2 = r2.sub(a2);
    }
    return n2;
  }
  div(e2) {
    return this.divide(e2);
  }
  equals(e2) {
    return Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), (this.unsigned === e2.unsigned || this.high >>> 31 != 1 || e2.high >>> 31 != 1) && this.high === e2.high && this.low === e2.low;
  }
  eq(e2) {
    return this.equals(e2);
  }
  getHighBits() {
    return this.high;
  }
  getHighBitsUnsigned() {
    return this.high >>> 0;
  }
  getLowBits() {
    return this.low;
  }
  getLowBitsUnsigned() {
    return this.low >>> 0;
  }
  getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(Zu.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    const e2 = 0 !== this.high ? this.high : this.low;
    let t2;
    for (t2 = 31; t2 > 0 && 0 == (e2 & 1 << t2); t2--)
      ;
    return 0 !== this.high ? t2 + 33 : t2 + 1;
  }
  greaterThan(e2) {
    return this.comp(e2) > 0;
  }
  gt(e2) {
    return this.greaterThan(e2);
  }
  greaterThanOrEqual(e2) {
    return this.comp(e2) >= 0;
  }
  gte(e2) {
    return this.greaterThanOrEqual(e2);
  }
  ge(e2) {
    return this.greaterThanOrEqual(e2);
  }
  isEven() {
    return 0 == (1 & this.low);
  }
  isNegative() {
    return !this.unsigned && this.high < 0;
  }
  isOdd() {
    return 1 == (1 & this.low);
  }
  isPositive() {
    return this.unsigned || this.high >= 0;
  }
  isZero() {
    return 0 === this.high && 0 === this.low;
  }
  lessThan(e2) {
    return this.comp(e2) < 0;
  }
  lt(e2) {
    return this.lessThan(e2);
  }
  lessThanOrEqual(e2) {
    return this.comp(e2) <= 0;
  }
  lte(e2) {
    return this.lessThanOrEqual(e2);
  }
  modulo(e2) {
    if (Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), Fu) {
      const t2 = (this.unsigned ? Fu.rem_u : Fu.rem_s)(this.low, this.high, e2.low, e2.high);
      return Zu.fromBits(t2, Fu.get_high(), this.unsigned);
    }
    return this.sub(this.div(e2).mul(e2));
  }
  mod(e2) {
    return this.modulo(e2);
  }
  rem(e2) {
    return this.modulo(e2);
  }
  multiply(e2) {
    if (this.isZero())
      return Zu.ZERO;
    if (Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), Fu) {
      const t3 = Fu.mul(this.low, this.high, e2.low, e2.high);
      return Zu.fromBits(t3, Fu.get_high(), this.unsigned);
    }
    if (e2.isZero())
      return Zu.ZERO;
    if (this.eq(Zu.MIN_VALUE))
      return e2.isOdd() ? Zu.MIN_VALUE : Zu.ZERO;
    if (e2.eq(Zu.MIN_VALUE))
      return this.isOdd() ? Zu.MIN_VALUE : Zu.ZERO;
    if (this.isNegative())
      return e2.isNegative() ? this.neg().mul(e2.neg()) : this.neg().mul(e2).neg();
    if (e2.isNegative())
      return this.mul(e2.neg()).neg();
    if (this.lt(Zu.TWO_PWR_24) && e2.lt(Zu.TWO_PWR_24))
      return Zu.fromNumber(this.toNumber() * e2.toNumber(), this.unsigned);
    const t2 = 65535 & this.high, r2 = this.low >>> 16, n2 = 65535 & this.low, i2 = 65535 & e2.high, o2 = e2.low >>> 16, s2 = 65535 & e2.low;
    let a2 = 0, u2 = 0, h2 = 0, f2 = 0;
    return f2 += n2 * s2, h2 += f2 >>> 16, f2 &= 65535, h2 += r2 * s2, u2 += h2 >>> 16, h2 &= 65535, h2 += n2 * o2, u2 += h2 >>> 16, h2 &= 65535, u2 += t2 * s2, a2 += u2 >>> 16, u2 &= 65535, u2 += r2 * o2, a2 += u2 >>> 16, u2 &= 65535, u2 += n2 * i2, a2 += u2 >>> 16, u2 &= 65535, a2 += (this.high >>> 16) * s2 + t2 * o2 + r2 * i2 + n2 * (e2.high >>> 16), a2 &= 65535, Zu.fromBits(h2 << 16 | f2, a2 << 16 | u2, this.unsigned);
  }
  mul(e2) {
    return this.multiply(e2);
  }
  negate() {
    return !this.unsigned && this.eq(Zu.MIN_VALUE) ? Zu.MIN_VALUE : this.not().add(Zu.ONE);
  }
  neg() {
    return this.negate();
  }
  not() {
    return Zu.fromBits(~this.low, ~this.high, this.unsigned);
  }
  notEquals(e2) {
    return !this.equals(e2);
  }
  neq(e2) {
    return this.notEquals(e2);
  }
  ne(e2) {
    return this.notEquals(e2);
  }
  or(e2) {
    return Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), Zu.fromBits(this.low | e2.low, this.high | e2.high, this.unsigned);
  }
  shiftLeft(e2) {
    return Zu.isLong(e2) && (e2 = e2.toInt()), 0 == (e2 &= 63) ? this : e2 < 32 ? Zu.fromBits(this.low << e2, this.high << e2 | this.low >>> 32 - e2, this.unsigned) : Zu.fromBits(0, this.low << e2 - 32, this.unsigned);
  }
  shl(e2) {
    return this.shiftLeft(e2);
  }
  shiftRight(e2) {
    return Zu.isLong(e2) && (e2 = e2.toInt()), 0 == (e2 &= 63) ? this : e2 < 32 ? Zu.fromBits(this.low >>> e2 | this.high << 32 - e2, this.high >> e2, this.unsigned) : Zu.fromBits(this.high >> e2 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  }
  shr(e2) {
    return this.shiftRight(e2);
  }
  shiftRightUnsigned(e2) {
    if (Zu.isLong(e2) && (e2 = e2.toInt()), 0 == (e2 &= 63))
      return this;
    {
      const t2 = this.high;
      return e2 < 32 ? Zu.fromBits(this.low >>> e2 | t2 << 32 - e2, t2 >>> e2, this.unsigned) : Zu.fromBits(32 === e2 ? t2 : t2 >>> e2 - 32, 0, this.unsigned);
    }
  }
  shr_u(e2) {
    return this.shiftRightUnsigned(e2);
  }
  shru(e2) {
    return this.shiftRightUnsigned(e2);
  }
  subtract(e2) {
    return Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), this.add(e2.neg());
  }
  sub(e2) {
    return this.subtract(e2);
  }
  toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  }
  toNumber() {
    return this.unsigned ? (this.high >>> 0) * Hu + (this.low >>> 0) : this.high * Hu + (this.low >>> 0);
  }
  toBigInt() {
    return BigInt(this.toString());
  }
  toBytes(e2) {
    return e2 ? this.toBytesLE() : this.toBytesBE();
  }
  toBytesLE() {
    const e2 = this.high, t2 = this.low;
    return [255 & t2, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24, 255 & e2, e2 >>> 8 & 255, e2 >>> 16 & 255, e2 >>> 24];
  }
  toBytesBE() {
    const e2 = this.high, t2 = this.low;
    return [e2 >>> 24, e2 >>> 16 & 255, e2 >>> 8 & 255, 255 & e2, t2 >>> 24, t2 >>> 16 & 255, t2 >>> 8 & 255, 255 & t2];
  }
  toSigned() {
    return this.unsigned ? Zu.fromBits(this.low, this.high, false) : this;
  }
  toString(e2) {
    if ((e2 = e2 || 10) < 2 || 36 < e2)
      throw new bu("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(Zu.MIN_VALUE)) {
        const t3 = Zu.fromNumber(e2), r3 = this.div(t3), n3 = r3.mul(t3).sub(this);
        return r3.toString(e2) + n3.toInt().toString(e2);
      }
      return "-" + this.neg().toString(e2);
    }
    const t2 = Zu.fromNumber(Math.pow(e2, 6), this.unsigned);
    let r2 = this, n2 = "";
    for (; ; ) {
      const i2 = r2.div(t2);
      let o2 = (r2.sub(i2.mul(t2)).toInt() >>> 0).toString(e2);
      if (r2 = i2, r2.isZero())
        return o2 + n2;
      for (; o2.length < 6; )
        o2 = "0" + o2;
      n2 = "" + o2 + n2;
    }
  }
  toUnsigned() {
    return this.unsigned ? this : Zu.fromBits(this.low, this.high, true);
  }
  xor(e2) {
    return Zu.isLong(e2) || (e2 = Zu.fromValue(e2)), Zu.fromBits(this.low ^ e2.low, this.high ^ e2.high, this.unsigned);
  }
  eqz() {
    return this.isZero();
  }
  le(e2) {
    return this.lessThanOrEqual(e2);
  }
  toExtendedJSON(e2) {
    return e2 && e2.relaxed ? this.toNumber() : { $numberLong: this.toString() };
  }
  static fromExtendedJSON(e2, t2) {
    const { useBigInt64: r2 = false, relaxed: n2 = true } = { ...t2 };
    if (e2.$numberLong.length > 20)
      throw new bu("$numberLong string is too long");
    if (!Wu.test(e2.$numberLong))
      throw new bu(`$numberLong string "${e2.$numberLong}" is in an invalid format`);
    if (r2) {
      const t3 = BigInt(e2.$numberLong);
      return BigInt.asIntN(64, t3);
    }
    const i2 = Zu.fromString(e2.$numberLong);
    return n2 ? i2.toNumber() : i2;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new Long("${this.toString()}"${this.unsigned ? ", true" : ""})`;
  }
};
Zu.TWO_PWR_24 = Zu.fromInt(1 << 24), Zu.MAX_UNSIGNED_VALUE = Zu.fromBits(-1, -1, true), Zu.ZERO = Zu.fromInt(0), Zu.UZERO = Zu.fromInt(0, true), Zu.ONE = Zu.fromInt(1), Zu.UONE = Zu.fromInt(1, true), Zu.NEG_ONE = Zu.fromInt(-1), Zu.MAX_VALUE = Zu.fromBits(-1, 2147483647, false), Zu.MIN_VALUE = Zu.fromBits(0, -2147483648, false);
var Yu = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
var Xu = /^(\+|-)?(Infinity|inf)$/i;
var Qu = /^(\+|-)?NaN$/i;
var eh = 6111;
var th = -6176;
var rh = Su.fromNumberArray([124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse());
var nh = Su.fromNumberArray([248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse());
var ih = Su.fromNumberArray([120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse());
var oh = /^([-+])?(\d+)?$/;
function sh(e2) {
  return !isNaN(parseInt(e2, 10));
}
function ah(e2) {
  const t2 = Zu.fromNumber(1e9);
  let r2 = Zu.fromNumber(0);
  if (!(e2.parts[0] || e2.parts[1] || e2.parts[2] || e2.parts[3]))
    return { quotient: e2, rem: r2 };
  for (let n2 = 0; n2 <= 3; n2++)
    r2 = r2.shiftLeft(32), r2 = r2.add(new Zu(e2.parts[n2], 0)), e2.parts[n2] = r2.div(t2).low, r2 = r2.modulo(t2);
  return { quotient: e2, rem: r2 };
}
function uh(e2, t2) {
  throw new bu(`"${e2}" is not a valid Decimal128 string - ${t2}`);
}
var hh = class extends Ru {
  get _bsontype() {
    return "Decimal128";
  }
  constructor(e2) {
    if (super(), "string" == typeof e2)
      this.bytes = hh.fromString(e2).bytes;
    else {
      if (!Mu(e2))
        throw new bu("Decimal128 must take a Buffer or string");
      if (16 !== e2.byteLength)
        throw new bu("Decimal128 must take a Buffer of 16 bytes");
      this.bytes = e2;
    }
  }
  static fromString(e2) {
    let t2 = false, r2 = false, n2 = false, i2 = 0, o2 = 0, s2 = 0, a2 = 0, u2 = 0;
    const h2 = [0];
    let f2 = 0, c2 = 0, l2 = 0, d2 = 0, p2 = 0, y2 = 0, g2 = new Zu(0, 0), m2 = new Zu(0, 0), w2 = 0, b2 = 0;
    if (e2.length >= 7e3)
      throw new bu(e2 + " not a valid Decimal128 string");
    const v2 = e2.match(Yu), E2 = e2.match(Xu), x2 = e2.match(Qu);
    if (!v2 && !E2 && !x2 || 0 === e2.length)
      throw new bu(e2 + " not a valid Decimal128 string");
    if (v2) {
      const t3 = v2[2], r3 = v2[4], n3 = v2[5], i3 = v2[6];
      r3 && void 0 === i3 && uh(e2, "missing exponent power"), r3 && void 0 === t3 && uh(e2, "missing exponent base"), void 0 === r3 && (n3 || i3) && uh(e2, "missing e before exponent");
    }
    if ("+" !== e2[b2] && "-" !== e2[b2] || (t2 = "-" === e2[b2++]), !sh(e2[b2]) && "." !== e2[b2]) {
      if ("i" === e2[b2] || "I" === e2[b2])
        return new hh(t2 ? nh : ih);
      if ("N" === e2[b2])
        return new hh(rh);
    }
    for (; sh(e2[b2]) || "." === e2[b2]; )
      "." !== e2[b2] ? (f2 < 34 && ("0" !== e2[b2] || n2) && (n2 || (u2 = o2), n2 = true, h2[c2++] = parseInt(e2[b2], 10), f2 += 1), n2 && (s2 += 1), r2 && (a2 += 1), o2 += 1, b2 += 1) : (r2 && uh(e2, "contains multiple periods"), r2 = true, b2 += 1);
    if (r2 && !o2)
      throw new bu(e2 + " not a valid Decimal128 string");
    if ("e" === e2[b2] || "E" === e2[b2]) {
      const t3 = e2.substr(++b2).match(oh);
      if (!t3 || !t3[2])
        return new hh(rh);
      p2 = parseInt(t3[0], 10), b2 += t3[0].length;
    }
    if (e2[b2])
      return new hh(rh);
    if (l2 = 0, f2) {
      if (d2 = f2 - 1, i2 = s2, 1 !== i2)
        for (; 0 === h2[u2 + i2 - 1]; )
          i2 -= 1;
    } else
      l2 = 0, d2 = 0, h2[0] = 0, s2 = 1, f2 = 1, i2 = 0;
    for (p2 <= a2 && a2 - p2 > 16384 ? p2 = th : p2 -= a2; p2 > eh; ) {
      if (d2 += 1, d2 - l2 > 34) {
        if (h2.join("").match(/^0+$/)) {
          p2 = eh;
          break;
        }
        uh(e2, "overflow");
      }
      p2 -= 1;
    }
    for (; p2 < th || f2 < s2; ) {
      if (0 === d2 && i2 < f2) {
        p2 = th, i2 = 0;
        break;
      }
      if (f2 < s2 ? s2 -= 1 : d2 -= 1, p2 < eh)
        p2 += 1;
      else {
        if (h2.join("").match(/^0+$/)) {
          p2 = eh;
          break;
        }
        uh(e2, "overflow");
      }
    }
    if (d2 - l2 + 1 < i2) {
      let n3 = o2;
      r2 && (u2 += 1, n3 += 1), t2 && (u2 += 1, n3 += 1);
      const i3 = parseInt(e2[u2 + d2 + 1], 10);
      let s3 = 0;
      if (i3 >= 5 && (s3 = 1, 5 === i3)) {
        for (s3 = h2[d2] % 2 == 1 ? 1 : 0, y2 = u2 + d2 + 2; y2 < n3; y2++)
          if (parseInt(e2[y2], 10)) {
            s3 = 1;
            break;
          }
      }
      if (s3) {
        let e3 = d2;
        for (; e3 >= 0; e3--)
          if (++h2[e3] > 9 && (h2[e3] = 0, 0 === e3)) {
            if (!(p2 < eh))
              return new hh(t2 ? nh : ih);
            p2 += 1, h2[e3] = 1;
          }
      }
    }
    if (g2 = Zu.fromNumber(0), m2 = Zu.fromNumber(0), 0 === i2)
      g2 = Zu.fromNumber(0), m2 = Zu.fromNumber(0);
    else if (d2 - l2 < 17) {
      let e3 = l2;
      for (m2 = Zu.fromNumber(h2[e3++]), g2 = new Zu(0, 0); e3 <= d2; e3++)
        m2 = m2.multiply(Zu.fromNumber(10)), m2 = m2.add(Zu.fromNumber(h2[e3]));
    } else {
      let e3 = l2;
      for (g2 = Zu.fromNumber(h2[e3++]); e3 <= d2 - 17; e3++)
        g2 = g2.multiply(Zu.fromNumber(10)), g2 = g2.add(Zu.fromNumber(h2[e3]));
      for (m2 = Zu.fromNumber(h2[e3++]); e3 <= d2; e3++)
        m2 = m2.multiply(Zu.fromNumber(10)), m2 = m2.add(Zu.fromNumber(h2[e3]));
    }
    const B2 = function(e3, t3) {
      if (!e3 && !t3)
        return { high: Zu.fromNumber(0), low: Zu.fromNumber(0) };
      const r3 = e3.shiftRightUnsigned(32), n3 = new Zu(e3.getLowBits(), 0), i3 = t3.shiftRightUnsigned(32), o3 = new Zu(t3.getLowBits(), 0);
      let s3 = r3.multiply(i3), a3 = r3.multiply(o3);
      const u3 = n3.multiply(i3);
      let h3 = n3.multiply(o3);
      return s3 = s3.add(a3.shiftRightUnsigned(32)), a3 = new Zu(a3.getLowBits(), 0).add(u3).add(h3.shiftRightUnsigned(32)), s3 = s3.add(a3.shiftRightUnsigned(32)), h3 = a3.shiftLeft(32).add(new Zu(h3.getLowBits(), 0)), { high: s3, low: h3 };
    }(g2, Zu.fromString("100000000000000000"));
    B2.low = B2.low.add(m2), function(e3, t3) {
      const r3 = e3.high >>> 0, n3 = t3.high >>> 0;
      return r3 < n3 || r3 === n3 && e3.low >>> 0 < t3.low >>> 0;
    }(B2.low, m2) && (B2.high = B2.high.add(Zu.fromNumber(1))), w2 = p2 + 6176;
    const A2 = { low: Zu.fromNumber(0), high: Zu.fromNumber(0) };
    B2.high.shiftRightUnsigned(49).and(Zu.fromNumber(1)).equals(Zu.fromNumber(1)) ? (A2.high = A2.high.or(Zu.fromNumber(3).shiftLeft(61)), A2.high = A2.high.or(Zu.fromNumber(w2).and(Zu.fromNumber(16383).shiftLeft(47))), A2.high = A2.high.or(B2.high.and(Zu.fromNumber(140737488355327)))) : (A2.high = A2.high.or(Zu.fromNumber(16383 & w2).shiftLeft(49)), A2.high = A2.high.or(B2.high.and(Zu.fromNumber(562949953421311)))), A2.low = B2.low, t2 && (A2.high = A2.high.or(Zu.fromString("9223372036854775808")));
    const _2 = Su.allocate(16);
    return b2 = 0, _2[b2++] = 255 & A2.low.low, _2[b2++] = A2.low.low >> 8 & 255, _2[b2++] = A2.low.low >> 16 & 255, _2[b2++] = A2.low.low >> 24 & 255, _2[b2++] = 255 & A2.low.high, _2[b2++] = A2.low.high >> 8 & 255, _2[b2++] = A2.low.high >> 16 & 255, _2[b2++] = A2.low.high >> 24 & 255, _2[b2++] = 255 & A2.high.low, _2[b2++] = A2.high.low >> 8 & 255, _2[b2++] = A2.high.low >> 16 & 255, _2[b2++] = A2.high.low >> 24 & 255, _2[b2++] = 255 & A2.high.high, _2[b2++] = A2.high.high >> 8 & 255, _2[b2++] = A2.high.high >> 16 & 255, _2[b2++] = A2.high.high >> 24 & 255, new hh(_2);
  }
  toString() {
    let e2, t2 = 0;
    const r2 = new Array(36);
    for (let e3 = 0; e3 < r2.length; e3++)
      r2[e3] = 0;
    let n2, i2, o2, s2 = 0, a2 = false, u2 = { parts: [0, 0, 0, 0] };
    const h2 = [];
    s2 = 0;
    const f2 = this.bytes, c2 = f2[s2++] | f2[s2++] << 8 | f2[s2++] << 16 | f2[s2++] << 24, l2 = f2[s2++] | f2[s2++] << 8 | f2[s2++] << 16 | f2[s2++] << 24, d2 = f2[s2++] | f2[s2++] << 8 | f2[s2++] << 16 | f2[s2++] << 24, p2 = f2[s2++] | f2[s2++] << 8 | f2[s2++] << 16 | f2[s2++] << 24;
    s2 = 0, (new Zu(c2, l2), new Zu(d2, p2)).lessThan(Zu.ZERO) && h2.push("-");
    const y2 = p2 >> 26 & 31;
    if (y2 >> 3 == 3) {
      if (30 === y2)
        return h2.join("") + "Infinity";
      if (31 === y2)
        return "NaN";
      e2 = p2 >> 15 & 16383, n2 = 8 + (p2 >> 14 & 1);
    } else
      n2 = p2 >> 14 & 7, e2 = p2 >> 17 & 16383;
    const g2 = e2 - 6176;
    if (u2.parts[0] = (16383 & p2) + ((15 & n2) << 14), u2.parts[1] = d2, u2.parts[2] = l2, u2.parts[3] = c2, 0 === u2.parts[0] && 0 === u2.parts[1] && 0 === u2.parts[2] && 0 === u2.parts[3])
      a2 = true;
    else
      for (o2 = 3; o2 >= 0; o2--) {
        let e3 = 0;
        const t3 = ah(u2);
        if (u2 = t3.quotient, e3 = t3.rem.low, e3)
          for (i2 = 8; i2 >= 0; i2--)
            r2[9 * o2 + i2] = e3 % 10, e3 = Math.floor(e3 / 10);
      }
    if (a2)
      t2 = 1, r2[s2] = 0;
    else
      for (t2 = 36; !r2[s2]; )
        t2 -= 1, s2 += 1;
    const m2 = t2 - 1 + g2;
    if (m2 >= 34 || m2 <= -7 || g2 > 0) {
      if (t2 > 34)
        return h2.push("0"), g2 > 0 ? h2.push(`E+${g2}`) : g2 < 0 && h2.push(`E${g2}`), h2.join("");
      h2.push(`${r2[s2++]}`), t2 -= 1, t2 && h2.push(".");
      for (let e3 = 0; e3 < t2; e3++)
        h2.push(`${r2[s2++]}`);
      h2.push("E"), h2.push(m2 > 0 ? `+${m2}` : `${m2}`);
    } else if (g2 >= 0)
      for (let e3 = 0; e3 < t2; e3++)
        h2.push(`${r2[s2++]}`);
    else {
      let e3 = t2 + g2;
      if (e3 > 0)
        for (let t3 = 0; t3 < e3; t3++)
          h2.push(`${r2[s2++]}`);
      else
        h2.push("0");
      for (h2.push("."); e3++ < 0; )
        h2.push("0");
      for (let n3 = 0; n3 < t2 - Math.max(e3 - 1, 0); n3++)
        h2.push(`${r2[s2++]}`);
    }
    return h2.join("");
  }
  toJSON() {
    return { $numberDecimal: this.toString() };
  }
  toExtendedJSON() {
    return { $numberDecimal: this.toString() };
  }
  static fromExtendedJSON(e2) {
    return hh.fromString(e2.$numberDecimal);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new Decimal128("${this.toString()}")`;
  }
};
var fh = class extends Ru {
  get _bsontype() {
    return "Double";
  }
  constructor(e2) {
    super(), e2 instanceof Number && (e2 = e2.valueOf()), this.value = +e2;
  }
  valueOf() {
    return this.value;
  }
  toJSON() {
    return this.value;
  }
  toString(e2) {
    return this.value.toString(e2);
  }
  toExtendedJSON(e2) {
    return e2 && (e2.legacy || e2.relaxed && isFinite(this.value)) ? this.value : Object.is(Math.sign(this.value), -0) ? { $numberDouble: "-0.0" } : { $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString() };
  }
  static fromExtendedJSON(e2, t2) {
    const r2 = parseFloat(e2.$numberDouble);
    return t2 && t2.relaxed ? r2 : new fh(r2);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new Double(${this.toExtendedJSON().$numberDouble})`;
  }
};
var ch = class extends Ru {
  get _bsontype() {
    return "Int32";
  }
  constructor(e2) {
    super(), e2 instanceof Number && (e2 = e2.valueOf()), this.value = 0 | +e2;
  }
  valueOf() {
    return this.value;
  }
  toString(e2) {
    return this.value.toString(e2);
  }
  toJSON() {
    return this.value;
  }
  toExtendedJSON(e2) {
    return e2 && (e2.relaxed || e2.legacy) ? this.value : { $numberInt: this.value.toString() };
  }
  static fromExtendedJSON(e2, t2) {
    return t2 && t2.relaxed ? parseInt(e2.$numberInt, 10) : new ch(e2.$numberInt);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new Int32(${this.valueOf()})`;
  }
};
var lh = class extends Ru {
  get _bsontype() {
    return "MaxKey";
  }
  toExtendedJSON() {
    return { $maxKey: 1 };
  }
  static fromExtendedJSON() {
    return new lh();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return "new MaxKey()";
  }
};
var dh = class extends Ru {
  get _bsontype() {
    return "MinKey";
  }
  toExtendedJSON() {
    return { $minKey: 1 };
  }
  static fromExtendedJSON() {
    return new dh();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return "new MinKey()";
  }
};
var ph = new RegExp("^[0-9a-fA-F]{24}$");
var yh = null;
var gh = Symbol("id");
var mh = class extends Ru {
  get _bsontype() {
    return "ObjectId";
  }
  constructor(e2) {
    let t2;
    if (super(), "object" == typeof e2 && e2 && "id" in e2) {
      if ("string" != typeof e2.id && !ArrayBuffer.isView(e2.id))
        throw new bu("Argument passed in must have an id that is of type string or Buffer");
      t2 = "toHexString" in e2 && "function" == typeof e2.toHexString ? Su.fromHex(e2.toHexString()) : e2.id;
    } else
      t2 = e2;
    if (null == t2 || "number" == typeof t2)
      this[gh] = mh.generate("number" == typeof t2 ? t2 : void 0);
    else if (ArrayBuffer.isView(t2) && 12 === t2.byteLength)
      this[gh] = Su.toLocalBufferType(t2);
    else {
      if ("string" != typeof t2)
        throw new bu("Argument passed in does not match the accepted types");
      if (12 === t2.length) {
        const e3 = Su.fromUTF8(t2);
        if (12 !== e3.byteLength)
          throw new bu("Argument passed in must be a string of 12 bytes");
        this[gh] = e3;
      } else {
        if (24 !== t2.length || !ph.test(t2))
          throw new bu("Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer");
        this[gh] = Su.fromHex(t2);
      }
    }
    mh.cacheHexString && (this.__id = Su.toHex(this.id));
  }
  get id() {
    return this[gh];
  }
  set id(e2) {
    this[gh] = e2, mh.cacheHexString && (this.__id = Su.toHex(e2));
  }
  toHexString() {
    if (mh.cacheHexString && this.__id)
      return this.__id;
    const e2 = Su.toHex(this.id);
    return mh.cacheHexString && !this.__id && (this.__id = e2), e2;
  }
  static getInc() {
    return mh.index = (mh.index + 1) % 16777215;
  }
  static generate(e2) {
    "number" != typeof e2 && (e2 = Math.floor(Date.now() / 1e3));
    const t2 = mh.getInc(), r2 = Su.allocate(12);
    return Nu.fromUint8Array(r2).setUint32(0, e2, false), null === yh && (yh = Su.randomBytes(5)), r2[4] = yh[0], r2[5] = yh[1], r2[6] = yh[2], r2[7] = yh[3], r2[8] = yh[4], r2[11] = 255 & t2, r2[10] = t2 >> 8 & 255, r2[9] = t2 >> 16 & 255, r2;
  }
  toString(e2) {
    return "base64" === e2 ? Su.toBase64(this.id) : this.toHexString();
  }
  toJSON() {
    return this.toHexString();
  }
  equals(e2) {
    if (null == e2)
      return false;
    if (e2 instanceof mh)
      return this[gh][11] === e2[gh][11] && Su.equals(this[gh], e2[gh]);
    if ("string" == typeof e2 && mh.isValid(e2) && 12 === e2.length && Mu(this.id))
      return Su.equals(this.id, Su.fromISO88591(e2));
    if ("string" == typeof e2 && mh.isValid(e2) && 24 === e2.length)
      return e2.toLowerCase() === this.toHexString();
    if ("string" == typeof e2 && mh.isValid(e2) && 12 === e2.length)
      return Su.equals(Su.fromUTF8(e2), this.id);
    if ("object" == typeof e2 && "toHexString" in e2 && "function" == typeof e2.toHexString) {
      const t2 = e2.toHexString(), r2 = this.toHexString().toLowerCase();
      return "string" == typeof t2 && t2.toLowerCase() === r2;
    }
    return false;
  }
  getTimestamp() {
    const e2 = new Date(), t2 = Nu.fromUint8Array(this.id).getUint32(0, false);
    return e2.setTime(1e3 * Math.floor(t2)), e2;
  }
  static createPk() {
    return new mh();
  }
  static createFromTime(e2) {
    const t2 = Su.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    return Nu.fromUint8Array(t2).setUint32(0, e2, false), new mh(t2);
  }
  static createFromHexString(e2) {
    if (void 0 === e2 || null != e2 && 24 !== e2.length)
      throw new bu("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
    return new mh(Su.fromHex(e2));
  }
  static isValid(e2) {
    if (null == e2)
      return false;
    try {
      return new mh(e2), true;
    } catch {
      return false;
    }
  }
  toExtendedJSON() {
    return this.toHexString ? { $oid: this.toHexString() } : { $oid: this.toString("hex") };
  }
  static fromExtendedJSON(e2) {
    return new mh(e2.$oid);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new ObjectId("${this.toHexString()}")`;
  }
};
function wh(e2, t2, r2) {
  let n2 = 5;
  if (Array.isArray(e2))
    for (let i2 = 0; i2 < e2.length; i2++)
      n2 += bh(i2.toString(), e2[i2], t2, true, r2);
  else {
    "function" == typeof (e2 == null ? void 0 : e2.toBSON) && (e2 = e2.toBSON());
    for (const i2 of Object.keys(e2))
      n2 += bh(i2, e2[i2], t2, false, r2);
  }
  return n2;
}
function bh(e2, t2, r2 = false, n2 = false, i2 = false) {
  switch ("function" == typeof (t2 == null ? void 0 : t2.toBSON) && (t2 = t2.toBSON()), typeof t2) {
    case "string":
      return 1 + Su.utf8ByteLength(e2) + 1 + 4 + Su.utf8ByteLength(t2) + 1;
    case "number":
      return Math.floor(t2) === t2 && t2 >= gu && t2 <= yu && t2 >= lu && t2 <= cu ? (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 5 : (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 9;
    case "undefined":
      return n2 || !i2 ? (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 : 0;
    case "boolean":
      return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 2;
    case "object":
      if (null != t2 && "string" == typeof t2._bsontype && 5 !== t2[Symbol.for("@@mdb.bson.version")])
        throw new vu();
      if (null == t2 || "MinKey" === t2._bsontype || "MaxKey" === t2._bsontype)
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1;
      if ("ObjectId" === t2._bsontype)
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 13;
      if (t2 instanceof Date || Pu(t2))
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 9;
      if (ArrayBuffer.isView(t2) || t2 instanceof ArrayBuffer || ku(t2))
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 6 + t2.byteLength;
      if ("Long" === t2._bsontype || "Double" === t2._bsontype || "Timestamp" === t2._bsontype)
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 9;
      if ("Decimal128" === t2._bsontype)
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 17;
      if ("Code" === t2._bsontype)
        return null != t2.scope && Object.keys(t2.scope).length > 0 ? (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 + 4 + 4 + Su.utf8ByteLength(t2.code.toString()) + 1 + wh(t2.scope, r2, i2) : (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 + 4 + Su.utf8ByteLength(t2.code.toString()) + 1;
      if ("Binary" === t2._bsontype) {
        const r3 = t2;
        return r3.sub_type === Du.SUBTYPE_BYTE_ARRAY ? (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + (r3.position + 1 + 4 + 1 + 4) : (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + (r3.position + 1 + 4 + 1);
      }
      if ("Symbol" === t2._bsontype)
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + Su.utf8ByteLength(t2.value) + 4 + 1 + 1;
      if ("DBRef" === t2._bsontype) {
        const n3 = Object.assign({ $ref: t2.collection, $id: t2.oid }, t2.fields);
        return null != t2.db && (n3.$db = t2.db), (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 + wh(n3, r2, i2);
      }
      return t2 instanceof RegExp || Cu(t2) ? (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 + Su.utf8ByteLength(t2.source) + 1 + (t2.global ? 1 : 0) + (t2.ignoreCase ? 1 : 0) + (t2.multiline ? 1 : 0) + 1 : "BSONRegExp" === t2._bsontype ? (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 + Su.utf8ByteLength(t2.pattern) + 1 + Su.utf8ByteLength(t2.options) + 1 : (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + wh(t2, r2, i2) + 1;
    case "function":
      if (r2)
        return (null != e2 ? Su.utf8ByteLength(e2) + 1 : 0) + 1 + 4 + Su.utf8ByteLength(t2.toString()) + 1;
  }
  return 0;
}
mh.index = Math.floor(16777215 * Math.random());
var vh = class extends Ru {
  get _bsontype() {
    return "BSONRegExp";
  }
  constructor(e2, t2) {
    if (super(), this.pattern = e2, this.options = (t2 != null ? t2 : "").split("").sort().join(""), -1 !== this.pattern.indexOf("\0"))
      throw new bu(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
    if (-1 !== this.options.indexOf("\0"))
      throw new bu(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
    for (let e3 = 0; e3 < this.options.length; e3++)
      if ("i" !== this.options[e3] && "m" !== this.options[e3] && "x" !== this.options[e3] && "l" !== this.options[e3] && "s" !== this.options[e3] && "u" !== this.options[e3])
        throw new bu(`The regular expression option [${this.options[e3]}] is not supported`);
  }
  static parseOptions(e2) {
    return e2 ? e2.split("").sort().join("") : "";
  }
  toExtendedJSON(e2) {
    return (e2 = e2 || {}).legacy ? { $regex: this.pattern, $options: this.options } : { $regularExpression: { pattern: this.pattern, options: this.options } };
  }
  static fromExtendedJSON(e2) {
    if ("$regex" in e2) {
      if ("string" == typeof e2.$regex)
        return new vh(e2.$regex, vh.parseOptions(e2.$options));
      if ("BSONRegExp" === e2.$regex._bsontype)
        return e2;
    }
    if ("$regularExpression" in e2)
      return new vh(e2.$regularExpression.pattern, vh.parseOptions(e2.$regularExpression.options));
    throw new bu(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(e2)}`);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`;
  }
};
var Eh = class extends Ru {
  get _bsontype() {
    return "BSONSymbol";
  }
  constructor(e2) {
    super(), this.value = e2;
  }
  valueOf() {
    return this.value;
  }
  toString() {
    return this.value;
  }
  inspect() {
    return `new BSONSymbol("${this.value}")`;
  }
  toJSON() {
    return this.value;
  }
  toExtendedJSON() {
    return { $symbol: this.value };
  }
  static fromExtendedJSON(e2) {
    return new Eh(e2.$symbol);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
};
var xh = Zu;
var Bh = class extends xh {
  get _bsontype() {
    return "Timestamp";
  }
  constructor(e2) {
    if (null == e2)
      super(0, 0, true);
    else if ("bigint" == typeof e2)
      super(e2, true);
    else if (Zu.isLong(e2))
      super(e2.low, e2.high, true);
    else {
      if ("object" != typeof e2 || !("t" in e2) || !("i" in e2))
        throw new bu("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
      if ("number" != typeof e2.t && ("object" != typeof e2.t || "Int32" !== e2.t._bsontype))
        throw new bu("Timestamp constructed from { t, i } must provide t as a number");
      if ("number" != typeof e2.i && ("object" != typeof e2.i || "Int32" !== e2.i._bsontype))
        throw new bu("Timestamp constructed from { t, i } must provide i as a number");
      if (e2.t < 0)
        throw new bu("Timestamp constructed from { t, i } must provide a positive t");
      if (e2.i < 0)
        throw new bu("Timestamp constructed from { t, i } must provide a positive i");
      if (e2.t > 4294967295)
        throw new bu("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
      if (e2.i > 4294967295)
        throw new bu("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
      super(e2.i.valueOf(), e2.t.valueOf(), true);
    }
  }
  toJSON() {
    return { $timestamp: this.toString() };
  }
  static fromInt(e2) {
    return new Bh(Zu.fromInt(e2, true));
  }
  static fromNumber(e2) {
    return new Bh(Zu.fromNumber(e2, true));
  }
  static fromBits(e2, t2) {
    return new Bh({ i: e2, t: t2 });
  }
  static fromString(e2, t2) {
    return new Bh(Zu.fromString(e2, true, t2));
  }
  toExtendedJSON() {
    return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
  }
  static fromExtendedJSON(e2) {
    const t2 = Zu.isLong(e2.$timestamp.i) ? e2.$timestamp.i.getLowBitsUnsigned() : e2.$timestamp.i, r2 = Zu.isLong(e2.$timestamp.t) ? e2.$timestamp.t.getLowBitsUnsigned() : e2.$timestamp.t;
    return new Bh({ t: r2, i: t2 });
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.inspect();
  }
  inspect() {
    return `new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`;
  }
};
function Ah(e2, t2, r2) {
  let n2 = 0;
  for (let i2 = t2; i2 < r2; i2 += 1) {
    const t3 = e2[i2];
    if (n2) {
      if (128 != (192 & t3))
        return false;
      n2 -= 1;
    } else if (128 & t3)
      if (192 == (224 & t3))
        n2 = 1;
      else if (224 == (240 & t3))
        n2 = 2;
      else {
        if (240 != (248 & t3))
          return false;
        n2 = 3;
      }
  }
  return !n2;
}
Bh.MAX_VALUE = Zu.MAX_UNSIGNED_VALUE;
var _h = Zu.fromNumber(yu);
var Th = Zu.fromNumber(gu);
function Sh(e2, t2, r2) {
  const n2 = (t2 = null == t2 ? {} : t2) && t2.index ? t2.index : 0, i2 = e2[n2] | e2[n2 + 1] << 8 | e2[n2 + 2] << 16 | e2[n2 + 3] << 24;
  if (i2 < 5)
    throw new bu(`bson size must be >= 5, is ${i2}`);
  if (t2.allowObjectSmallerThanBufferSize && e2.length < i2)
    throw new bu(`buffer length ${e2.length} must be >= bson size ${i2}`);
  if (!t2.allowObjectSmallerThanBufferSize && e2.length !== i2)
    throw new bu(`buffer length ${e2.length} must === bson size ${i2}`);
  if (i2 + n2 > e2.byteLength)
    throw new bu(`(bson size ${i2} + options.index ${n2} must be <= buffer length ${e2.byteLength})`);
  if (0 !== e2[n2 + i2 - 1])
    throw new bu("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
  return Ih(e2, n2, t2, r2);
}
var Nh = /^\$ref$|^\$id$|^\$db$/;
function Ih(e2, t2, r2, n2 = false) {
  var _a3, _b, _c, _d;
  const i2 = null == r2.fieldsAsRaw ? null : r2.fieldsAsRaw, o2 = null != r2.raw && r2.raw, s2 = "boolean" == typeof r2.bsonRegExp && r2.bsonRegExp, a2 = (_a3 = r2.promoteBuffers) != null ? _a3 : false, u2 = (_b = r2.promoteLongs) != null ? _b : true, h2 = (_c = r2.promoteValues) != null ? _c : true, f2 = (_d = r2.useBigInt64) != null ? _d : false;
  if (f2 && !h2)
    throw new bu("Must either request bigint or Long for int64 deserialization");
  if (f2 && !u2)
    throw new bu("Must either request bigint or Long for int64 deserialization");
  const c2 = null == r2.validation ? { utf8: true } : r2.validation;
  let l2, d2 = true;
  const p2 = /* @__PURE__ */ new Set(), y2 = c2.utf8;
  if ("boolean" == typeof y2)
    l2 = y2;
  else {
    d2 = false;
    const e3 = Object.keys(y2).map(function(e4) {
      return y2[e4];
    });
    if (0 === e3.length)
      throw new bu("UTF-8 validation setting cannot be empty");
    if ("boolean" != typeof e3[0])
      throw new bu("Invalid UTF-8 validation option, must specify boolean values");
    if (l2 = e3[0], !e3.every((e4) => e4 === l2))
      throw new bu("Invalid UTF-8 validation option - keys must be all true or all false");
  }
  if (!d2)
    for (const e3 of Object.keys(y2))
      p2.add(e3);
  const g2 = t2;
  if (e2.length < 5)
    throw new bu("corrupt bson message < 5 bytes long");
  const m2 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
  if (m2 < 5 || m2 > e2.length)
    throw new bu("corrupt bson message");
  const w2 = n2 ? [] : {};
  let b2 = 0, v2 = !n2 && null;
  const E2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
  for (; ; ) {
    const y3 = e2[t2++];
    if (0 === y3)
      break;
    let g3 = t2;
    for (; 0 !== e2[g3] && g3 < e2.length; )
      g3++;
    if (g3 >= e2.byteLength)
      throw new bu("Bad BSON Document: illegal CString");
    const m3 = n2 ? b2++ : Su.toUTF8(e2.subarray(t2, g3));
    let x2, B2 = true;
    if (B2 = d2 || p2.has(m3) ? l2 : !l2, false !== v2 && "$" === m3[0] && (v2 = Nh.test(m3)), t2 = g3 + 1, 2 === y3) {
      const r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      if (r3 <= 0 || r3 > e2.length - t2 || 0 !== e2[t2 + r3 - 1])
        throw new bu("bad string length in bson");
      x2 = Oh(e2, t2, t2 + r3 - 1, B2), t2 += r3;
    } else if (7 === y3) {
      const r3 = Su.allocate(12);
      r3.set(e2.subarray(t2, t2 + 12)), x2 = new mh(r3), t2 += 12;
    } else if (y3 === mu && false === h2)
      x2 = new ch(e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24);
    else if (y3 === mu)
      x2 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
    else if (1 === y3 && false === h2)
      x2 = new fh(E2.getFloat64(t2, true)), t2 += 8;
    else if (1 === y3)
      x2 = E2.getFloat64(t2, true), t2 += 8;
    else if (9 === y3) {
      const r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24, n3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      x2 = new Date(new Zu(r3, n3).toNumber());
    } else if (8 === y3) {
      if (0 !== e2[t2] && 1 !== e2[t2])
        throw new bu("illegal boolean type value");
      x2 = 1 === e2[t2++];
    } else if (3 === y3) {
      const n3 = t2, i3 = e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24;
      if (i3 <= 0 || i3 > e2.length - t2)
        throw new bu("bad embedded document length in bson");
      if (o2)
        x2 = e2.slice(t2, t2 + i3);
      else {
        let t3 = r2;
        d2 || (t3 = { ...r2, validation: { utf8: B2 } }), x2 = Ih(e2, n3, t3, false);
      }
      t2 += i3;
    } else if (4 === y3) {
      const n3 = t2, o3 = e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24;
      let s3 = r2;
      const a3 = t2 + o3;
      if (i2 && i2[m3] && (s3 = { ...r2, raw: true }), d2 || (s3 = { ...s3, validation: { utf8: B2 } }), x2 = Ih(e2, n3, s3, true), 0 !== e2[(t2 += o3) - 1])
        throw new bu("invalid array terminator byte");
      if (t2 !== a3)
        throw new bu("corrupted array bson");
    } else if (6 === y3)
      x2 = void 0;
    else if (10 === y3)
      x2 = null;
    else if (18 === y3) {
      const r3 = Nu.fromUint8Array(e2.subarray(t2, t2 + 8)), n3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24, i3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24, o3 = new Zu(n3, i3);
      x2 = f2 ? r3.getBigInt64(0, true) : u2 && true === h2 && o3.lessThanOrEqual(_h) && o3.greaterThanOrEqual(Th) ? o3.toNumber() : o3;
    } else if (19 === y3) {
      const r3 = Su.allocate(16);
      r3.set(e2.subarray(t2, t2 + 16), 0), t2 += 16, x2 = new hh(r3);
    } else if (5 === y3) {
      let r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      const n3 = r3, i3 = e2[t2++];
      if (r3 < 0)
        throw new bu("Negative binary type element size found");
      if (r3 > e2.byteLength)
        throw new bu("Binary type size larger than document size");
      if (null != e2.slice) {
        if (i3 === Du.SUBTYPE_BYTE_ARRAY) {
          if (r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24, r3 < 0)
            throw new bu("Negative binary type element size found for subtype 0x02");
          if (r3 > n3 - 4)
            throw new bu("Binary type with subtype 0x02 contains too long binary size");
          if (r3 < n3 - 4)
            throw new bu("Binary type with subtype 0x02 contains too short binary size");
        }
        a2 && h2 ? x2 = Su.toLocalBufferType(e2.slice(t2, t2 + r3)) : (x2 = new Du(e2.slice(t2, t2 + r3), i3), 4 === i3 && (x2 = x2.toUUID()));
      } else {
        const o3 = Su.allocate(r3);
        if (i3 === Du.SUBTYPE_BYTE_ARRAY) {
          if (r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24, r3 < 0)
            throw new bu("Negative binary type element size found for subtype 0x02");
          if (r3 > n3 - 4)
            throw new bu("Binary type with subtype 0x02 contains too long binary size");
          if (r3 < n3 - 4)
            throw new bu("Binary type with subtype 0x02 contains too short binary size");
        }
        for (g3 = 0; g3 < r3; g3++)
          o3[g3] = e2[t2 + g3];
        x2 = a2 && h2 ? o3 : 4 === i3 ? new Du(e2.slice(t2, t2 + r3), i3).toUUID() : new Du(e2.slice(t2, t2 + r3), i3);
      }
      t2 += r3;
    } else if (11 === y3 && false === s2) {
      for (g3 = t2; 0 !== e2[g3] && g3 < e2.length; )
        g3++;
      if (g3 >= e2.length)
        throw new bu("Bad BSON Document: illegal CString");
      const r3 = Su.toUTF8(e2.subarray(t2, g3));
      for (g3 = t2 = g3 + 1; 0 !== e2[g3] && g3 < e2.length; )
        g3++;
      if (g3 >= e2.length)
        throw new bu("Bad BSON Document: illegal CString");
      const n3 = Su.toUTF8(e2.subarray(t2, g3));
      t2 = g3 + 1;
      const i3 = new Array(n3.length);
      for (g3 = 0; g3 < n3.length; g3++)
        switch (n3[g3]) {
          case "m":
            i3[g3] = "m";
            break;
          case "s":
            i3[g3] = "g";
            break;
          case "i":
            i3[g3] = "i";
        }
      x2 = new RegExp(r3, i3.join(""));
    } else if (11 === y3 && true === s2) {
      for (g3 = t2; 0 !== e2[g3] && g3 < e2.length; )
        g3++;
      if (g3 >= e2.length)
        throw new bu("Bad BSON Document: illegal CString");
      const r3 = Su.toUTF8(e2.subarray(t2, g3));
      for (g3 = t2 = g3 + 1; 0 !== e2[g3] && g3 < e2.length; )
        g3++;
      if (g3 >= e2.length)
        throw new bu("Bad BSON Document: illegal CString");
      const n3 = Su.toUTF8(e2.subarray(t2, g3));
      t2 = g3 + 1, x2 = new vh(r3, n3);
    } else if (14 === y3) {
      const r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      if (r3 <= 0 || r3 > e2.length - t2 || 0 !== e2[t2 + r3 - 1])
        throw new bu("bad string length in bson");
      const n3 = Oh(e2, t2, t2 + r3 - 1, B2);
      x2 = h2 ? n3 : new Eh(n3), t2 += r3;
    } else if (17 === y3) {
      const r3 = e2[t2++] + 256 * e2[t2++] + 65536 * e2[t2++] + e2[t2++] * (1 << 24), n3 = e2[t2++] + 256 * e2[t2++] + 65536 * e2[t2++] + e2[t2++] * (1 << 24);
      x2 = new Bh({ i: r3, t: n3 });
    } else if (255 === y3)
      x2 = new dh();
    else if (127 === y3)
      x2 = new lh();
    else if (13 === y3) {
      const r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      if (r3 <= 0 || r3 > e2.length - t2 || 0 !== e2[t2 + r3 - 1])
        throw new bu("bad string length in bson");
      const n3 = Oh(e2, t2, t2 + r3 - 1, B2);
      x2 = new $u(n3), t2 += r3;
    } else if (15 === y3) {
      const n3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      if (n3 < 13)
        throw new bu("code_w_scope total size shorter minimum expected length");
      const i3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
      if (i3 <= 0 || i3 > e2.length - t2 || 0 !== e2[t2 + i3 - 1])
        throw new bu("bad string length in bson");
      const o3 = Oh(e2, t2, t2 + i3 - 1, B2), s3 = e2[t2 += i3] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24, a3 = Ih(e2, t2, r2, false);
      if (t2 += s3, n3 < 8 + s3 + i3)
        throw new bu("code_w_scope total size is too short, truncating scope");
      if (n3 > 8 + s3 + i3)
        throw new bu("code_w_scope total size is too long, clips outer document");
      x2 = new $u(o3, a3);
    } else {
      if (12 !== y3)
        throw new bu(`Detected unknown BSON type ${y3.toString(16)} for fieldname "${m3}"`);
      {
        const r3 = e2[t2++] | e2[t2++] << 8 | e2[t2++] << 16 | e2[t2++] << 24;
        if (r3 <= 0 || r3 > e2.length - t2 || 0 !== e2[t2 + r3 - 1])
          throw new bu("bad string length in bson");
        if (null != c2 && c2.utf8 && !Ah(e2, t2, t2 + r3 - 1))
          throw new bu("Invalid UTF-8 string in BSON document");
        const n3 = Su.toUTF8(e2.subarray(t2, t2 + r3 - 1));
        t2 += r3;
        const i3 = Su.allocate(12);
        i3.set(e2.subarray(t2, t2 + 12), 0);
        const o3 = new mh(i3);
        t2 += 12, x2 = new ju(n3, o3);
      }
    }
    "__proto__" === m3 ? Object.defineProperty(w2, m3, { value: x2, writable: true, enumerable: true, configurable: true }) : w2[m3] = x2;
  }
  if (m2 !== t2 - g2) {
    if (n2)
      throw new bu("corrupt array bson");
    throw new bu("corrupt object bson");
  }
  if (!v2)
    return w2;
  if (Vu(w2)) {
    const e3 = Object.assign({}, w2);
    return delete e3.$ref, delete e3.$id, delete e3.$db, new ju(w2.$ref, w2.$id, w2.$db, e3);
  }
  return w2;
}
function Oh(e2, t2, r2, n2) {
  const i2 = Su.toUTF8(e2.subarray(t2, r2));
  if (n2) {
    for (let n3 = 0; n3 < i2.length; n3++)
      if (65533 === i2.charCodeAt(n3)) {
        if (!Ah(e2, t2, r2))
          throw new bu("Invalid UTF-8 string in BSON document");
        break;
      }
  }
  return i2;
}
var Uh = /\x00/;
var Lh = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
function kh(e2, t2, r2, n2) {
  e2[n2++] = 2, e2[(n2 = n2 + Su.encodeUTF8Into(e2, t2, n2) + 1) - 1] = 0;
  const i2 = Su.encodeUTF8Into(e2, r2, n2 + 4);
  return e2[n2 + 3] = i2 + 1 >> 24 & 255, e2[n2 + 2] = i2 + 1 >> 16 & 255, e2[n2 + 1] = i2 + 1 >> 8 & 255, e2[n2] = i2 + 1 & 255, n2 = n2 + 4 + i2, e2[n2++] = 0, n2;
}
var Mh = new DataView(new ArrayBuffer(8), 0, 8);
var Ch = new Uint8Array(Mh.buffer, 0, 4);
var Ph = new Uint8Array(Mh.buffer, 0, 8);
function Rh(e2, t2, r2, n2) {
  const i2 = !Object.is(r2, -0) && Number.isSafeInteger(r2) && r2 <= cu && r2 >= lu ? mu : 1;
  i2 === mu ? Mh.setInt32(0, r2, true) : Mh.setFloat64(0, r2, true);
  const o2 = i2 === mu ? Ch : Ph;
  return e2[n2++] = i2, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, e2.set(o2, n2), n2 + o2.byteLength;
}
function Dh(e2, t2, r2, n2) {
  return e2[n2++] = 18, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, Mh.setBigInt64(0, r2, true), e2.set(Ph, n2), n2 + Ph.byteLength;
}
function zh(e2, t2, r2, n2) {
  return e2[n2++] = 10, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, n2;
}
function $h(e2, t2, r2, n2) {
  return e2[n2++] = 8, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, e2[n2++] = r2 ? 1 : 0, n2;
}
function Vh(e2, t2, r2, n2) {
  e2[n2++] = 9, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const i2 = Zu.fromNumber(r2.getTime()), o2 = i2.getLowBits(), s2 = i2.getHighBits();
  return e2[n2++] = 255 & o2, e2[n2++] = o2 >> 8 & 255, e2[n2++] = o2 >> 16 & 255, e2[n2++] = o2 >> 24 & 255, e2[n2++] = 255 & s2, e2[n2++] = s2 >> 8 & 255, e2[n2++] = s2 >> 16 & 255, e2[n2++] = s2 >> 24 & 255, n2;
}
function jh(e2, t2, r2, n2) {
  if (e2[n2++] = 11, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, r2.source && null != r2.source.match(Uh))
    throw new bu("value " + r2.source + " must not contain null bytes");
  return n2 += Su.encodeUTF8Into(e2, r2.source, n2), e2[n2++] = 0, r2.ignoreCase && (e2[n2++] = 105), r2.global && (e2[n2++] = 115), r2.multiline && (e2[n2++] = 109), e2[n2++] = 0, n2;
}
function Fh(e2, t2, r2, n2) {
  if (e2[n2++] = 11, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, null != r2.pattern.match(Uh))
    throw new bu("pattern " + r2.pattern + " must not contain null bytes");
  n2 += Su.encodeUTF8Into(e2, r2.pattern, n2), e2[n2++] = 0;
  const i2 = r2.options.split("").sort().join("");
  return n2 += Su.encodeUTF8Into(e2, i2, n2), e2[n2++] = 0, n2;
}
function Hh(e2, t2, r2, n2) {
  return e2[n2++] = null === r2 ? 10 : "MinKey" === r2._bsontype ? 255 : 127, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, n2;
}
function Kh(e2, t2, r2, n2) {
  if (e2[n2++] = 7, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, !Mu(r2.id))
    throw new bu("object [" + JSON.stringify(r2) + "] is not a valid ObjectId");
  return e2.set(r2.id.subarray(0, 12), n2), n2 + 12;
}
function Gh(e2, t2, r2, n2) {
  e2[n2++] = 5, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const i2 = r2.length;
  return e2[n2++] = 255 & i2, e2[n2++] = i2 >> 8 & 255, e2[n2++] = i2 >> 16 & 255, e2[n2++] = i2 >> 24 & 255, e2[n2++] = 0, e2.set(r2, n2), n2 + i2;
}
function qh(e2, t2, r2, n2, i2, o2, s2, a2, u2) {
  if (u2.has(r2))
    throw new bu("Cannot convert circular structure to BSON");
  u2.add(r2), e2[n2++] = Array.isArray(r2) ? 4 : 3, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const h2 = nf(e2, r2, i2, n2, o2 + 1, s2, a2, u2);
  return u2.delete(r2), h2;
}
function Jh(e2, t2, r2, n2) {
  return e2[n2++] = 19, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, e2.set(r2.bytes.subarray(0, 16), n2), n2 + 16;
}
function Wh(e2, t2, r2, n2) {
  e2[n2++] = "Long" === r2._bsontype ? 18 : 17, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const i2 = r2.getLowBits(), o2 = r2.getHighBits();
  return e2[n2++] = 255 & i2, e2[n2++] = i2 >> 8 & 255, e2[n2++] = i2 >> 16 & 255, e2[n2++] = i2 >> 24 & 255, e2[n2++] = 255 & o2, e2[n2++] = o2 >> 8 & 255, e2[n2++] = o2 >> 16 & 255, e2[n2++] = o2 >> 24 & 255, n2;
}
function Zh(e2, t2, r2, n2) {
  return r2 = r2.valueOf(), e2[n2++] = mu, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, e2[n2++] = 255 & r2, e2[n2++] = r2 >> 8 & 255, e2[n2++] = r2 >> 16 & 255, e2[n2++] = r2 >> 24 & 255, n2;
}
function Yh(e2, t2, r2, n2) {
  return e2[n2++] = 1, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0, Mh.setFloat64(0, r2.value, true), e2.set(Ph, n2), n2 + 8;
}
function Xh(e2, t2, r2, n2) {
  e2[n2++] = 13, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const i2 = r2.toString(), o2 = Su.encodeUTF8Into(e2, i2, n2 + 4) + 1;
  return e2[n2] = 255 & o2, e2[n2 + 1] = o2 >> 8 & 255, e2[n2 + 2] = o2 >> 16 & 255, e2[n2 + 3] = o2 >> 24 & 255, n2 = n2 + 4 + o2 - 1, e2[n2++] = 0, n2;
}
function Qh(e2, t2, r2, n2, i2 = false, o2 = 0, s2 = false, a2 = true, u2) {
  if (r2.scope && "object" == typeof r2.scope) {
    e2[n2++] = 15, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
    let h2 = n2;
    const f2 = Su.encodeUTF8Into(e2, r2.code, (n2 += 4) + 4) + 1;
    e2[n2] = 255 & f2, e2[n2 + 1] = f2 >> 8 & 255, e2[n2 + 2] = f2 >> 16 & 255, e2[n2 + 3] = f2 >> 24 & 255, e2[n2 + 4 + f2 - 1] = 0;
    const c2 = nf(e2, r2.scope, i2, n2 = n2 + f2 + 4, o2 + 1, s2, a2, u2);
    n2 = c2 - 1;
    const l2 = c2 - h2;
    e2[h2++] = 255 & l2, e2[h2++] = l2 >> 8 & 255, e2[h2++] = l2 >> 16 & 255, e2[h2++] = l2 >> 24 & 255, e2[n2++] = 0;
  } else {
    e2[n2++] = 13, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
    const i3 = r2.code.toString(), o3 = Su.encodeUTF8Into(e2, i3, n2 + 4) + 1;
    e2[n2] = 255 & o3, e2[n2 + 1] = o3 >> 8 & 255, e2[n2 + 2] = o3 >> 16 & 255, e2[n2 + 3] = o3 >> 24 & 255, n2 = n2 + 4 + o3 - 1, e2[n2++] = 0;
  }
  return n2;
}
function ef(e2, t2, r2, n2) {
  e2[n2++] = 5, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const i2 = r2.buffer;
  let o2 = r2.position;
  return r2.sub_type === Du.SUBTYPE_BYTE_ARRAY && (o2 += 4), e2[n2++] = 255 & o2, e2[n2++] = o2 >> 8 & 255, e2[n2++] = o2 >> 16 & 255, e2[n2++] = o2 >> 24 & 255, e2[n2++] = r2.sub_type, r2.sub_type === Du.SUBTYPE_BYTE_ARRAY && (o2 -= 4, e2[n2++] = 255 & o2, e2[n2++] = o2 >> 8 & 255, e2[n2++] = o2 >> 16 & 255, e2[n2++] = o2 >> 24 & 255), e2.set(i2, n2), n2 + r2.position;
}
function tf(e2, t2, r2, n2) {
  e2[n2++] = 14, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  const i2 = Su.encodeUTF8Into(e2, r2.value, n2 + 4) + 1;
  return e2[n2] = 255 & i2, e2[n2 + 1] = i2 >> 8 & 255, e2[n2 + 2] = i2 >> 16 & 255, e2[n2 + 3] = i2 >> 24 & 255, n2 = n2 + 4 + i2 - 1, e2[n2++] = 0, n2;
}
function rf(e2, t2, r2, n2, i2, o2, s2) {
  e2[n2++] = 3, n2 += Su.encodeUTF8Into(e2, t2, n2), e2[n2++] = 0;
  let a2 = n2, u2 = { $ref: r2.collection || r2.namespace, $id: r2.oid };
  null != r2.db && (u2.$db = r2.db), u2 = Object.assign(u2, r2.fields);
  const h2 = nf(e2, u2, false, n2, i2 + 1, o2, true, s2), f2 = h2 - a2;
  return e2[a2++] = 255 & f2, e2[a2++] = f2 >> 8 & 255, e2[a2++] = f2 >> 16 & 255, e2[a2++] = f2 >> 24 & 255, h2;
}
function nf(e2, t2, r2, n2, i2, o2, s2, a2) {
  if (null == a2) {
    if (null == t2)
      return e2[0] = 5, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, 5;
    if (Array.isArray(t2))
      throw new bu("serialize does not support an array as the root input");
    if ("object" != typeof t2)
      throw new bu("serialize does not support non-object as the root input");
    if ("_bsontype" in t2 && "string" == typeof t2._bsontype)
      throw new bu("BSON types cannot be serialized as a document");
    if (Pu(t2) || Cu(t2) || Mu(t2) || ku(t2))
      throw new bu("date, regexp, typedarray, and arraybuffer cannot be BSON documents");
    a2 = /* @__PURE__ */ new Set();
  }
  a2.add(t2);
  let u2 = n2 + 4;
  if (Array.isArray(t2))
    for (let n3 = 0; n3 < t2.length; n3++) {
      const h3 = `${n3}`;
      let f2 = t2[n3];
      if ("function" == typeof (f2 == null ? void 0 : f2.toBSON) && (f2 = f2.toBSON()), "string" == typeof f2)
        u2 = kh(e2, h3, f2, u2);
      else if ("number" == typeof f2)
        u2 = Rh(e2, h3, f2, u2);
      else if ("bigint" == typeof f2)
        u2 = Dh(e2, h3, f2, u2);
      else if ("boolean" == typeof f2)
        u2 = $h(e2, h3, f2, u2);
      else if (f2 instanceof Date || Pu(f2))
        u2 = Vh(e2, h3, f2, u2);
      else if (void 0 === f2)
        u2 = zh(e2, h3, 0, u2);
      else if (null === f2)
        u2 = zh(e2, h3, 0, u2);
      else if (Mu(f2))
        u2 = Gh(e2, h3, f2, u2);
      else if (f2 instanceof RegExp || Cu(f2))
        u2 = jh(e2, h3, f2, u2);
      else if ("object" == typeof f2 && null == f2._bsontype)
        u2 = qh(e2, h3, f2, u2, r2, i2, o2, s2, a2);
      else {
        if ("object" == typeof f2 && 5 !== f2[Symbol.for("@@mdb.bson.version")])
          throw new vu();
        if ("ObjectId" === f2._bsontype)
          u2 = Kh(e2, h3, f2, u2);
        else if ("Decimal128" === f2._bsontype)
          u2 = Jh(e2, h3, f2, u2);
        else if ("Long" === f2._bsontype || "Timestamp" === f2._bsontype)
          u2 = Wh(e2, h3, f2, u2);
        else if ("Double" === f2._bsontype)
          u2 = Yh(e2, h3, f2, u2);
        else if ("function" == typeof f2 && o2)
          u2 = Xh(e2, h3, f2, u2);
        else if ("Code" === f2._bsontype)
          u2 = Qh(e2, h3, f2, u2, r2, i2, o2, s2, a2);
        else if ("Binary" === f2._bsontype)
          u2 = ef(e2, h3, f2, u2);
        else if ("BSONSymbol" === f2._bsontype)
          u2 = tf(e2, h3, f2, u2);
        else if ("DBRef" === f2._bsontype)
          u2 = rf(e2, h3, f2, u2, i2, o2, a2);
        else if ("BSONRegExp" === f2._bsontype)
          u2 = Fh(e2, h3, f2, u2);
        else if ("Int32" === f2._bsontype)
          u2 = Zh(e2, h3, f2, u2);
        else if ("MinKey" === f2._bsontype || "MaxKey" === f2._bsontype)
          u2 = Hh(e2, h3, f2, u2);
        else if (void 0 !== f2._bsontype)
          throw new bu(`Unrecognized or invalid _bsontype: ${String(f2._bsontype)}`);
      }
    }
  else if (t2 instanceof Map || "[object Map]" === Object.prototype.toString.call(t2)) {
    const n3 = t2.entries();
    let h3 = false;
    for (; !h3; ) {
      const t3 = n3.next();
      if (h3 = !!t3.done, h3)
        continue;
      const f2 = t3.value[0];
      let c2 = t3.value[1];
      "function" == typeof (c2 == null ? void 0 : c2.toBSON) && (c2 = c2.toBSON());
      const l2 = typeof c2;
      if ("string" == typeof f2 && !Lh.has(f2)) {
        if (null != f2.match(Uh))
          throw new bu("key " + f2 + " must not contain null bytes");
        if (r2) {
          if ("$" === f2[0])
            throw new bu("key " + f2 + " must not start with '$'");
          if (~f2.indexOf("."))
            throw new bu("key " + f2 + " must not contain '.'");
        }
      }
      if ("string" === l2)
        u2 = kh(e2, f2, c2, u2);
      else if ("number" === l2)
        u2 = Rh(e2, f2, c2, u2);
      else if ("bigint" === l2)
        u2 = Dh(e2, f2, c2, u2);
      else if ("boolean" === l2)
        u2 = $h(e2, f2, c2, u2);
      else if (c2 instanceof Date || Pu(c2))
        u2 = Vh(e2, f2, c2, u2);
      else if (null === c2 || void 0 === c2 && false === s2)
        u2 = zh(e2, f2, 0, u2);
      else if (Mu(c2))
        u2 = Gh(e2, f2, c2, u2);
      else if (c2 instanceof RegExp || Cu(c2))
        u2 = jh(e2, f2, c2, u2);
      else if ("object" === l2 && null == c2._bsontype)
        u2 = qh(e2, f2, c2, u2, r2, i2, o2, s2, a2);
      else {
        if ("object" == typeof c2 && 5 !== c2[Symbol.for("@@mdb.bson.version")])
          throw new vu();
        if ("ObjectId" === c2._bsontype)
          u2 = Kh(e2, f2, c2, u2);
        else if ("object" === l2 && "Decimal128" === c2._bsontype)
          u2 = Jh(e2, f2, c2, u2);
        else if ("Long" === c2._bsontype || "Timestamp" === c2._bsontype)
          u2 = Wh(e2, f2, c2, u2);
        else if ("Double" === c2._bsontype)
          u2 = Yh(e2, f2, c2, u2);
        else if ("Code" === c2._bsontype)
          u2 = Qh(e2, f2, c2, u2, r2, i2, o2, s2, a2);
        else if ("function" == typeof c2 && o2)
          u2 = Xh(e2, f2, c2, u2);
        else if ("Binary" === c2._bsontype)
          u2 = ef(e2, f2, c2, u2);
        else if ("BSONSymbol" === c2._bsontype)
          u2 = tf(e2, f2, c2, u2);
        else if ("DBRef" === c2._bsontype)
          u2 = rf(e2, f2, c2, u2, i2, o2, a2);
        else if ("BSONRegExp" === c2._bsontype)
          u2 = Fh(e2, f2, c2, u2);
        else if ("Int32" === c2._bsontype)
          u2 = Zh(e2, f2, c2, u2);
        else if ("MinKey" === c2._bsontype || "MaxKey" === c2._bsontype)
          u2 = Hh(e2, f2, c2, u2);
        else if (void 0 !== c2._bsontype)
          throw new bu(`Unrecognized or invalid _bsontype: ${String(c2._bsontype)}`);
      }
    }
  } else {
    if ("function" == typeof (t2 == null ? void 0 : t2.toBSON) && null != (t2 = t2.toBSON()) && "object" != typeof t2)
      throw new bu("toBSON function did not return an object");
    for (const n3 of Object.keys(t2)) {
      let h3 = t2[n3];
      "function" == typeof (h3 == null ? void 0 : h3.toBSON) && (h3 = h3.toBSON());
      const f2 = typeof h3;
      if ("string" == typeof n3 && !Lh.has(n3)) {
        if (null != n3.match(Uh))
          throw new bu("key " + n3 + " must not contain null bytes");
        if (r2) {
          if ("$" === n3[0])
            throw new bu("key " + n3 + " must not start with '$'");
          if (~n3.indexOf("."))
            throw new bu("key " + n3 + " must not contain '.'");
        }
      }
      if ("string" === f2)
        u2 = kh(e2, n3, h3, u2);
      else if ("number" === f2)
        u2 = Rh(e2, n3, h3, u2);
      else if ("bigint" === f2)
        u2 = Dh(e2, n3, h3, u2);
      else if ("boolean" === f2)
        u2 = $h(e2, n3, h3, u2);
      else if (h3 instanceof Date || Pu(h3))
        u2 = Vh(e2, n3, h3, u2);
      else if (void 0 === h3)
        false === s2 && (u2 = zh(e2, n3, 0, u2));
      else if (null === h3)
        u2 = zh(e2, n3, 0, u2);
      else if (Mu(h3))
        u2 = Gh(e2, n3, h3, u2);
      else if (h3 instanceof RegExp || Cu(h3))
        u2 = jh(e2, n3, h3, u2);
      else if ("object" === f2 && null == h3._bsontype)
        u2 = qh(e2, n3, h3, u2, r2, i2, o2, s2, a2);
      else {
        if ("object" == typeof h3 && 5 !== h3[Symbol.for("@@mdb.bson.version")])
          throw new vu();
        if ("ObjectId" === h3._bsontype)
          u2 = Kh(e2, n3, h3, u2);
        else if ("object" === f2 && "Decimal128" === h3._bsontype)
          u2 = Jh(e2, n3, h3, u2);
        else if ("Long" === h3._bsontype || "Timestamp" === h3._bsontype)
          u2 = Wh(e2, n3, h3, u2);
        else if ("Double" === h3._bsontype)
          u2 = Yh(e2, n3, h3, u2);
        else if ("Code" === h3._bsontype)
          u2 = Qh(e2, n3, h3, u2, r2, i2, o2, s2, a2);
        else if ("function" == typeof h3 && o2)
          u2 = Xh(e2, n3, h3, u2);
        else if ("Binary" === h3._bsontype)
          u2 = ef(e2, n3, h3, u2);
        else if ("BSONSymbol" === h3._bsontype)
          u2 = tf(e2, n3, h3, u2);
        else if ("DBRef" === h3._bsontype)
          u2 = rf(e2, n3, h3, u2, i2, o2, a2);
        else if ("BSONRegExp" === h3._bsontype)
          u2 = Fh(e2, n3, h3, u2);
        else if ("Int32" === h3._bsontype)
          u2 = Zh(e2, n3, h3, u2);
        else if ("MinKey" === h3._bsontype || "MaxKey" === h3._bsontype)
          u2 = Hh(e2, n3, h3, u2);
        else if (void 0 !== h3._bsontype)
          throw new bu(`Unrecognized or invalid _bsontype: ${String(h3._bsontype)}`);
      }
    }
  }
  a2.delete(t2), e2[u2++] = 0;
  const h2 = u2 - n2;
  return e2[n2++] = 255 & h2, e2[n2++] = h2 >> 8 & 255, e2[n2++] = h2 >> 16 & 255, e2[n2++] = h2 >> 24 & 255, u2;
}
var of = { $oid: mh, $binary: Du, $uuid: Du, $symbol: Eh, $numberInt: ch, $numberDecimal: hh, $numberDouble: fh, $numberLong: Zu, $minKey: dh, $maxKey: lh, $regex: vh, $regularExpression: vh, $timestamp: Bh };
function sf(e2, t2 = {}) {
  if ("number" == typeof e2) {
    const r3 = e2 <= cu && e2 >= lu, n2 = e2 <= du && e2 >= pu;
    if (t2.relaxed || t2.legacy)
      return e2;
    if (Number.isInteger(e2) && !Object.is(e2, -0)) {
      if (r3)
        return new ch(e2);
      if (n2)
        return t2.useBigInt64 ? BigInt(e2) : Zu.fromNumber(e2);
    }
    return new fh(e2);
  }
  if (null == e2 || "object" != typeof e2)
    return e2;
  if (e2.$undefined)
    return null;
  const r2 = Object.keys(e2).filter((t3) => t3.startsWith("$") && null != e2[t3]);
  for (let n2 = 0; n2 < r2.length; n2++) {
    const i2 = of[r2[n2]];
    if (i2)
      return i2.fromExtendedJSON(e2, t2);
  }
  if (null != e2.$date) {
    const r3 = e2.$date, n2 = new Date();
    if (t2.legacy)
      if ("number" == typeof r3)
        n2.setTime(r3);
      else if ("string" == typeof r3)
        n2.setTime(Date.parse(r3));
      else {
        if ("bigint" != typeof r3)
          throw new Eu("Unrecognized type for EJSON date: " + typeof r3);
        n2.setTime(Number(r3));
      }
    else if ("string" == typeof r3)
      n2.setTime(Date.parse(r3));
    else if (Zu.isLong(r3))
      n2.setTime(r3.toNumber());
    else if ("number" == typeof r3 && t2.relaxed)
      n2.setTime(r3);
    else {
      if ("bigint" != typeof r3)
        throw new Eu("Unrecognized type for EJSON date: " + typeof r3);
      n2.setTime(Number(r3));
    }
    return n2;
  }
  if (null != e2.$code) {
    const t3 = Object.assign({}, e2);
    return e2.$scope && (t3.$scope = sf(e2.$scope)), $u.fromExtendedJSON(e2);
  }
  if (Vu(e2) || e2.$dbPointer) {
    const t3 = e2.$ref ? e2 : e2.$dbPointer;
    if (t3 instanceof ju)
      return t3;
    const r3 = Object.keys(t3).filter((e3) => e3.startsWith("$"));
    let n2 = true;
    if (r3.forEach((e3) => {
      -1 === ["$ref", "$id", "$db"].indexOf(e3) && (n2 = false);
    }), n2)
      return ju.fromExtendedJSON(t3);
  }
  return e2;
}
function af(e2) {
  const t2 = e2.toISOString();
  return 0 !== e2.getUTCMilliseconds() ? t2 : t2.slice(0, -5) + "Z";
}
function uf(e2, t2) {
  if (("object" == typeof e2 || "function" == typeof e2) && null !== e2) {
    const r2 = t2.seenObjects.findIndex((t3) => t3.obj === e2);
    if (-1 !== r2) {
      const e3 = t2.seenObjects.map((e4) => e4.propertyName), n2 = e3.slice(0, r2).map((e4) => `${e4} -> `).join(""), i2 = e3[r2], o2 = " -> " + e3.slice(r2 + 1, e3.length - 1).map((e4) => `${e4} -> `).join(""), s2 = e3[e3.length - 1], a2 = " ".repeat(n2.length + i2.length / 2), u2 = "-".repeat(o2.length + (i2.length + s2.length) / 2 - 1);
      throw new bu(`Converting circular structure to EJSON:
    ${n2}${i2}${o2}${s2}
    ${a2}\\${u2}/`);
    }
    t2.seenObjects[t2.seenObjects.length - 1].obj = e2;
  }
  if (Array.isArray(e2))
    return function(e3, t3) {
      return e3.map((e4, r2) => {
        t3.seenObjects.push({ propertyName: `index ${r2}`, obj: null });
        try {
          return uf(e4, t3);
        } finally {
          t3.seenObjects.pop();
        }
      });
    }(e2, t2);
  if (void 0 === e2)
    return null;
  if (e2 instanceof Date || Pu(e2)) {
    const r2 = e2.getTime(), n2 = r2 > -1 && r2 < 2534023188e5;
    return t2.legacy ? t2.relaxed && n2 ? { $date: e2.getTime() } : { $date: af(e2) } : t2.relaxed && n2 ? { $date: af(e2) } : { $date: { $numberLong: e2.getTime().toString() } };
  }
  if (!("number" != typeof e2 || t2.relaxed && isFinite(e2))) {
    if (Number.isInteger(e2) && !Object.is(e2, -0)) {
      if (e2 >= lu && e2 <= cu)
        return { $numberInt: e2.toString() };
      if (e2 >= pu && e2 <= du)
        return { $numberLong: e2.toString() };
    }
    return { $numberDouble: Object.is(e2, -0) ? "-0.0" : e2.toString() };
  }
  if ("bigint" == typeof e2)
    return t2.relaxed ? Number(BigInt.asIntN(64, e2)) : { $numberLong: BigInt.asIntN(64, e2).toString() };
  if (e2 instanceof RegExp || Cu(e2)) {
    let r2 = e2.flags;
    if (void 0 === r2) {
      const t3 = e2.toString().match(/[gimuy]*$/);
      t3 && (r2 = t3[0]);
    }
    return new vh(e2.source, r2).toExtendedJSON(t2);
  }
  return null != e2 && "object" == typeof e2 ? function(e3, t3) {
    if (null == e3 || "object" != typeof e3)
      throw new bu("not an object instance");
    const r2 = e3._bsontype;
    if (void 0 === r2) {
      const r3 = {};
      for (const n2 of Object.keys(e3)) {
        t3.seenObjects.push({ propertyName: n2, obj: null });
        try {
          const i2 = uf(e3[n2], t3);
          "__proto__" === n2 ? Object.defineProperty(r3, n2, { value: i2, writable: true, enumerable: true, configurable: true }) : r3[n2] = i2;
        } finally {
          t3.seenObjects.pop();
        }
      }
      return r3;
    }
    if (null != e3 && "object" == typeof e3 && "string" == typeof e3._bsontype && 5 !== e3[Symbol.for("@@mdb.bson.version")])
      throw new vu();
    if (function(e4) {
      return null != e4 && "object" == typeof e4 && "_bsontype" in e4 && "string" == typeof e4._bsontype;
    }(e3)) {
      let n2 = e3;
      if ("function" != typeof n2.toExtendedJSON) {
        const t4 = hf[e3._bsontype];
        if (!t4)
          throw new bu("Unrecognized or invalid _bsontype: " + e3._bsontype);
        n2 = t4(n2);
      }
      return "Code" === r2 && n2.scope ? n2 = new $u(n2.code, uf(n2.scope, t3)) : "DBRef" === r2 && n2.oid && (n2 = new ju(uf(n2.collection, t3), uf(n2.oid, t3), uf(n2.db, t3), uf(n2.fields, t3))), n2.toExtendedJSON(t3);
    }
    throw new bu("_bsontype must be a string, but was: " + typeof r2);
  }(e2, t2) : e2;
}
var hf = { Binary: (e2) => new Du(e2.value(), e2.sub_type), Code: (e2) => new $u(e2.code, e2.scope), DBRef: (e2) => new ju(e2.collection || e2.namespace, e2.oid, e2.db, e2.fields), Decimal128: (e2) => new hh(e2.bytes), Double: (e2) => new fh(e2.value), Int32: (e2) => new ch(e2.value), Long: (e2) => Zu.fromBits(null != e2.low ? e2.low : e2.low_, null != e2.low ? e2.high : e2.high_, null != e2.low ? e2.unsigned : e2.unsigned_), MaxKey: () => new lh(), MinKey: () => new dh(), ObjectId: (e2) => new mh(e2), BSONRegExp: (e2) => new vh(e2.pattern, e2.options), BSONSymbol: (e2) => new Eh(e2.value), Timestamp: (e2) => Bh.fromBits(e2.low, e2.high) };
function ff(e2, t2) {
  var _a3, _b, _c;
  const r2 = { useBigInt64: (_a3 = t2 == null ? void 0 : t2.useBigInt64) != null ? _a3 : false, relaxed: (_b = t2 == null ? void 0 : t2.relaxed) != null ? _b : true, legacy: (_c = t2 == null ? void 0 : t2.legacy) != null ? _c : false };
  return JSON.parse(e2, (e3, t3) => {
    if (-1 !== e3.indexOf("\0"))
      throw new bu(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(e3)}`);
    return sf(t3, r2);
  });
}
function cf(e2, t2, r2, n2) {
  null != r2 && "object" == typeof r2 && (n2 = r2, r2 = 0), null == t2 || "object" != typeof t2 || Array.isArray(t2) || (n2 = t2, t2 = void 0, r2 = 0);
  const i2 = uf(e2, Object.assign({ relaxed: true, legacy: false }, n2, { seenObjects: [{ propertyName: "(root)", obj: null }] }));
  return JSON.stringify(i2, t2, r2);
}
var lf = /* @__PURE__ */ Object.create(null);
lf.parse = ff, lf.stringify = cf, lf.serialize = function(e2, t2) {
  return t2 = t2 || {}, JSON.parse(cf(e2, t2));
}, lf.deserialize = function(e2, t2) {
  return t2 = t2 || {}, ff(JSON.stringify(e2), t2);
}, Object.freeze(lf);
var df = 17825792;
var pf = Su.allocate(df);
var yf;
var gf = Object.freeze({ __proto__: null, Code: $u, BSONSymbol: Eh, DBRef: ju, Binary: Du, ObjectId: mh, UUID: zu, Long: Zu, Timestamp: Bh, Double: fh, Int32: ch, MinKey: dh, MaxKey: lh, BSONRegExp: vh, Decimal128: hh, setInternalBufferSize: function(e2) {
  pf.length < e2 && (pf = Su.allocate(e2));
}, serialize: function(e2, t2 = {}) {
  const r2 = "boolean" == typeof t2.checkKeys && t2.checkKeys, n2 = "boolean" == typeof t2.serializeFunctions && t2.serializeFunctions, i2 = "boolean" != typeof t2.ignoreUndefined || t2.ignoreUndefined, o2 = "number" == typeof t2.minInternalBufferSize ? t2.minInternalBufferSize : df;
  pf.length < o2 && (pf = Su.allocate(o2));
  const s2 = nf(pf, e2, r2, 0, 0, n2, i2, null), a2 = Su.allocate(s2);
  return a2.set(pf.subarray(0, s2), 0), a2;
}, serializeWithBufferAndIndex: function(e2, t2, r2 = {}) {
  const n2 = "number" == typeof r2.index ? r2.index : 0, i2 = nf(pf, e2, "boolean" == typeof r2.checkKeys && r2.checkKeys, 0, 0, "boolean" == typeof r2.serializeFunctions && r2.serializeFunctions, "boolean" != typeof r2.ignoreUndefined || r2.ignoreUndefined, null);
  return t2.set(pf.subarray(0, i2), n2), n2 + i2 - 1;
}, deserialize: function(e2, t2 = {}) {
  return Sh(Su.toLocalBufferType(e2), t2);
}, calculateObjectSize: function(e2, t2 = {}) {
  return wh(e2, "boolean" == typeof (t2 = t2 || {}).serializeFunctions && t2.serializeFunctions, "boolean" != typeof t2.ignoreUndefined || t2.ignoreUndefined);
}, deserializeStream: function(e2, t2, r2, n2, i2, o2) {
  const s2 = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, o2), a2 = Su.toLocalBufferType(e2);
  let u2 = t2;
  for (let e3 = 0; e3 < r2; e3++) {
    const t3 = a2[u2] | a2[u2 + 1] << 8 | a2[u2 + 2] << 16 | a2[u2 + 3] << 24;
    s2.index = u2, n2[i2 + e3] = Sh(a2, s2), u2 += t3;
  }
  return u2;
}, BSONValue: Ru, BSONError: bu, BSONVersionError: vu, BSONRuntimeError: Eu, BSONType: wu, EJSON: lf });
var mf = class {
  constructor(e2, t2) {
    this.provider = void 0, this.querySessionInfo = void 0, this.sessionToken = void 0, this.wallet = void 0, this.provider = new hu(e2, t2), this.wallet = t2;
  }
  async createDatabase() {
    const e2 = { nonce: this.provider.getNonce().toString(), chainId: Os.MainNet, chainRole: Is.StorageShardChain }, t2 = { meta: e2, collectionMutations: [], documentMutations: [], dbAddress: new Uint8Array(), action: Gs.CreateDB }, r2 = Js.toBinary(t2), n2 = await this.provider.sendMutation(r2, qs.DatabasePayload);
    return [new uu(this.wallet.getAddress(), +e2.nonce).getHexAddr(), n2.getB64()];
  }
  async getDatabase(e2) {
    const t2 = await this.keepSessionAlive(), r2 = await this.provider.getDatabase(e2, t2);
    return this.querySessionInfo.queryCount += 1, r2.db;
  }
  async listCollection(e2) {
    const t2 = await this.getDatabase(e2);
    return null == t2 ? void 0 : t2.collections;
  }
  async createCollection(e2, t2, r2) {
    const n2 = { meta: { nonce: this.provider.getNonce().toString(), chainId: Os.MainNet, chainRole: Is.StorageShardChain }, collectionMutations: [{ index: r2, collectionName: t2 }], documentMutations: [], dbAddress: ut(e2), action: Gs.AddCollection }, i2 = Js.toBinary(n2);
    return (await this.provider.sendMutation(i2, qs.DatabasePayload)).getB64();
  }
  async getState() {
    return await this.provider.getState();
  }
  async getAccount(e2) {
    const t2 = ut(e2);
    return await this.provider.getAccount(t2);
  }
  async createDocument(e2, t2, r2) {
    const n2 = { collectionName: t2, documents: [gf.serialize(r2)], ids: [], masks: [] }, i2 = { meta: { nonce: this.provider.getNonce().toString(), chainId: Os.MainNet, chainRole: Is.StorageShardChain }, action: Gs.AddDocument, dbAddress: ut(e2), collectionMutations: [], documentMutations: [n2] }, o2 = Js.toBinary(i2);
    return (await this.provider.sendMutation(o2, qs.DatabasePayload)).getB64();
  }
  async getDocument(e2) {
    const t2 = await this.keepSessionAlive(), r2 = await this.provider.getDocument(t2, e2);
    return { id: lt(r2.document.id), doc: gf.deserialize(r2.document.doc), owner: "0x" + ht(r2.document.owner), tx: lt(r2.document.txId) };
  }
  async runQuery(e2, t2) {
    const r2 = await this.keepSessionAlive();
    return (await this.provider.runQuery(r2, e2, t2)).documents.map((e3) => ({ doc: gf.deserialize(e3.doc), id: lt(e3.id), owner: "0x" + ht(e3.owner), tx: lt(e3.txId) }));
  }
  async deleteDocument(e2, t2, r2) {
    const n2 = { meta: { nonce: this.provider.getNonce().toString(), chainId: Os.MainNet, chainRole: Is.StorageShardChain }, collectionMutations: [], documentMutations: [{ collectionName: t2, documents: [], ids: r2, masks: [] }], dbAddress: ut(e2), action: Gs.DeleteDocument }, i2 = Js.toBinary(n2);
    return this.provider.sendMutation(i2, qs.DatabasePayload);
  }
  async updateDocument(e2, t2, r2, n2, i2) {
    const o2 = { fields: i2 }, s2 = { meta: { nonce: this.provider.getNonce().toString(), chainId: Os.MainNet, chainRole: Is.StorageShardChain }, collectionMutations: [], documentMutations: [{ collectionName: t2, documents: [gf.serialize(r2)], ids: [n2], masks: [o2] }], dbAddress: ut(e2), action: Gs.UpdateDocument }, a2 = Js.toBinary(s2);
    return this.provider.sendMutation(a2, qs.DatabasePayload);
  }
  async keepSessionAlive() {
    if (!this.querySessionInfo || !this.sessionToken) {
      const e2 = await this.provider.openSession();
      return this.sessionToken = e2.sessionToken, this.querySessionInfo = e2.querySessionInfo, fu.info("create a new session token ", e2.sessionToken), this.sessionToken;
    }
    if (this.querySessionInfo.queryCount > 1e3) {
      fu.info("submit query session with count ", this.querySessionInfo.queryCount), await this.provider.closeSession(this.sessionToken, this.querySessionInfo);
      const e2 = await this.provider.openSession();
      return this.sessionToken = e2.sessionToken, this.querySessionInfo = e2.querySessionInfo, fu.info("create a new session token ", e2.sessionToken), this.sessionToken;
    }
    if (!this.sessionToken)
      throw fu.warn("no session token"), new Error("sessioToken is not found");
    return this.sessionToken;
  }
};
var wf = class {
  constructor(e2, t2) {
    this.address = void 0, this.client = void 0, this._database = void 0, this._collections = void 0, this.address = e2, this.client = t2, this._database = void 0, this._collections = void 0;
  }
  async getCollections(e2) {
    if (this._database && this._collections && this._collections[e2])
      return this._collections[e2];
    const t2 = await this.client.getDatabase(this.address);
    return this._database = t2, this._collections = null == t2 ? void 0 : t2.collections, this._collections && this._collections[e2] ? this._collections[e2] : void 0;
  }
  async getDatabase() {
    if (!this._database) {
      const e2 = await this.client.getDatabase(this.address);
      this._database = e2, this._collections = null == e2 ? void 0 : e2.collections;
    }
    return this._database;
  }
};
var bf = class {
  constructor(e2, t2) {
    this.address = void 0, this.client = void 0, this.address = e2, this.client = t2;
  }
  async getAccount() {
    await this.client.getAccount(this.address);
  }
};
function vf(e2) {
  var t2 = 0, r2 = e2, n2 = e2;
  for (r2 >>= 10; r2 > 0 && t2 < 7; )
    n2 /= 1024, t2 += 1, r2 >>= 10;
  return n2.toFixed(2) + [" ", "K", "M", "G", "T", "P", "E"][t2];
}
function Ef(e2) {
  return (e2 / 1e9).toFixed(6);
}
var xf = class {
  constructor(e2) {
    this.client = void 0, this.client = e2;
  }
  async getState() {
    return await this.client.getState();
  }
};
function Bf(e2, t2, r2) {
  const n2 = new mf(e2, r2);
  return { db: new wf(t2, n2), db3Account: new bf(r2.getAddress(), n2), db3Network: new xf(n2) };
}
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, Af.apply(this, arguments);
}
!function(e2) {
  e2.LESS_THAN = "<", e2.LESS_THAN_OR_EQUAL = "<=", e2.EQUAL = "==", e2.NOT_EQUAL = "!=", e2.GREATER_THAN = ">", e2.GREATER_THAN_OR_EQUAL = ">=", e2.ARRAY_CONTAINS = "array-contains", e2.IN = "in", e2.NOT_IN = "not-in", e2.ARRAY_CONTAINS_ANY = "array-contains-any";
}(yf || (yf = {}));
var _f = class {
  constructor(e2, t2) {
    this.type = void 0, this.db = void 0, this._query = void 0, this.db = e2, this.type = "query", this._query = t2;
  }
};
var Tf = class {
};
var Sf = class extends Tf {
};
var Nf = class extends Sf {
  constructor(e2, t2, r2) {
    super(), this._field = void 0, this._op = void 0, this._value = void 0, this.type = "where", this._field = e2, this._op = t2, this._value = r2;
  }
  static _create(e2, t2, r2) {
    return new Nf(e2, t2, r2);
  }
  _apply(e2) {
    const t2 = this._parse();
    return new _f(e2.db, "collection" == e2.type ? { filters: [t2], limit: null, collection: e2 } : function(e3, t3) {
      const r2 = e3.filters.concat([t3]);
      return Af({}, e3, { filters: r2 });
    }(e2._query, t2));
  }
  _parse() {
    return function(e2, t2, r2) {
      const n2 = function(e3) {
        if (e3 === yf.EQUAL)
          return re.EQUAL;
        throw new Error("the op is not supported");
      }(t2), i2 = function(e3) {
        return "string" == typeof e3 ? { valueType: { oneofKind: "stringValue", stringValue: e3 } } : "boolean" == typeof e3 ? { valueType: { oneofKind: "booleanValue", booleanValue: e3 } } : { valueType: { oneofKind: void 0 } };
      }(r2);
      return { filterType: { oneofKind: "fieldFilter", fieldFilter: { field: e2, op: n2, value: i2 } } };
    }(this._field, this._op, this._value);
  }
};
function If(e2, t2, r2) {
  return Nf._create(e2, t2, r2);
}
function Of(e2, ...t2) {
  if (0 == t2.length)
    throw new Error("bad query constraint len");
  for (const r2 of t2)
    e2 = r2._apply(e2);
  return e2;
}
var Uf = class {
  constructor(e2, t2) {
    this.docs = void 0, this.db = void 0, this.db = e2, this.docs = t2;
  }
  get empty() {
    return 0 == this.docs.length;
  }
  get size() {
    return this.docs.length;
  }
};
var Lf = class extends Sf {
  constructor(e2, t2) {
    super(), this.type = void 0, this._limit = void 0, this.type = e2, this._limit = t2;
  }
  static _create(e2, t2) {
    return new Lf(e2, t2);
  }
  _apply(e2) {
    return new _f(e2.db, function(e3, t2) {
      return Af({}, e3, { limit: { limit: t2 } });
    }("collection" == e2.type ? { filters: [], limit: null, collection: e2 } : e2._query, this._limit));
  }
};
function kf(e2) {
  return Lf._create("limit", e2);
}
var Mf = class extends _f {
  constructor(e2, t2) {
    super(e2), this.type = "collection", this.db = void 0, this.name = void 0, this.name = t2, this.db = e2;
  }
};
function Cf(e2, t2, r2) {
  return new Promise((n2, i2) => {
    e2.getCollections(t2).then((i3) => {
      i3 ? n2(new Mf(e2, t2)) : e2.client.createCollection(e2.address, t2, r2).then((r3) => {
        n2(new Mf(e2, t2));
      });
    });
  });
}
var Pf = class {
  constructor(e2, t2) {
    this.type = "document", this.collection = void 0, this.entry = void 0, this.collection = e2, this.entry = t2;
  }
};
function Rf(e2, t2) {
  return new Promise((r2, n2) => {
    const i2 = e2.db;
    i2.client.createDocument(i2.address, e2.name, t2).then((e3) => {
      r2(e3);
    });
  });
}
function Df(e2) {
  return new Promise((t2, r2) => {
    const n2 = e2.db;
    if ("collection" == e2.type) {
      const r3 = e2;
      n2.client.runQuery(n2.address, { collectionName: r3.name }).then((e3) => {
        const i2 = e3.map((e4) => new Pf(r3, e4));
        t2(new Uf(n2, i2));
      });
    } else {
      const r3 = e2._query, i2 = r3.collection, o2 = { collectionName: r3.collection.name };
      r3.filters.length > 0 && (o2.where = r3.filters[0]), null != r3.limit && (o2.limit = r3.limit), n2.client.runQuery(n2.address, o2).then((e3) => {
        const r4 = e3.map((e4) => new Pf(i2, e4));
        t2(new Uf(n2, r4));
      });
    }
  });
}
function zf(e2) {
  const t2 = e2.collection.db, r2 = e2.entry.id;
  return new Promise((n2, i2) => {
    t2.client.deleteDocument(t2.address, e2.collection.name, [r2]).then(() => {
      n2();
    });
  });
}
function $f(e2, t2) {
  const r2 = e2.collection.db, n2 = Object.keys(t2), i2 = e2.entry.doc, o2 = e2.entry.id;
  for (const e3 in t2)
    i2[e3] = t2[e3];
  return new Promise((t3, s2) => {
    r2.client.updateDocument(r2.address, e2.collection.name, i2, o2, n2).then(() => {
      t3();
    });
  });
}
export {
  X as Account,
  bf as DB3Account,
  Ai as DB3BrowserWallet,
  mf as DB3Client,
  wf as DB3Store,
  Pf as DocumentReference,
  se as Index,
  Hs as MetamaskWallet,
  Rf as addDoc,
  vf as bytesToReadableNum,
  Cf as collection,
  zf as deleteDoc,
  Df as getDocs,
  Bf as initializeDB3,
  kf as limit,
  Of as query,
  Ef as unitsToReadableNum,
  $f as updateDoc,
  If as where
};
//# sourceMappingURL=db3__js.js.map
